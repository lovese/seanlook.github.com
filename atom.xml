<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sean&#39;s Notes</title>
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://seanlook.com/"/>
  <updated>2017-03-11T08:32:49.000Z</updated>
  <id>http://seanlook.com/</id>
  
  <author>
    <name>seanlook</name>
    <email>seanlook7@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>index merge 引起的死锁分析</title>
    <link href="http://seanlook.com/2017/03/11/mysql-index_merge-deadlock/"/>
    <id>http://seanlook.com/2017/03/11/mysql-index_merge-deadlock/</id>
    <published>2017-03-11T08:32:49.000Z</published>
    <updated>2017-03-11T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在看线上一个 MySQL innodb status 时，发现有死锁信息，而且出现的频率还不低。于是分析了一下，把过程记录下来。</p>
<h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h2><p>表结构脱敏处理：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_mytb1 (</div><div class="line">  f_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  f_fid <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  f_sid <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  f_mode <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</div><div class="line">  f_read <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  f_xxx1 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  f_xxx2 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  f_wx_zone <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (f_id),</div><div class="line">  <span class="keyword">KEY</span> idx_sid (f_sid),</div><div class="line">  <span class="keyword">KEY</span> idx_fid (f_fid)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</div></pre></td></tr></table></figure></p>
<p>死锁信息：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">LATEST DETECTED DEADLOCK</div><div class="line">------------------------</div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">58</span>:<span class="number">29</span> <span class="number">7</span>f25a3efd700</div><div class="line">*** (<span class="number">1</span>) TRANSACTION:</div><div class="line">TRANSACTION <span class="number">4907718431</span>, ACTIVE <span class="number">0.010</span> sec fetching rows</div><div class="line">mysql tables <span class="keyword">in</span> use <span class="number">3</span>, locked <span class="number">3</span></div><div class="line">LOCK WAIT <span class="number">154</span> lock struct(s), heap size <span class="number">30248</span>, <span class="number">10</span> row lock(s)</div><div class="line">LOCK BLOCKING MySQL thread id: <span class="number">13589250</span> block <span class="number">13589247</span></div><div class="line">MySQL thread id <span class="number">13589247</span>, OS thread handle <span class="number">0x7f25a17e3700</span>, query id <span class="number">27061926722</span> <span class="number">11.</span>xx<span class="number">.52</span>.xx ecweb Searching rows <span class="keyword">for</span> update</div><div class="line">UPDATE `d_db1`.`t_mytb1` <span class="keyword">SET</span> `f_read` = f_read+<span class="number">1</span> WHERE (f_fid=<span class="number">91243</span>) <span class="keyword">AND</span> (f_sid=<span class="number">100</span>) <span class="keyword">AND</span> (f_mode=<span class="comment">'浏览器')</span></div><div class="line">*** (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</div><div class="line">RECORD LOCKS <span class="built_in">space</span> id <span class="number">13288</span> page no <span class="number">375</span> n bits <span class="number">352</span> index `PRIMARY` of table `d_db1`.`t_mytb1` trx id <span class="number">4907718431</span> lock_mode X locks rec but <span class="keyword">not</span> gap waiting</div><div class="line">Record lock, heap no <span class="number">245</span> PHYSICAL RECORD: n_fields <span class="number">10</span>; compact format; info bits <span class="number">0</span></div><div class="line"> <span class="number">0</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000</span>a63b; <span class="built_in">asc</span>    ;;;</div><div class="line"> <span class="number">1</span>: <span class="built_in">len</span> <span class="number">6</span>; <span class="built_in">hex</span> <span class="number">0001246304</span>a7; <span class="built_in">asc</span>   $c  ;;</div><div class="line"> <span class="number">2</span>: <span class="built_in">len</span> <span class="number">7</span>; <span class="built_in">hex</span> <span class="number">7</span>f000ac0162428; <span class="built_in">asc</span>      $(;;</div><div class="line"> <span class="number">3</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00016470</span>; <span class="built_in">asc</span>   dp;;</div><div class="line"> <span class="number">4</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000064</span>; <span class="built_in">asc</span>    d;;</div><div class="line"> <span class="number">5</span>: <span class="built_in">len</span> <span class="number">9</span>; <span class="built_in">hex</span> e6b58fe8a788e599a8; <span class="built_in">asc</span>          ;;</div><div class="line"> <span class="number">6</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000244</span>f; <span class="built_in">asc</span>   $O;;</div><div class="line"> <span class="number">7</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000007</span>c; <span class="built_in">asc</span>    |;;</div><div class="line"> <span class="number">8</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000000</span>; <span class="built_in">asc</span>     ;;</div><div class="line"> <span class="number">9</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000000</span>; <span class="built_in">asc</span>     ;;</div><div class="line"></div><div class="line">*** (<span class="number">2</span>) TRANSACTION:</div><div class="line">TRANSACTION <span class="number">4907718435</span>, ACTIVE <span class="number">0.007</span> sec fetching rows</div><div class="line">mysql tables <span class="keyword">in</span> use <span class="number">3</span>, locked <span class="number">3</span></div><div class="line"><span class="number">154</span> lock struct(s), heap size <span class="number">30248</span>, <span class="number">3</span> row lock(s)</div><div class="line">MySQL thread id <span class="number">13589250</span>, OS thread handle <span class="number">0x7f25a3efd700</span>, query id <span class="number">27061926757</span> <span class="number">11.</span>xx<span class="number">.104</span>.xxx ecweb Searching rows <span class="keyword">for</span> update</div><div class="line">UPDATE `d_db1`.`t_mytb1` <span class="keyword">SET</span> `f_read` = f_read+<span class="number">1</span> WHERE (f_fid=<span class="number">91248</span>) <span class="keyword">AND</span> (f_sid=<span class="number">100</span>) <span class="keyword">AND</span> (f_mode=<span class="comment">'浏览器')</span></div><div class="line">*** (<span class="number">2</span>) HOLDS THE LOCK(S):</div><div class="line">RECORD LOCKS <span class="built_in">space</span> id <span class="number">13288</span> page no <span class="number">375</span> n bits <span class="number">352</span> index `PRIMARY` of table `d_db1`.`t_mytb1` trx id <span class="number">4907718435</span> lock_mode X locks rec but <span class="keyword">not</span> gap</div><div class="line">Record lock, heap no <span class="number">245</span> PHYSICAL RECORD: n_fields <span class="number">10</span>; compact format; info bits <span class="number">0</span></div><div class="line"> <span class="number">0</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000</span>a63b; <span class="built_in">asc</span>    ;;;  -- <span class="number">42555</span></div><div class="line"> <span class="number">1</span>: <span class="built_in">len</span> <span class="number">6</span>; <span class="built_in">hex</span> <span class="number">0001246304</span>a7; <span class="built_in">asc</span>   $c  ;;  -- <span class="number">4905436327</span></div><div class="line"> <span class="number">2</span>: <span class="built_in">len</span> <span class="number">7</span>; <span class="built_in">hex</span> <span class="number">7</span>f000ac0162428; <span class="built_in">asc</span>      $(;;</div><div class="line"> <span class="number">3</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00016470</span>; <span class="built_in">asc</span>   dp;;  -- <span class="number">91248</span></div><div class="line"> <span class="number">4</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000064</span>; <span class="built_in">asc</span>    d;;  -- <span class="number">100</span></div><div class="line"> <span class="number">5</span>: <span class="built_in">len</span> <span class="number">9</span>; <span class="built_in">hex</span> e6b58fe8a788e599a8; <span class="built_in">asc</span>          ;;</div><div class="line"> <span class="number">6</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000244</span>f; <span class="built_in">asc</span>   $O;;  -- <span class="number">9295</span></div><div class="line"> <span class="number">7</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000007</span>c; <span class="built_in">asc</span>    |;;  -- <span class="number">124</span></div><div class="line"> <span class="number">8</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000000</span>; <span class="built_in">asc</span>     ;;</div><div class="line"> <span class="number">9</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000000</span>; <span class="built_in">asc</span>     ;;</div><div class="line"></div><div class="line">*** (<span class="number">2</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</div><div class="line">RECORD LOCKS <span class="built_in">space</span> id <span class="number">13288</span> page no <span class="number">202</span> n bits <span class="number">1272</span> index `idx_sid` of table `d_db1`.`t_mytb1` trx id <span class="number">4907718435</span> lock_mode X locks rec but <span class="keyword">not</span> gap waiting</div><div class="line">Record lock, heap no <span class="number">705</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></div><div class="line"> <span class="number">0</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">00000064</span>; <span class="built_in">asc</span>    d;;  -- <span class="number">100</span></div><div class="line"> <span class="number">1</span>: <span class="built_in">len</span> <span class="number">4</span>; <span class="built_in">hex</span> <span class="number">0000</span>a633; <span class="built_in">asc</span>    <span class="number">3</span>;;  -- <span class="number">42547</span></div><div class="line"></div><div class="line">*** WE ROLL BACK TRANSACTION (<span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<p>乍一看很奇怪，tx1和tx2 两个 UPDATE 各自以 f_fid 为条件更新的记录互不影响才对，即使 91243，91248 两个值有可能出现在同一条数据上（因为f_fid上是二级索引），那顶多也就是个更新锁等待，谁后来谁等待，怎么会出现互相争用对方已持有的锁，被死锁检测机制捕获？</p>
<p>当然,把 update 语句拿到数据库中 EXPLAIN 一下就可以看出端倪。这里不妨先分析一下输出的锁情况：</p>
<p><strong>先看 Tx2 (对应trx id 4907718435)</strong> :  </p>
<ol>
<li><p><code>RECORD LOCKS space id 13288 page no 375 n bits 352</code> 告诉我们是表空间id 13288 (可从 <code>information_schema.INNODB_SYS_DATAFILES</code> 查到对应ibd文件) 即 t_mytb1 表，第 375 号页面的 245 位置的记录被锁，并且是 idx PRIMARY 上的记录锁（注：本实例隔离级别为RC）。 Tx2正持有这把记录锁。<br>因为是聚集索引，显示了完整记录</p>
<figure class="highlight ldif"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">0</span>: 主键f_id=42555</div><div class="line"><span class="attribute">1</span>: DB_TRX_ID = 4905436327</div><div class="line"><span class="attribute">2</span>: DB_ROLL_PTR指向undo记录的地址</div><div class="line"><span class="attribute">3</span>: f_fid=91248</div><div class="line"><span class="attribute">4</span>: f_sid=100</div><div class="line">   ...</div></pre></td></tr></table></figure>
</li>
<li><p>然而Tx2还在等待一个记录锁（lock_mode X locks rec but not gap waiting），但这把锁来自二级索引 <code>idx_sid</code> 索引上的记录锁。在 RC 级别下没有GAP lock，行锁除了加在符合条件的二级索引 f_sid=100 上外，还会对主键加record lock。<br>二级索引值：</p>
<a id="more"></a>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">0</span>: f_sid=100</div><div class="line"><span class="attribute">1</span>: 主键f_id=42547</div></pre></td></tr></table></figure>
</li>
</ol>
<p>明显它们是两条不同的记录。</p>
<p><strong>再看 Tx1（对应trx id 4907718431）</strong><br>Tx1 事务等待的锁，就是上面 Tx2 已持有的记录锁 f_id=42555 。但是由于输出的关系，没有看到它持有的锁。既然这里出现死锁，可以推断，Tx1执行update时，已获得 f_id=42547 的记录锁，这样才导致死锁，否则的话只会出现一方等待。示意图如下：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-secondary-index-merge.png" alt=""></p>
<p>InnoDB最终选择回滚 Tx2 是可以理解的 —— 它只获得了一个记录锁，资源占用最少。目前还无法解释的是关于锁数量这一部分：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql tables in <span class="keyword">use</span> <span class="number">3</span>, <span class="keyword">locked</span> <span class="number">3</span></div><div class="line"><span class="number">154</span> <span class="keyword">lock</span> <span class="keyword">struct</span>(s), <span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">30248</span>, <span class="number">3</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s)</div></pre></td></tr></table></figure></p>
<h2 id="2-死锁产生的原因-——-index-merge"><a href="#2-死锁产生的原因-——-index-merge" class="headerlink" title="2. 死锁产生的原因 —— index merge"></a>2. 死锁产生的原因 —— index merge</h2><p>上面任何一个 update 的explain结果：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-index_merge-deadlock.png" alt=""></p>
<p>可以看到 EXTRA 列 <code>Using intersect(idx_sid, idx_fid)</code>。</p>
<p>索引合并是 5.0 就引入的一种优化手段，意指在查询语句里，可以在一个表上使用多个索引，同时扫描，最后进行结果合并。上面的例子里，条件 <code>f_fid=xxx and f_sid=xxx</code>，因为表上有 <em>f_fid</em> 和 <em>f_sid</em> 两个单列索引，优化器在成本模型里进行估算，认为一边使用 f_fid=91243 索引扫描，一边使用 f_sid=100 索引扫描，然后对两个结果集取交集，会更快。结果在高并发更新情况下：</p>
<ul>
<li>Tx2通过 f_fid 索引锁住了记录 42555，欲通过 f_sid 锁定另一条记录 42547</li>
<li>Tx1 已通过 f_sid 锁定 42547，欲通过 f_fid 锁住记录42555</li>
<li>死锁发生</li>
</ul>
<h3 id="关于索引合并"><a href="#关于索引合并" class="headerlink" title="关于索引合并"></a>关于索引合并</h3><p>intersection 只是 索引合并中的一种，还有 union, sort_union 。可以用到  index_merge 是有比较苛刻的条件。</p>
<ol>
<li>首先是 Range 优先(&gt;5.6.7)。比如 key1=1 or (key1=2 and key2=3)，其中key1是可以转化成 range scan 的，不会使用 index merge union</li>
<li>其次，Intersect和Union要符合 ROR，即 Rowid-Ordered-Retrival：<blockquote>
<p>Intersect和Union都需要使用的索引是ROR的，也就时ROWID ORDERED，即针对不同的索引扫描出来的数据必须是同时按照ROWID排序的，这里的 ROWID其实也就是InnoDB的主键(如果不定义主键，InnoDB会隐式添加ROWID列作为主键)。只有每个索引是ROR的，才能进行归并排序，你懂的。 当然你可能会有疑惑，查不记录后内部进行一次sort不一样么，何必必须要ROR呢，不错，所以有了SORT-UNION。SORT-UNION就是每个非ROR的索引 排序后再进行Merge<br> – 来自 <a href="http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html" target="_blank" rel="external">http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html</a></p>
</blockquote>
</li>
</ol>
<p>像 <em>key1=v1 or key2=v2</em> ， key1与key2是单列索引，并且无其它索引可用，就有可能看到 Using Union(xx,xxx) 。更多内容可见参考链接。</p>
<h2 id="3-解决-——-加联合索引"><a href="#3-解决-——-加联合索引" class="headerlink" title="3. 解决 —— 加联合索引"></a>3. 解决 —— 加联合索引</h2><p>解决这个死锁可能你也想到了，添加联合索引 <code>idx_fid_sid(f_fid, f_sid)</code>，这样一来查询会选择这一个索引，至于 idx_sid 这个单列索引还需不需要，看业务场景。</p>
<p>另外，如果懂点业务的话，会发现这个更新之所以这么频繁，实际上是一个阅读量计数的功能，放到redis里可极大的提高并发能力，定时持久化到mysql表。</p>
<p>最后提一句 index_merge 是有选项可以关闭的：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select @@optimizer_switch;</div><div class="line">index_merge=<span class="keyword">on</span>,index_merge_union=<span class="keyword">on</span>,index_merge_sort_union=<span class="keyword">on</span>,index_merge_intersection=<span class="keyword">on</span> ...</div></pre></td></tr></table></figure></p>
<p>如果优化器选择了index_merge，一般是索引没建好，我看不让它使用比较更好。</p>
<p><strong> 参考文章 </strong>  </p>
<ol>
<li><a href="http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/" target="_blank" rel="external">MySQL优化器：index merge介绍</a></li>
<li><a href="http://hidba.org/?p=1065" target="_blank" rel="external">MySQL update use index merge(Using intersect) increase chances for deadlock</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html</a></li>
</ol>
<hr>
<p>  原文链接地址：<a href="http://seanlook.com/2017/03/11/mysql-index_merge-deadlock/">http://seanlook.com/2017/03/11/mysql-index_merge-deadlock/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看线上一个 MySQL innodb status 时，发现有死锁信息，而且出现的频率还不低。于是分析了一下，把过程记录下来。&lt;/p&gt;
&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h2&gt;&lt;p&gt;表结构脱敏处理：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; t_mytb1 (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_id &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_fid &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_sid &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_mode &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_read &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_xxx1 &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_xxx2 &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  f_wx_zone &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (f_id),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; idx_sid (f_sid),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; idx_fid (f_fid)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8mb4;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;死锁信息：&lt;br&gt;&lt;figure class=&quot;highlight vbscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;LATEST DETECTED DEADLOCK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;------------------------&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-02&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-28&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;58&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;f25a3efd700&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) TRANSACTION:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;TRANSACTION &lt;span class=&quot;number&quot;&gt;4907718431&lt;/span&gt;, ACTIVE &lt;span class=&quot;number&quot;&gt;0.010&lt;/span&gt; sec fetching rows&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql tables &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; use &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, locked &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;LOCK WAIT &lt;span class=&quot;number&quot;&gt;154&lt;/span&gt; lock struct(s), heap size &lt;span class=&quot;number&quot;&gt;30248&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; row lock(s)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;LOCK BLOCKING MySQL thread id: &lt;span class=&quot;number&quot;&gt;13589250&lt;/span&gt; block &lt;span class=&quot;number&quot;&gt;13589247&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MySQL thread id &lt;span class=&quot;number&quot;&gt;13589247&lt;/span&gt;, OS thread handle &lt;span class=&quot;number&quot;&gt;0x7f25a17e3700&lt;/span&gt;, query id &lt;span class=&quot;number&quot;&gt;27061926722&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11.&lt;/span&gt;xx&lt;span class=&quot;number&quot;&gt;.52&lt;/span&gt;.xx ecweb Searching rows &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; update&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UPDATE `d_db1`.`t_mytb1` &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; `f_read` = f_read+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; WHERE (f_fid=&lt;span class=&quot;number&quot;&gt;91243&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; (f_sid=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; (f_mode=&lt;span class=&quot;comment&quot;&gt;&#39;浏览器&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) WAITING &lt;span class=&quot;keyword&quot;&gt;FOR&lt;/span&gt; THIS LOCK &lt;span class=&quot;keyword&quot;&gt;TO&lt;/span&gt; BE GRANTED:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RECORD LOCKS &lt;span class=&quot;built_in&quot;&gt;space&lt;/span&gt; id &lt;span class=&quot;number&quot;&gt;13288&lt;/span&gt; page no &lt;span class=&quot;number&quot;&gt;375&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;352&lt;/span&gt; index `PRIMARY` of table `d_db1`.`t_mytb1` trx id &lt;span class=&quot;number&quot;&gt;4907718431&lt;/span&gt; lock_mode X locks rec but &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; gap waiting&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Record lock, heap no &lt;span class=&quot;number&quot;&gt;245&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; compact format; info bits &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt;a63b; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    ;;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0001246304&lt;/span&gt;a7; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   $c  ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;f000ac0162428; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;      $(;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00016470&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   dp;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000064&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    d;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; e6b58fe8a788e599a8; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;          ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000244&lt;/span&gt;f; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   $O;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000007&lt;/span&gt;c; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    |;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;     ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;     ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) TRANSACTION:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;TRANSACTION &lt;span class=&quot;number&quot;&gt;4907718435&lt;/span&gt;, ACTIVE &lt;span class=&quot;number&quot;&gt;0.007&lt;/span&gt; sec fetching rows&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql tables &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; use &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, locked &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;154&lt;/span&gt; lock struct(s), heap size &lt;span class=&quot;number&quot;&gt;30248&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; row lock(s)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MySQL thread id &lt;span class=&quot;number&quot;&gt;13589250&lt;/span&gt;, OS thread handle &lt;span class=&quot;number&quot;&gt;0x7f25a3efd700&lt;/span&gt;, query id &lt;span class=&quot;number&quot;&gt;27061926757&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11.&lt;/span&gt;xx&lt;span class=&quot;number&quot;&gt;.104&lt;/span&gt;.xxx ecweb Searching rows &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; update&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UPDATE `d_db1`.`t_mytb1` &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; `f_read` = f_read+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; WHERE (f_fid=&lt;span class=&quot;number&quot;&gt;91248&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; (f_sid=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; (f_mode=&lt;span class=&quot;comment&quot;&gt;&#39;浏览器&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) HOLDS THE LOCK(S):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RECORD LOCKS &lt;span class=&quot;built_in&quot;&gt;space&lt;/span&gt; id &lt;span class=&quot;number&quot;&gt;13288&lt;/span&gt; page no &lt;span class=&quot;number&quot;&gt;375&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;352&lt;/span&gt; index `PRIMARY` of table `d_db1`.`t_mytb1` trx id &lt;span class=&quot;number&quot;&gt;4907718435&lt;/span&gt; lock_mode X locks rec but &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; gap&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Record lock, heap no &lt;span class=&quot;number&quot;&gt;245&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; compact format; info bits &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt;a63b; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    ;;;  -- &lt;span class=&quot;number&quot;&gt;42555&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0001246304&lt;/span&gt;a7; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   $c  ;;  -- &lt;span class=&quot;number&quot;&gt;4905436327&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;f000ac0162428; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;      $(;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00016470&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   dp;;  -- &lt;span class=&quot;number&quot;&gt;91248&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000064&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    d;;  -- &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; e6b58fe8a788e599a8; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;          ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000244&lt;/span&gt;f; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;   $O;;  -- &lt;span class=&quot;number&quot;&gt;9295&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000007&lt;/span&gt;c; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    |;;  -- &lt;span class=&quot;number&quot;&gt;124&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;     ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000000&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;     ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) WAITING &lt;span class=&quot;keyword&quot;&gt;FOR&lt;/span&gt; THIS LOCK &lt;span class=&quot;keyword&quot;&gt;TO&lt;/span&gt; BE GRANTED:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RECORD LOCKS &lt;span class=&quot;built_in&quot;&gt;space&lt;/span&gt; id &lt;span class=&quot;number&quot;&gt;13288&lt;/span&gt; page no &lt;span class=&quot;number&quot;&gt;202&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;1272&lt;/span&gt; index `idx_sid` of table `d_db1`.`t_mytb1` trx id &lt;span class=&quot;number&quot;&gt;4907718435&lt;/span&gt; lock_mode X locks rec but &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; gap waiting&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Record lock, heap no &lt;span class=&quot;number&quot;&gt;705&lt;/span&gt; PHYSICAL RECORD: n_fields &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; compact format; info bits &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00000064&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    d;;  -- &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0000&lt;/span&gt;a633; &lt;span class=&quot;built_in&quot;&gt;asc&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;;  -- &lt;span class=&quot;number&quot;&gt;42547&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** WE ROLL BACK TRANSACTION (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;乍一看很奇怪，tx1和tx2 两个 UPDATE 各自以 f_fid 为条件更新的记录互不影响才对，即使 91243，91248 两个值有可能出现在同一条数据上（因为f_fid上是二级索引），那顶多也就是个更新锁等待，谁后来谁等待，怎么会出现互相争用对方已持有的锁，被死锁检测机制捕获？&lt;/p&gt;
&lt;p&gt;当然,把 update 语句拿到数据库中 EXPLAIN 一下就可以看出端倪。这里不妨先分析一下输出的锁情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看 Tx2 (对应trx id 4907718435)&lt;/strong&gt; :  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;RECORD LOCKS space id 13288 page no 375 n bits 352&lt;/code&gt; 告诉我们是表空间id 13288 (可从 &lt;code&gt;information_schema.INNODB_SYS_DATAFILES&lt;/code&gt; 查到对应ibd文件) 即 t_mytb1 表，第 375 号页面的 245 位置的记录被锁，并且是 idx PRIMARY 上的记录锁（注：本实例隔离级别为RC）。 Tx2正持有这把记录锁。&lt;br&gt;因为是聚集索引，显示了完整记录&lt;/p&gt;
&lt;figure class=&quot;highlight ldif&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;0&lt;/span&gt;: 主键f_id=42555&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;1&lt;/span&gt;: DB_TRX_ID = 4905436327&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;: DB_ROLL_PTR指向undo记录的地址&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;3&lt;/span&gt;: f_fid=91248&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;4&lt;/span&gt;: f_sid=100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然而Tx2还在等待一个记录锁（lock_mode X locks rec but not gap waiting），但这把锁来自二级索引 &lt;code&gt;idx_sid&lt;/code&gt; 索引上的记录锁。在 RC 级别下没有GAP lock，行锁除了加在符合条件的二级索引 f_sid=100 上外，还会对主键加record lock。&lt;br&gt;二级索引值：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="mysql优化" scheme="http://seanlook.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL根据离线binlog快速“闪回”</title>
    <link href="http://seanlook.com/2017/03/03/mysql-flashback_use_purged-binlog/"/>
    <id>http://seanlook.com/2017/03/03/mysql-flashback_use_purged-binlog/</id>
    <published>2017-03-03T08:32:49.000Z</published>
    <updated>2017-03-03T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天突然有个客户说误操作，自己删除了大量数据，CTO直接将我拉到一个讨论组里，说要帮他们恢复数据。他们自己挖的坑，打算让开发那边根据业务日志去恢复，被告知只记录的删除主键这样的信息，物理删除，无能为力。</p>
<p>上服务器看了下记录的日志，发现好几台上面都有被误删的记录输出。阿里RDS虽然可以克隆一个恢复到删除时间点前的实例，但这散落的几万个id找起来费力，还有就是几个表之间关联的数据也要恢复，觉得麻烦。</p>
<p>想到 MySQL 的闪回方案。以前看过好几篇相关文章，甚至差点自己用python撸一个来解析binlog，反转得到回滚sql，实在没空，这下要急用了。赶紧找了下网上“现成的方案”。</p>
<p>正文开始</p>
<hr>
<p>MySQL（含阿里RDS）快速闪回可以说是对数据库误操作的后悔药，flashback功能可以将数据库返回到误操作之前。但是即使oracle数据库也只支持短时间内的闪回。</p>
<p>网上现有开源的MySQL闪回实现，原理都是解析binlog，生成反向sql: (必须为row模式)</p>
<ol>
<li>对于 delete 操作，生成insert （DELETE_ROWS_EVENT）</li>
<li>对于 update 操作，交换binlog里面值的顺序 （UPDATE_ROWS_EVENT）</li>
<li>对于 insert 操作，反向生成delete （WRITE_ROWS_EVENT）</li>
<li>对于多个event，要逆向生成sql</li>
</ol>
<p>开源实现：</p>
<ul>
<li><a href="https://github.com/58daojia-dba/mysqlbinlog_flashback" target="_blank" rel="external">https://github.com/58daojia-dba/mysqlbinlog_flashback</a></li>
<li><a href="https://github.com/danfengcao/binlog2sql/" target="_blank" rel="external">https://github.com/danfengcao/binlog2sql/</a></li>
</ul>
<p>上面两种实现方式，都是通过 python-mysql-replication 包，模拟出原库的一个从库，然后 <code>show binary logs</code> 来获取binlog，发起同步binlog的请求，再解析EVENT。但是阿里云 RDS 的binlog在同步给从库之后，<strong> 很快就被 purge 掉了 </strong>。如果要恢复 <strong> 昨天</strong> 的 <strong> 部分数据 </strong>，两种方案都是拿不到binlog的。也就是闪回的时间有限。</p>
<p>还有一些比较简单的实现，就是解析 binlog 物理文件，实现回滚，如 <code>binlog-rollback.pl</code> ，试过，但是速度太慢。</p>
<p>为了不影响速度，又想使用比较成熟的闪回方案，我们可以这样做：</p>
<ol>
<li>借助一个自建的 mysqld 实例，将已purge掉的binlog拷贝到该实例的目录下</li>
<li>在自建实例里，提前创建好需要恢复的表（结构），因为工具需要连接上来从 <code>information_schema.columns</code> 获取元数据信息</li>
<li>拷贝的时候，可以替换掉mysql实例自己的binlog文件名，保持连续</li>
<li>可能要修改 <code>mysql-bin.index</code>，确保文件名还能被mysqld识别到</li>
<li>重启mysql实例，<code>show binary logs</code> 看一下是否在列表里面</li>
<li>接下来就可以使用上面任何一种工具，模拟从库，指定一个binlog文件，开始时间，结束时间，得到回滚SQL</li>
<li>再根据业务逻辑，筛选出需要的sql</li>
</ol>
<a id="more"></a>
<p>总之就是借助另外一个mysql，把binlog event传输过来。温馨提示：</p>
<ol>
<li>两个实例间版本不要跨度太大</li>
<li>注意文件权限</li>
<li>如果原库开启了gtid，这个自建实例也要开启gtid</li>
</ol>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">python mysqlbinlog_back.py --host=<span class="string">"localhost"</span> --username=<span class="string">"ecuser"</span> --password=<span class="string">"ecuser"</span> --port=<span class="number">3306</span> \</div><div class="line">--schema=dbname --tables=<span class="string">"t_xx1,t_xx2,t_xx3"</span> -S <span class="string">"mysql-bin.000019"</span> -E <span class="string">"2017-03-02 13:00:00"</span> -N <span class="string">"2017-03-02 14:09:00"</span> -I -U</div><div class="line"></div><div class="line">===log will also  write to .//mysqlbinlog_flashback.log===</div><div class="line">parameter=&#123;<span class="string">'start_binlog_file'</span>: <span class="string">'mysql-bin.000019'</span>, <span class="string">'stream'</span>: <span class="keyword">None</span>, <span class="string">'keep_data'</span>: <span class="keyword">True</span>,</div><div class="line"> <span class="string">'file'</span>: &#123;<span class="string">'data_create'</span>: <span class="keyword">None</span>, <span class="string">'flashback'</span>: <span class="keyword">None</span>, <span class="string">'data'</span>: <span class="keyword">None</span>&#125;, <span class="string">'add_schema_name'</span>: <span class="keyword">False</span>, <span class="string">'start_time'</span>: <span class="keyword">None</span>, <span class="string">'keep_current_data'</span>: <span class="keyword">False</span>, <span class="string">'start_to_timestamp'</span>: <span class="number">1488430800</span>,</div><div class="line"> <span class="string">'mysql_setting'</span>: &#123;<span class="string">'passwd'</span>: <span class="string">'ecuser'</span>, <span class="string">'host'</span>: <span class="string">'localhost'</span>, <span class="string">'charset'</span>: <span class="string">'utf8'</span>, <span class="string">'port'</span>: <span class="number">3306</span>, <span class="string">'user'</span>: <span class="string">'ecuser'</span>&#125;,</div><div class="line"> <span class="string">'table_name'</span>: <span class="string">'t_xx1,t_xx2,t_xx3'</span>, <span class="string">'skip_delete'</span>: <span class="keyword">False</span>, <span class="string">'schema'</span>: <span class="string">'dbname'</span>, <span class="string">'stat'</span>: &#123;<span class="string">'flash_sql'</span>: &#123;&#125;&#125;,</div><div class="line"> <span class="string">'table_name_array'</span>: [<span class="string">'t_xx1'</span>, <span class="string">'t_xx2'</span>, <span class="string">'t_xx3'</span>],</div><div class="line"> <span class="string">'one_binlog_file'</span>: <span class="keyword">False</span>, <span class="string">'output_file_path'</span>: <span class="string">'./log'</span>, <span class="string">'start_position'</span>: <span class="number">4</span>, <span class="string">'skip_update'</span>: <span class="keyword">True</span>,</div><div class="line"> <span class="string">'dump_event'</span>: <span class="keyword">False</span>, <span class="string">'end_to_timestamp'</span>: <span class="number">1488434940</span>, <span class="string">'skip_insert'</span>: <span class="keyword">True</span>, <span class="string">'schema_array'</span>: [<span class="string">'dbname'</span>]</div><div class="line">&#125;</div><div class="line">scan <span class="number">10000</span> events ....<span class="keyword">from</span> binlogfile=mysql-bin<span class="number">.000019</span>,timestamp=<span class="number">2017</span><span class="number">-03</span><span class="number">-02</span>T11:<span class="number">42</span>:<span class="number">14</span></div><div class="line">scan <span class="number">20000</span> events ....<span class="keyword">from</span> binlogfile=mysql-bin<span class="number">.000019</span>,timestamp=<span class="number">2017</span><span class="number">-03</span><span class="number">-02</span>T11:<span class="number">42</span>:<span class="number">29</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>提示：<br>binlog为ROW格式，dml影响的每一行都会记录两个event：Table_map和Row_log。而table_map里面的table_id并不会影响它在哪个实例上应用，这个id可以认为是逻辑上，记录表结构版本的机制 —— 当它在 table_definition_cache 没有找到表定义时，id自增1，分配给要记录到binlog的表。</p>
<p><strong>mysqlbinlog_back.py 使用经验</strong> ：</p>
<ul>
<li>务必指定库名、表明，开始的binlog文件名，起始时间，结束时间。可以加快scan的速度。</li>
<li>根据恢复的需要，选择 -I, -U, -D，指定回滚哪些类型的操作。</li>
<li>如果只是恢复部分表数据（非完全闪回），做不到关联表的正确恢复。比如需要恢复delete数据，但无法恢复业务里因为delete引起其它表更新的数据，除非完全闪回。</li>
<li>不支持表字段是 enum 类型的，比如 t_xx3 的f_do_type字段。可以把自建实例上的enum定义改成int。</li>
</ul>
<p><strong>参考</strong></p>
<ol>
<li><a href="http://dinglin.iteye.com/blog/1539167" target="_blank" rel="external">http://dinglin.iteye.com/blog/1539167</a></li>
<li><a href="http://www.penglixun.com/tech/database/mysql_flashback_feature.html/comment-page-1#comment-1207998" target="_blank" rel="external">http://www.penglixun.com/tech/database/mysql_flashback_feature.html/comment-page-1#comment-1207998</a></li>
<li><a href="http://www.cnblogs.com/yuyue2014/p/3721172.html" target="_blank" rel="external">http://www.cnblogs.com/yuyue2014/p/3721172.html</a></li>
</ol>
<hr>
<p>本文链接地址：<a href="http://seanlook.com/2017/03/03/mysql-flashback_use_purged-binlog/">http://seanlook.com/2017/03/03/mysql-flashback_use_purged-binlog/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天突然有个客户说误操作，自己删除了大量数据，CTO直接将我拉到一个讨论组里，说要帮他们恢复数据。他们自己挖的坑，打算让开发那边根据业务日志去恢复，被告知只记录的删除主键这样的信息，物理删除，无能为力。&lt;/p&gt;
&lt;p&gt;上服务器看了下记录的日志，发现好几台上面都有被误删的记录输出。阿里RDS虽然可以克隆一个恢复到删除时间点前的实例，但这散落的几万个id找起来费力，还有就是几个表之间关联的数据也要恢复，觉得麻烦。&lt;/p&gt;
&lt;p&gt;想到 MySQL 的闪回方案。以前看过好几篇相关文章，甚至差点自己用python撸一个来解析binlog，反转得到回滚sql，实在没空，这下要急用了。赶紧找了下网上“现成的方案”。&lt;/p&gt;
&lt;p&gt;正文开始&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;MySQL（含阿里RDS）快速闪回可以说是对数据库误操作的后悔药，flashback功能可以将数据库返回到误操作之前。但是即使oracle数据库也只支持短时间内的闪回。&lt;/p&gt;
&lt;p&gt;网上现有开源的MySQL闪回实现，原理都是解析binlog，生成反向sql: (必须为row模式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于 delete 操作，生成insert （DELETE_ROWS_EVENT）&lt;/li&gt;
&lt;li&gt;对于 update 操作，交换binlog里面值的顺序 （UPDATE_ROWS_EVENT）&lt;/li&gt;
&lt;li&gt;对于 insert 操作，反向生成delete （WRITE_ROWS_EVENT）&lt;/li&gt;
&lt;li&gt;对于多个event，要逆向生成sql&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开源实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/58daojia-dba/mysqlbinlog_flashback&quot;&gt;https://github.com/58daojia-dba/mysqlbinlog_flashback&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/danfengcao/binlog2sql/&quot;&gt;https://github.com/danfengcao/binlog2sql/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两种实现方式，都是通过 python-mysql-replication 包，模拟出原库的一个从库，然后 &lt;code&gt;show binary logs&lt;/code&gt; 来获取binlog，发起同步binlog的请求，再解析EVENT。但是阿里云 RDS 的binlog在同步给从库之后，&lt;strong&gt; 很快就被 purge 掉了 &lt;/strong&gt;。如果要恢复 &lt;strong&gt; 昨天&lt;/strong&gt; 的 &lt;strong&gt; 部分数据 &lt;/strong&gt;，两种方案都是拿不到binlog的。也就是闪回的时间有限。&lt;/p&gt;
&lt;p&gt;还有一些比较简单的实现，就是解析 binlog 物理文件，实现回滚，如 &lt;code&gt;binlog-rollback.pl&lt;/code&gt; ，试过，但是速度太慢。&lt;/p&gt;
&lt;p&gt;为了不影响速度，又想使用比较成熟的闪回方案，我们可以这样做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;借助一个自建的 mysqld 实例，将已purge掉的binlog拷贝到该实例的目录下&lt;/li&gt;
&lt;li&gt;在自建实例里，提前创建好需要恢复的表（结构），因为工具需要连接上来从 &lt;code&gt;information_schema.columns&lt;/code&gt; 获取元数据信息&lt;/li&gt;
&lt;li&gt;拷贝的时候，可以替换掉mysql实例自己的binlog文件名，保持连续&lt;/li&gt;
&lt;li&gt;可能要修改 &lt;code&gt;mysql-bin.index&lt;/code&gt;，确保文件名还能被mysqld识别到&lt;/li&gt;
&lt;li&gt;重启mysql实例，&lt;code&gt;show binary logs&lt;/code&gt; 看一下是否在列表里面&lt;/li&gt;
&lt;li&gt;接下来就可以使用上面任何一种工具，模拟从库，指定一个binlog文件，开始时间，结束时间，得到回滚SQL&lt;/li&gt;
&lt;li&gt;再根据业务逻辑，筛选出需要的sql&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于MySQL自增主键的几点问题（下）</title>
    <link href="http://seanlook.com/2017/02/17/mysql-autoincrement_2/"/>
    <id>http://seanlook.com/2017/02/17/mysql-autoincrement_2/</id>
    <published>2017-02-17T08:32:49.000Z</published>
    <updated>2017-02-17T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AUTO-INC-waiting-锁等待"><a href="#AUTO-INC-waiting-锁等待" class="headerlink" title="AUTO-INC waiting 锁等待"></a>AUTO-INC waiting 锁等待</h3><p>这是生产环境出现的现象，某日下午5点业务高峰期，我们的 <a href="http://seanlook.com/2016/09/27/python-mysql-querykill/">慢查询快照抓取程序</a> 报出大量线程阻塞，但是1分钟以后就好了。于是分析了当时的 processlist 和 innodb status 现场记录，发现有大量的 <code>AUTO-INC waiting</code>：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-1.png" alt="auto-inc-lock-wait"></p>
<p>当时想这是得多大的并发量，才会导致 AUTO_INCREMENT 列的自增id分配出现性能问题，不太愿意相信这个事实（后面就再也没出现过）。了解一番之后（见 <a href="http://seanlook.com/2017/02/16/mysql-autoincrement/">关于MySQLz自增主键问题（上篇）</a>），发现这个表级别的 AUTO-INC lock 就不应该在业务中存在，因为 <code>innodb_autoinc_lock_mode</code>为1，普通业务都是 simple inserts，获取自增id是靠内存里维护的一个互斥量（mutex counter）。</p>
<p>问题拿到知数堂优化班上课群里讨论过，也只是猜测是不是慢查询多了导致负载高，或者当时磁盘遇到什么物理故障阿里云那边自动恢复了。再后来怀疑是不是因为插入时带了 auto_increment 列的值（我们有个redis incr实现的自增id服务，虽然这一列有 AAUTO_INCREMENT 定义，但实际已经从发号器取id了），会导致锁的性质会变？</p>
<p>为了弄清这个疑问，特意去看了下mysql源码，发现如果插入的自增值比表当前AUTOINC值要大，是直接update mutex counter：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-mutex-update.png" alt=""></p>
<p>看源码的时候也打消了另一个疑虑：<code>show engine innodb status</code> 看到的 <code>AUTO-INC</code> 有没有可能不区分 表级自增锁和互斥量计数器 两种自增方案，只是告诉你自增id获取忙不过来？ 实际不是的，代码里面有明确的定义是 <code>autoinc_lock</code>还是<code>autoinc_mutex</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dict0dict.cc :</span></div><div class="line">#ifndef UNIV_HOTBACKUP</div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>/</span></span><span class="comment"><span class="markdown">/**</span></span></div><div class="line">Acquire the<span class="markdown"> autoinc lock. */</span></div><div class="line">UNIV_INTERN</div><div class="line"><span class="keyword">void</span></div><div class="line">dict_table_autoinc_lock(</div><div class="line"><span class="comment">/*====================*/</span></div><div class="line">4dict_table_t*	table)	<span class="comment">/*!&lt; in/out: table */</span></div><div class="line">&#123;</div><div class="line">4mutex_enter(&amp;table-&gt;autoinc_mutex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>/</span></span><span class="comment"><span class="markdown">/**</span></span></div><div class="line">Unconditionally set the<span class="markdown"> autoinc counter. */</span></div><div class="line">UNIV_INTERN</div><div class="line"><span class="keyword">void</span></div><div class="line">dict_table_autoinc_initialize(</div><div class="line"><span class="comment">/*==========================*/</span></div><div class="line">4dict_table_t*	table,	<span class="comment">/*!&lt; in/out: table */</span></div><div class="line">4ib_uint64_t	value)	<span class="comment">/*!&lt; in: next value to assign to a row */</span></div><div class="line">&#123;</div><div class="line">4ut_ad(mutex_own(&amp;table-&gt;autoinc_mutex));</div><div class="line"></div><div class="line">4table-&gt;autoinc = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>最后在微信上找周彦伟大神问问，在快要放弃的时候，从 innodb_lock_waits 中锁等待之间关系，一层一层挖，终于找到了一条这样的sql:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"<span class="keyword">INSERT</span> <span class="keyword">INTO</span> mydb1.t_mytable_inc ( f_log_id, f_fff_id, ..., f_from, f_sendmsg )</div><div class="line">    <span class="keyword">SELECT</span> <span class="number">2021712366</span>, <span class="number">507019984</span>, ..., <span class="number">10</span>, <span class="number">0</span> <span class="keyword">from</span> dual<span class="string">"</span></div></pre></td></tr></table></figure></p>
<p>瞬间就明(ma)白(niang)了。典型的 <code>INSERT ... SELECT ...</code>， 但是 select 子句带的全是常量，但是对 innodb 来说它还是认为“这是 bulk inserts，我无法预估插入行数”，所以使用表级锁的自增方式。当时同时有 22 个这样的插入，可能负载也确实比较高导致活跃事务里主键最小的那一条一直处于 <em>query end</em> 状态，后面简单insert也需要等这个 语句 结束，直到释放 AUTO-INC table lock，以致引起雪崩效应。</p>
<p>之所以一直没发现这条语句，是因为 processlist 太长了，而且格式不友好。快照抓取程序这块还可以优化。</p>
<p>最后解决其实非常容易：</p>
<ol>
<li>既然已经有自增id服务，直接把把主键上的 AUTO_INCREMENT 定义去掉</li>
<li>整改这种 insert … select … 的sql。维护时可以，但开发账号要杜绝</li>
<li>周大神说他们用的是 mode 2 模式。也不失为一种方法</li>
</ol>
<h3 id="load-data-为什么没阻塞其它事务"><a href="#load-data-为什么没阻塞其它事务" class="headerlink" title="load data 为什么没阻塞其它事务"></a>load data 为什么没阻塞其它事务</h3><p>这是一个同行网友请教我的：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-loaddata.png" alt=""></p>
<p>上篇讲到，load data infile 由于innodb无法提前知道插入的行数，所以归为 bulk inserts —— 表自增方式升级为表级锁，这样一来其它会话里的 insert岂不应该是会被阻塞，为什么实验结果却没有阻塞。</p>
<p>当然一开始我也觉得奇怪，但是仔细想一下就知道，这个表级锁是一个特殊的表锁，为了提高并发性，它是在 <strong>语句</strong> 结束就释放了（而不是事务结束），那么只要验证 LOAD DATA 是把文件里面的行记录，拼装成单个insert就行了，这样其它会话的插入就可以在交错获得表级自增锁，实现不阻塞插入：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-loaddata-binlog.png" alt=""></p>
<p><del>~上图我是为了看效果，临时设置 <code>log_bin=&#39;statement&#39;</code>，看到 <code>LOAD DATA INFILE</code> 会把文件转换成 <em>一个</em> 事务包含的 <em>多行</em> insert，于是就说得通了。</del>~ @jin 多谢指正。</p>
<p>上图 row 模式下 的binlog，看到 BEGIN … COMMIT 之间包含了 多行 insert。（注：在 statement 模式下，binlog里面记录的是 LOAD DATA 语句，从库会把文件从主库传输过来，再执行）</p>
<p>温馨提示：  </p>
<ol>
<li>如果load data 的文件自带主键值，那么另一个会话获取的自增值很容易产生重复。</li>
<li>stackexchange上有个关于 <a href="http://dba.stackexchange.com/questions/40400/loading-data-in-mysql-using-load-data-infile-replication-safe" target="_blank" rel="external">load data infile 对复制安全性的讨论</a> ，同意二楼的观点，官方文档里说的 unsafe，并不是说执行这样的语句会导致安全问题，而是 considered unsafe，在 row-based 可用的情况下，优化器会自动把binlog记录为 row ，依然是安全的。</li>
</ol>
<hr>
<p>本文链接地址：<a href="http://seanlook.com/2017/02/17/mysql-autoincrement_2/">http://seanlook.com/2017/02/17/mysql-autoincrement_2/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AUTO-INC-waiting-锁等待&quot;&gt;&lt;a href=&quot;#AUTO-INC-waiting-锁等待&quot; class=&quot;headerlink&quot; title=&quot;AUTO-INC waiting 锁等待&quot;&gt;&lt;/a&gt;AUTO-INC waiting 锁等待&lt;/h3&gt;&lt;p&gt;这是生产环境出现的现象，某日下午5点业务高峰期，我们的 &lt;a href=&quot;http://seanlook.com/2016/09/27/python-mysql-querykill/&quot;&gt;慢查询快照抓取程序&lt;/a&gt; 报出大量线程阻塞，但是1分钟以后就好了。于是分析了当时的 processlist 和 innodb status 现场记录，发现有大量的 &lt;code&gt;AUTO-INC waiting&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-1.png&quot; alt=&quot;auto-inc-lock-wait&quot;&gt;&lt;/p&gt;
&lt;p&gt;当时想这是得多大的并发量，才会导致 AUTO_INCREMENT 列的自增id分配出现性能问题，不太愿意相信这个事实（后面就再也没出现过）。了解一番之后（见 &lt;a href=&quot;http://seanlook.com/2017/02/16/mysql-autoincrement/&quot;&gt;关于MySQLz自增主键问题（上篇）&lt;/a&gt;），发现这个表级别的 AUTO-INC lock 就不应该在业务中存在，因为 &lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt;为1，普通业务都是 simple inserts，获取自增id是靠内存里维护的一个互斥量（mutex counter）。&lt;/p&gt;
&lt;p&gt;问题拿到知数堂优化班上课群里讨论过，也只是猜测是不是慢查询多了导致负载高，或者当时磁盘遇到什么物理故障阿里云那边自动恢复了。再后来怀疑是不是因为插入时带了 auto_increment 列的值（我们有个redis incr实现的自增id服务，虽然这一列有 AAUTO_INCREMENT 定义，但实际已经从发号器取id了），会导致锁的性质会变？&lt;/p&gt;
&lt;p&gt;为了弄清这个疑问，特意去看了下mysql源码，发现如果插入的自增值比表当前AUTOINC值要大，是直接update mutex counter：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7q5fot.com1.z0.glb.clouddn.com/mysql-autoinc-mutex-update.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看源码的时候也打消了另一个疑虑：&lt;code&gt;show engine innodb status&lt;/code&gt; 看到的 &lt;code&gt;AUTO-INC&lt;/code&gt; 有没有可能不区分 表级自增锁和互斥量计数器 两种自增方案，只是告诉你自增id获取忙不过来？ 实际不是的，代码里面有明确的定义是 &lt;code&gt;autoinc_lock&lt;/code&gt;还是&lt;code&gt;autoinc_mutex&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// dict0dict.cc :&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#ifndef UNIV_HOTBACKUP&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;markdown&quot;&gt;/&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;emphasis&quot;&gt;***&lt;/span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;markdown&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Acquire &lt;/span&gt;the&lt;span class=&quot;markdown&quot;&gt; autoinc lock. */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UNIV_INTERN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dict_table_autoinc_lock(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*====================*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4dict_table_t*	table)	&lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; in/out: table */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4mutex_enter(&amp;amp;table-&amp;gt;autoinc_mutex);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;markdown&quot;&gt;/&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;emphasis&quot;&gt;***&lt;/span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;markdown&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Unconditionally set &lt;/span&gt;the&lt;span class=&quot;markdown&quot;&gt; autoinc counter. */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UNIV_INTERN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dict_table_autoinc_initialize(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*==========================*/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4dict_table_t*	table,	&lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; in/out: table */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4ib_uint64_t	value)	&lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; in: next value to assign to a row */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4ut_ad(mutex_own(&amp;amp;table-&amp;gt;autoinc_mutex));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4table-&amp;gt;autoinc = value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="schema设计" scheme="http://seanlook.com/tags/schema%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于MySQL自增主键的几点问题（上）</title>
    <link href="http://seanlook.com/2017/02/16/mysql-autoincrement/"/>
    <id>http://seanlook.com/2017/02/16/mysql-autoincrement/</id>
    <published>2017-02-16T08:32:49.000Z</published>
    <updated>2017-02-16T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间遇到一个InnoDB表自增锁导致的问题，最近刚好有一个同行网友也问到自增锁的疑问，所以抽空系统的总结一下，这两个问题下篇会有阐述。</p>
<h2 id="1-划分三种插入类型"><a href="#1-划分三种插入类型" class="headerlink" title="1. 划分三种插入类型"></a>1. 划分三种插入类型</h2><p>这里区分一下几种插入数据行的类型，便于后面描述：（纯逻辑上的划分）</p>
<ol>
<li><p>“Simple inserts”<br>简单插入，就是在处理sql语句的时候，能够提前预估到插入的行数，包括 <code>INSERT</code> / <code>REPLACE</code> 的单行、多行插入，但不含嵌套子查询以及 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p>
</li>
<li><p>“Bulk inserts”<br>本文暂且叫做 大块插入，不能提前预知语句要插入的行数，也就无法知道分配多少个自增值，包括 <code>INSERT ... SELECT</code>, <code>REPLACE ... SELECT</code>, 以及 <code>LOAD DATA</code> 导入语句。InnoDB会每处理一行记录就为 AUTO_INCREMENT 列分配一个值。</p>
</li>
<li><p>“Mixed-mode inserts”<br>混合插入，比如在 “简单插入” 多行记录的时候，有的新行有指定自增值，有的没有，所以获得最坏情况下需要插入的数量，然后一次性分配足够的auto_increment id。比如:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># <span class="selector-tag">c1</span> 是 <span class="selector-tag">t1</span> 的 <span class="selector-tag">AUTO_INCREMENT</span> 列</div><div class="line"><span class="selector-tag">INSERT</span> <span class="selector-tag">INTO</span> <span class="selector-tag">t1</span> (c1,c2) <span class="selector-tag">VALUES</span> (<span class="number">1</span>,<span class="string">'a'</span>), (NULL,<span class="string">'b'</span>), (<span class="number">5</span>,<span class="string">'c'</span>), (NULL,<span class="string">'d'</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>又比如 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>，它在 update 阶段有可能分配新的自增id，也可能不会。</p>
<h2 id="2-三种自增模式：innodb-autoinc-lock-mode"><a href="#2-三种自增模式：innodb-autoinc-lock-mode" class="headerlink" title="2. 三种自增模式：innodb_autoinc_lock_mode"></a>2. 三种自增模式：<code>innodb_autoinc_lock_mode</code></h2><p>在以 5.6 版本，自增id累加模式分为：</p>
<ul>
<li><p><strong> 传统模式</strong><br>traditional，<code>innodb_autoinc_lock_mode = 0</code><br>在具有 AUTO_INCREMENT 的表上，所有插入语句会获取一个特殊的表级锁 <em>AUTO-INC</em> ，这个表锁是在语句结束之后立即释放（无需等到事务结束），它可以保证在一个insert里面的多行记录连续递增，也能保证多个insert并发情况下自增值是连续的（不会有空洞）。</p>
</li>
<li><p><strong> 连续模式 </strong><br>consecutive，<code>innodb_autoinc_lock_mode = 1</code><br>MySQL 5.1.22开始，InnoDB提供了一种轻量级互斥的自增实现机制，在内存中会有一个互斥量（mutex），每次分配自增长ID时，就通过估算插入的数量（前提是必须能够估算到插入的数量，否则还是使用传统模式），然后更新mutex，下一个线程过来时从新 mutex 开始继续计算，这样就能避免传统模式非要等待每个都插入之后才能获取下一个，把“锁”降级到 只在分配id的时候 锁定互斥量。<br>在 <code>innodb_autoinc_lock_mode = 1</code>（默认） 模式下，“简单插入”采用上面的 mutex 方式，“大块插入”（insert/replace … select … 、load data…）依旧采用 AUTO-INC 表级锁方式。当然如果一个事务里已经持有表 AUTO-INC 锁，那么后续的简单插入也需要等待这个 AUTO-INC 锁释放。这能够保证任意insert并发情况下自增值是连续的。</p>
<a id="more"></a></li>
<li><p><strong> 交叉模式 </strong><br>interleaved，<code>innodb_autoinc_lock_mode = 2</code><br>该模式下所有 INSERT SQL 都不会有表级 AUTO-INC 锁，多个 <strong>语句</strong> 可以同时执行，所以在高并发插入场景下性能会好一些。但是当 binlog 采用 SBR 格式时，对于从库重放日志或者主库实例恢复时，并不可靠。<br>另者，它只能保证自增值在 insert语句级别 （单调）递增，所以多个insert可能会交叉着分配id，最终可能导致多个语句之间的id值不连续，这种情况出现在 混合插入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'a'</span>), (<span class="literal">NULL</span>,<span class="string">'b'</span>), (<span class="number">5</span>,<span class="string">'c'</span>), (<span class="literal">NULL</span>,<span class="string">'d'</span>);</div></pre></td></tr></table></figure>
<p>mutex 会按行分配4个id，但实际只用到2个，因此出现空洞。</p>
</li>
</ul>
<h2 id="3-自增空洞（auto-increment-sequence-gap）"><a href="#3-自增空洞（auto-increment-sequence-gap）" class="headerlink" title="3. 自增空洞（auto-increment sequence gap）"></a>3. 自增空洞（auto-increment sequence gap）</h2><p>关于 AUTO_INCREMENT 自增出现空洞的问题，有必要再说明一下。</p>
<ol>
<li><p>在 0, 1, 2 三种任何模式下，如果事务回滚，那么里面获得自增值的sql回滚，但产生的自增值会一起丢失，不可能重新分配给其它insert语句。这也会产生空洞。</p>
</li>
<li><p>在大块插入情景下</p>
<ul>
<li><code>innodb_autoinc_lock_mode</code>为 0 或 1 时，因为 AUTO-INC 锁会持续到语句结束，同一时间只有一个 语句 在表上执行，所以自增值是连续的（其它事务需要等待），不会有空洞；</li>
<li><code>innodb_autoinc_lock_mode</code>为 2 时，两个 “大块插入” 之间可能会有空洞，因为每条语句事先无法预知精确的数量而导致分配过多的id，可能有空洞。</li>
</ul>
</li>
</ol>
<h2 id="4-混合插入对-AUTO-INCREMENT-的影响"><a href="#4-混合插入对-AUTO-INCREMENT-的影响" class="headerlink" title="4. 混合插入对 AUTO_INCREMENT 的影响"></a>4. 混合插入对 AUTO_INCREMENT 的影响</h2><p>混合插入在 innodb_autoinc_lock_mode 不同模式下会有对 表自增值有不同的表现。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE t1 (</div><div class="line">  c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</div><div class="line">  c2 CHAR(1)</div><div class="line">  ) ENGINE=INNODB;</div><div class="line"></div><div class="line">ALTER TABLE t1 AUTO_INCREMENT 101;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SHOW CREATE TABLE t1\G</div><div class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 1. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></div><div class="line"><span class="code">       Table: t1</span></div><div class="line">Create Table: CREATE TABLE <span class="code">`t1`</span> (</div><div class="line">  <span class="code">`c1`</span> int(10) unsigned NOT NULL AUTO_INCREMENT,</div><div class="line">  <span class="code">`c2`</span> char(1) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (<span class="code">`c1`</span>)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8</div></pre></td></tr></table></figure></p>
<h3 id="1-mode-0"><a href="#1-mode-0" class="headerlink" title="1. mode 0"></a>1. mode 0</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; select @@innodb_autoinc_lock_mode;</span></div><div class="line">+----------------------------+</div><div class="line"><span class="section">| @@innodb_autoinc_lock_mode |</span></div><div class="line">+----------------------------+</div><div class="line"><span class="section">|                          0 |</span></div><div class="line">+----------------------------+</div><div class="line"></div><div class="line">mysql&gt; INSERT INTO t1 (c1,c2) VALUES (1,<span class="emphasis">'a'</span>), (NULL,<span class="emphasis">'b'</span>), (5,<span class="emphasis">'c'</span>), (NULL,<span class="emphasis">'d'</span>);</div><div class="line"><span class="section">mysql&gt; select * from t1;</span></div><div class="line">+-----+------+</div><div class="line"><span class="section">| c1  | c2   |</span></div><div class="line">+-----+------+</div><div class="line">|   1 | a    |</div><div class="line">|   5 | c    |</div><div class="line">| 101 | b    |</div><div class="line"><span class="section">| 102 | d    |</span></div><div class="line">+-----+------+</div><div class="line"></div><div class="line">mysql&gt; show create table t1\G</div><div class="line"><span class="bullet">...</span></div><div class="line">) ENGINE=InnoDB AUTO<span class="emphasis">_INCREMENT=103 DEFAULT CHARSET=utf8</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到下一个自增值是 103 ，因为即使这是 <strong> 一条 </strong> insert语句（多行记录），自增值还是每次分配一个，不会在语句开始前一次分配全。</p>
<h3 id="2-mode-1"><a href="#2-mode-1" class="headerlink" title="2. mode 1"></a>2. mode 1</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">mysql&gt; truncate table t1; ALTER TABLE t1 AUTO<span class="emphasis">_INCREMENT 101;  -- 复原</span></div><div class="line">mysql&gt; select @@innodb_autoinc<span class="emphasis">_lock_</span>mode;</div><div class="line"><span class="code">+----------------------------+</span></div><div class="line"><span class="section">| @@innodb_autoinc_lock_mode |</span></div><div class="line">+----------------------------+</div><div class="line"><span class="section">|                          1 |</span></div><div class="line">+----------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; INSERT INTO t1 (c1,c2) VALUES (1,<span class="emphasis">'a'</span>), (NULL,<span class="emphasis">'b'</span>), (5,<span class="emphasis">'c'</span>), (NULL,<span class="emphasis">'d'</span>);</div><div class="line">Query OK, 4 rows affected (0.00 sec)</div><div class="line">Records: 4  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line"><span class="section">mysql&gt; select * from t1;</span></div><div class="line">+-----+------+</div><div class="line"><span class="section">| c1  | c2   |</span></div><div class="line">+-----+------+</div><div class="line">|   1 | a    |</div><div class="line">|   5 | c    |</div><div class="line">| 101 | b    |</div><div class="line"><span class="section">| 102 | d    |</span></div><div class="line">+-----+------+</div><div class="line"></div><div class="line">mysql&gt; show create table t1\G</div><div class="line"><span class="bullet">...</span></div><div class="line">) ENGINE=InnoDB AUTO<span class="emphasis">_INCREMENT=105 DEFAULT CHARSET=utf8</span></div></pre></td></tr></table></figure>
<p>可以看到最终插入的值是一样的，但下一个自增值变成了 105，因为该模式下insert语句处理的时候，提前分配了 4 个自增值，但实际只有了两个。</p>
<p>注：如果你的insert自增列全都有带值，那么处理的时候是不会分配自增值的，经过下面这个实验，可以知道 <strong> 分配自增值，是在遇到第一个没有带自增列的行时，一次性分配的 </strong> ：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">-- </span>Tx1，先运行。 -- 插入第2行的时候 sleep 5s</div><div class="line">INSERT INTO t1 (c1,c2) VALUES (2,<span class="emphasis">'e'</span>),(sleep(5)+6,<span class="emphasis">'g'</span>),(NULL,<span class="emphasis">'f'</span>), (NULL,<span class="emphasis">'h'</span>);</div><div class="line"></div><div class="line"><span class="bullet">-- </span>Tx2，后运行。 -- 第一行没有给自增列值，马上分配 4 个</div><div class="line">INSERT INTO t1 (c1,c2) VALUES  (NULL,<span class="emphasis">'b'</span>), (1,<span class="emphasis">'a'</span>), (sleep(5)+5,<span class="emphasis">'c'</span>), (NULL,<span class="emphasis">'d'</span>);</div><div class="line"></div><div class="line"><span class="section">-- 得到的结果是</span></div><div class="line">+-----+------+</div><div class="line"><span class="section">| c1  | c2   |</span></div><div class="line">+-----+------+</div><div class="line">|   1 | a    |</div><div class="line">|   2 | e    |</div><div class="line">|   5 | c    |</div><div class="line">|   6 | g    |</div><div class="line">| 101 | b    |</div><div class="line">| 102 | d    |</div><div class="line">| 105 | f    |</div><div class="line"><span class="section">| 106 | h    |</span></div><div class="line">+-----+------+</div></pre></td></tr></table></figure></p>
<h3 id="3-mode-2"><a href="#3-mode-2" class="headerlink" title="3. mode 2"></a>3. mode 2</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">mysql&gt; truncate table t1; ALTER TABLE t1 AUTO<span class="emphasis">_INCREMENT 101;  -- 复原</span></div><div class="line">mysql&gt; select @@innodb_autoinc<span class="emphasis">_lock_</span>mode;</div><div class="line"><span class="code">+----------------------------+</span></div><div class="line"><span class="section">| @@innodb_autoinc_lock_mode |</span></div><div class="line">+----------------------------+</div><div class="line"><span class="section">|                          2 |</span></div><div class="line">+----------------------------+</div><div class="line"></div><div class="line">mysql&gt; INSERT INTO t1 (c1,c2) VALUES (1,<span class="emphasis">'a'</span>), (NULL,<span class="emphasis">'b'</span>), (5,<span class="emphasis">'c'</span>), (NULL,<span class="emphasis">'d'</span>);</div><div class="line"><span class="section">mysql&gt; select * from t1;</span></div><div class="line">+-----+------+</div><div class="line"><span class="section">| c1  | c2   |</span></div><div class="line">+-----+------+</div><div class="line">|   1 | a    |</div><div class="line">|   5 | c    |</div><div class="line">| 101 | b    |</div><div class="line"><span class="section">| 102 | d    |</span></div><div class="line">+-----+------+</div><div class="line"></div><div class="line">mysql&gt; show create table t1\G</div><div class="line"><span class="bullet">...</span></div><div class="line">) ENGINE=InnoDB AUTO<span class="emphasis">_INCREMENT=105 DEFAULT CHARSET=utf8</span></div></pre></td></tr></table></figure>
<p>结果看起来与 连续模式 一样，其实不然！该模式下，如果另外一个 大块插入 并发执行时，可能会出现以下现象：</p>
<ol>
<li>大块插入的的自增值有间断</li>
<li>其它并发执行的事务插入出现 duplicate-key error</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">第<span class="number">1</span>点 (create t2 select * <span class="keyword">from</span> t1)</div><div class="line">Tx1: insert <span class="keyword">into</span> t1(c2) select c2 <span class="keyword">from</span> t2；  -- 先执行</div><div class="line">Tx2: INSERT <span class="keyword">INTO</span> t1 (c1,c2) VALUES (<span class="number">1</span>,<span class="string">'a'</span>), (<span class="keyword">NULL</span>,<span class="string">'b'</span>), (<span class="number">5</span>,<span class="string">'c'</span>), (<span class="keyword">NULL</span>,<span class="string">'d'</span>);  -- 后 并发执行</div><div class="line"></div><div class="line">在交叉模式下，Tx1事务插入的数据行会与 Tx1 交叉出现。</div><div class="line">注：如果 Tx1 改成 insert <span class="keyword">into</span> t1 select * <span class="keyword">from</span> t2 ，那么 Tx2 执行极有可能会报 duplicate-key error，与下面第<span class="number">2</span>点所说的重复键是不一样的</div><div class="line"></div><div class="line">第<span class="number">2</span>点</div><div class="line">mysql&gt; truncate table t1; ALTER TABLE t1 AUTO_INCREMENT <span class="number">5</span>;  -- 复原</div><div class="line">mysql&gt; INSERT <span class="keyword">INTO</span> t1 (c1,c2) VALUES (<span class="number">1</span>,<span class="string">'a'</span>), (<span class="keyword">NULL</span>,<span class="string">'b'</span>), (<span class="number">5</span>,<span class="string">'c'</span>), (<span class="keyword">NULL</span>,<span class="string">'d'</span>);</div><div class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">'5'</span> <span class="keyword">for</span> key <span class="string">'PRIMARY'</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面说了这么多，那么自增模式到底该怎么选择呢？其实很简单，目前数据库默认的 traditional 即 <code>innodb_autoinc_lock_mode=1</code> 就是最好的模式，一般业务生产库不会有 <code>insert into ... select ...</code>或者 load data infile 这样的维护动作。（提示：即使晚上有数据迁移任务，也不要通过这样的形式进行）</p>
<p><code>innodb_autoinc_lock_mode=2</code> 可以提高获取表自增id的并发能力（性能），但是除非出现上面演示的 duplicate-key 特殊用法情形，不会像网上所说的获取到相同key导致重复的问题。但是如果binlog在 RBR 格式下不建议使用，可能出现主从数据不一致。还有就是能够容忍gap的存在，以及多个语句insert的自增值交叉。</p>
<p>参考： <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-auto-increment-handling.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/innodb-auto-increment-handling.html</a></p>
<p>下篇分析遇到过的 MySQL 自增主键相关的具体问题。</p>
<hr>
<p>本文链接地址：<a href="http://seanlook.com/2017/02/16/mysql-autoincrement/">http://seanlook.com/2017/02/16/mysql-autoincrement/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个InnoDB表自增锁导致的问题，最近刚好有一个同行网友也问到自增锁的疑问，所以抽空系统的总结一下，这两个问题下篇会有阐述。&lt;/p&gt;
&lt;h2 id=&quot;1-划分三种插入类型&quot;&gt;&lt;a href=&quot;#1-划分三种插入类型&quot; class=&quot;headerlink&quot; title=&quot;1. 划分三种插入类型&quot;&gt;&lt;/a&gt;1. 划分三种插入类型&lt;/h2&gt;&lt;p&gt;这里区分一下几种插入数据行的类型，便于后面描述：（纯逻辑上的划分）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“Simple inserts”&lt;br&gt;简单插入，就是在处理sql语句的时候，能够提前预估到插入的行数，包括 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;REPLACE&lt;/code&gt; 的单行、多行插入，但不含嵌套子查询以及 &lt;code&gt;INSERT ... ON DUPLICATE KEY UPDATE&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Bulk inserts”&lt;br&gt;本文暂且叫做 大块插入，不能提前预知语句要插入的行数，也就无法知道分配多少个自增值，包括 &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, &lt;code&gt;REPLACE ... SELECT&lt;/code&gt;, 以及 &lt;code&gt;LOAD DATA&lt;/code&gt; 导入语句。InnoDB会每处理一行记录就为 AUTO_INCREMENT 列分配一个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Mixed-mode inserts”&lt;br&gt;混合插入，比如在 “简单插入” 多行记录的时候，有的新行有指定自增值，有的没有，所以获得最坏情况下需要插入的数量，然后一次性分配足够的auto_increment id。比如:&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# &lt;span class=&quot;selector-tag&quot;&gt;c1&lt;/span&gt; 是 &lt;span class=&quot;selector-tag&quot;&gt;t1&lt;/span&gt; 的 &lt;span class=&quot;selector-tag&quot;&gt;AUTO_INCREMENT&lt;/span&gt; 列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;t1&lt;/span&gt; (c1,c2) &lt;span class=&quot;selector-tag&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;), (NULL,&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;), (NULL,&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;又比如 &lt;code&gt;INSERT ... ON DUPLICATE KEY UPDATE&lt;/code&gt;，它在 update 阶段有可能分配新的自增id，也可能不会。&lt;/p&gt;
&lt;h2 id=&quot;2-三种自增模式：innodb-autoinc-lock-mode&quot;&gt;&lt;a href=&quot;#2-三种自增模式：innodb-autoinc-lock-mode&quot; class=&quot;headerlink&quot; title=&quot;2. 三种自增模式：innodb_autoinc_lock_mode&quot;&gt;&lt;/a&gt;2. 三种自增模式：&lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;在以 5.6 版本，自增id累加模式分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt; 传统模式&lt;/strong&gt;&lt;br&gt;traditional，&lt;code&gt;innodb_autoinc_lock_mode = 0&lt;/code&gt;&lt;br&gt;在具有 AUTO_INCREMENT 的表上，所有插入语句会获取一个特殊的表级锁 &lt;em&gt;AUTO-INC&lt;/em&gt; ，这个表锁是在语句结束之后立即释放（无需等到事务结束），它可以保证在一个insert里面的多行记录连续递增，也能保证多个insert并发情况下自增值是连续的（不会有空洞）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt; 连续模式 &lt;/strong&gt;&lt;br&gt;consecutive，&lt;code&gt;innodb_autoinc_lock_mode = 1&lt;/code&gt;&lt;br&gt;MySQL 5.1.22开始，InnoDB提供了一种轻量级互斥的自增实现机制，在内存中会有一个互斥量（mutex），每次分配自增长ID时，就通过估算插入的数量（前提是必须能够估算到插入的数量，否则还是使用传统模式），然后更新mutex，下一个线程过来时从新 mutex 开始继续计算，这样就能避免传统模式非要等待每个都插入之后才能获取下一个，把“锁”降级到 只在分配id的时候 锁定互斥量。&lt;br&gt;在 &lt;code&gt;innodb_autoinc_lock_mode = 1&lt;/code&gt;（默认） 模式下，“简单插入”采用上面的 mutex 方式，“大块插入”（insert/replace … select … 、load data…）依旧采用 AUTO-INC 表级锁方式。当然如果一个事务里已经持有表 AUTO-INC 锁，那么后续的简单插入也需要等待这个 AUTO-INC 锁释放。这能够保证任意insert并发情况下自增值是连续的。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="schema设计" scheme="http://seanlook.com/tags/schema%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>监控MySQL你还应该收集表信息</title>
    <link href="http://seanlook.com/2016/12/04/mysql-schema-gather-statistics/"/>
    <id>http://seanlook.com/2016/12/04/mysql-schema-gather-statistics/</id>
    <published>2016-12-04T08:32:49.000Z</published>
    <updated>2016-12-04T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Story"><a href="#1-Story" class="headerlink" title="1. Story"></a>1. Story</h2><p>也许你经常会被问到，库里某个表最近一年的内每个月的数据量增长情况。当然如果你有按月分表比较好办，挨个 <code>show table status</code>，如果只有一个大表，那估计要在大家都休息的时候，寂寞的夜里去跑sql统计了，因为你只能获取当前的表信息，历史信息追查不到了。</p>
<p>除此以外，作为DBA本身也要对数据库空间增长情况进行预估，用以规划容量。我们说的表信息主要包括：</p>
<ol>
<li>表数据大小（DATA_LENGTH）</li>
<li>索引大小(INDEX_LENGTH)</li>
<li>行数（ROWS）</li>
<li>当前自增值（AUTO_INCREMENT，如果有）</li>
</ol>
<p>目前是没有看到哪个mysql监控工具上提供这样的指标。这些信息不需要采集的太频繁，而且结果也只是个预估值，不一定准确，所以这是站在一个全局、长远的角度去监控(采集)表的。</p>
<p>本文要介绍的自己写的采集工具，是基于组内现有的一套监控体系：</p>
<ul>
<li><code>InfluxDB</code>：时间序列数据库，存储监控数据</li>
<li><code>Grafana</code>：数据展示面板</li>
<li><code>Telegraf</code>：收集信息的agent<br>看了下 telegraf 的最新的 <a href="https://github.com/influxdata/telegraf/tree/master/plugins/inputs/mysql" target="_blank" rel="external">mysql 插件</a>，一开始很欣慰：支持收集 Table schema statistics 和 Info schema auto increment columns。试用了一下，有数据，但是如前面所说，除了自增值外其他都是预估值，telegraf收集频率过高没啥意义，也许一天2次就足够了，它提供的 <code>IntervalSlow</code>选项固定写死在代码里，只能是放缓 global status 监控频率。不过倒是可以与其它监控指标分开成两份配置文件，各自定义收集间隔来实现。<br>最后打算自己用python撸一个，上报到influxdb里 :)</li>
</ul>
<h2 id="2-Concept"><a href="#2-Concept" class="headerlink" title="2. Concept"></a>2. Concept</h2><p>完整代码见 GitHub项目地址：<a href="https://github.com/seanlook/DBschema_gather" target="_blank" rel="external">DBschema_gather</a><br>实现也特别简单，就是查询 <code>information_schema</code> 库的 <code>COLUMNS</code>、<code>TABLES</code> 两个表：<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    <span class="keyword">IFNULL</span>(@@hostname, @@server_id) SERVER_NAME,</div><div class="line">    %s <span class="keyword">as</span> HOST,</div><div class="line">    t.TABLE_SCHEMA,</div><div class="line">    t.TABLE_NAME,</div><div class="line">    t.TABLE_ROWS,</div><div class="line">    t.DATA_LENGTH,</div><div class="line">    t.INDEX_LENGTH,</div><div class="line">    t.AUTO_INCREMENT,</div><div class="line">  c.COLUMN_NAME,</div><div class="line">  c.DATA_TYPE,</div><div class="line">  <span class="keyword">LOCATE</span>(<span class="string">'unsigned'</span>, c.COLUMN_TYPE) COL_UNSIGNED</div><div class="line">  # <span class="keyword">CONCAT</span>(c.DATA_TYPE, <span class="keyword">IF</span>(<span class="keyword">LOCATE</span>(<span class="string">'unsigned'</span>, c.COLUMN_TYPE)=<span class="number">0</span>, <span class="string">''</span>, <span class="string">'_unsigned'</span>))</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    information_schema.<span class="string">`TABLES`</span> t</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> information_schema.<span class="string">`COLUMNS`</span> c <span class="keyword">ON</span> t.TABLE_SCHEMA = c.TABLE_SCHEMA</div><div class="line"><span class="keyword">AND</span> t.TABLE_NAME = c.TABLE_NAME</div><div class="line"><span class="keyword">AND</span> c.EXTRA = <span class="string">'auto_increment'</span></div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    t.TABLE_SCHEMA <span class="keyword">NOT</span> <span class="keyword">IN</span> (</div><div class="line">        <span class="string">'mysql'</span>,</div><div class="line">        <span class="string">'information_schema'</span>,</div><div class="line">        <span class="string">'performance_schema'</span>,</div><div class="line">        <span class="string">'sys'</span></div><div class="line">    )</div><div class="line"><span class="keyword">AND</span> t.TABLE_TYPE = <span class="string">'BASE TABLE'</span></div></pre></td></tr></table></figure></p>
<p>关于 <code>auto_increment</code>，我们除了关注当前增长到哪了，还会在意相比 <code>int / bigint</code> 的最大值，还有多少可用空间。于是计算了 <code>autoIncrUsage</code> 这一列，用于保存当前已使用的比例。</p>
<p>然后使用 InfluxDB 的python客户端，批量存入influxdb。如果没有InfluxDB，结果会打印出json —— 这是Zabbix、Open-Falcon这些监控工具普遍支持的格式。</p>
<p>最后就是使用 Grafana 从 influxdb 数据源画图。</p>
<h2 id="3-Usage"><a href="#3-Usage" class="headerlink" title="3. Usage"></a>3. Usage</h2><ol>
<li><p>环境<br>在 python 2.7 环境下编写的，2.6，3.x没测。<br>运行需要<code>MySQLdb</code>、<code>influxdb</code>两个库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip <span class="keyword">install</span> mysql-python influxdb</div></pre></td></tr></table></figure>
</li>
<li><p>配置<br><code>settings_dbs.py</code> 配置文件</p>
<ul>
<li><code>DBLIST_INFO</code>：列表存放需要采集的哪些MySQL实例表信息，元组内分别是连接地址、端口、用户名、密码<br>用户需要select表的权限，否则看不到对应的信息.</li>
<li><code>InfluxDB_INFO</code>：influxdb的连接信息，注意提前创建好数据库名 <code>mysql_info</code><br>设置为 <code>None</code> 可输出结果为json.</li>
</ul>
</li>
<li><p>创建influxdb上的数据库和存储策略<br>存放2年，1个复制集：（按需调整）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">"mysql_info"</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">RETENTION</span> <span class="keyword">POLICY</span> <span class="string">"mysql_info_schema"</span> <span class="keyword">ON</span> <span class="string">"mysql_info"</span> <span class="keyword">DURATION</span> <span class="number">730</span>d <span class="keyword">REPLICATION</span> <span class="number">1</span> <span class="keyword">DEFAULT</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>看大的信息类似于：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-schema-statistics.png" alt="schema-influxdb-data"></p>
<ol>
<li><p>放crontab跑<br>可以单独放在用于监控的服务器上，不过建议在生产环境可以运行在mysql实例所在主机上，安全起见。<br>一般库在晚上会有数据迁移的动作，可以在迁移前后分别运行 <code>mysql_schema_info.py</code> 来收集一次。不建议太频繁。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">40 </span><span class="number">23</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">18</span> * * * /opt/DBschema_info/mysql_schema_info.py &gt;&gt; /tmp/collect_DBschema_info.<span class="keyword">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></div></pre></td></tr></table></figure>
</li>
<li><p>生成图表</p>
</li>
</ol>
<p>导入项目下的 <code>grafana_table_stats.json</code> 到 Grafana面板中。效果如下：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-schema-statistics2.png" alt="表数据大小和行数"><br><em>表数据大小和行数</em></p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-schema-statistics3.png" alt="每天行数变化增量,auto_increment使用率"><br><em>每天行数变化增量,auto_increment使用率</em></p>
<h2 id="4-More"><a href="#4-More" class="headerlink" title="4. More"></a>4. More</h2><ol>
<li>分库分表情况下，全局唯一ID在表里无法计算 autoIncrUsage  </li>
<li>实现上其实很简单，更主要的是唤醒收集这些信息的意识  </li>
<li>可以增加 Graphite 输出格式  </li>
</ol>
<hr>
<p>  原文链接地址：<a href="http://seanlook.com/2016/12/04/mysql-schema-gather-statistics/">http://seanlook.com/2016/12/04/mysql-schema-gather-statistics/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Story&quot;&gt;&lt;a href=&quot;#1-Story&quot; class=&quot;headerlink&quot; title=&quot;1. Story&quot;&gt;&lt;/a&gt;1. Story&lt;/h2&gt;&lt;p&gt;也许你经常会被问到，库里某个表最近一年的内每个月的数据量增长情况。当然如果你有按月分表比较好办，挨个 &lt;code&gt;show table status&lt;/code&gt;，如果只有一个大表，那估计要在大家都休息的时候，寂寞的夜里去跑sql统计了，因为你只能获取当前的表信息，历史信息追查不到了。&lt;/p&gt;
&lt;p&gt;除此以外，作为DBA本身也要对数据库空间增长情况进行预估，用以规划容量。我们说的表信息主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表数据大小（DATA_LENGTH）&lt;/li&gt;
&lt;li&gt;索引大小(INDEX_LENGTH)&lt;/li&gt;
&lt;li&gt;行数（ROWS）&lt;/li&gt;
&lt;li&gt;当前自增值（AUTO_INCREMENT，如果有）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前是没有看到哪个mysql监控工具上提供这样的指标。这些信息不需要采集的太频繁，而且结果也只是个预估值，不一定准确，所以这是站在一个全局、长远的角度去监控(采集)表的。&lt;/p&gt;
&lt;p&gt;本文要介绍的自己写的采集工具，是基于组内现有的一套监控体系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InfluxDB&lt;/code&gt;：时间序列数据库，存储监控数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grafana&lt;/code&gt;：数据展示面板&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Telegraf&lt;/code&gt;：收集信息的agent&lt;br&gt;看了下 telegraf 的最新的 &lt;a href=&quot;https://github.com/influxdata/telegraf/tree/master/plugins/inputs/mysql&quot;&gt;mysql 插件&lt;/a&gt;，一开始很欣慰：支持收集 Table schema statistics 和 Info schema auto increment columns。试用了一下，有数据，但是如前面所说，除了自增值外其他都是预估值，telegraf收集频率过高没啥意义，也许一天2次就足够了，它提供的 &lt;code&gt;IntervalSlow&lt;/code&gt;选项固定写死在代码里，只能是放缓 global status 监控频率。不过倒是可以与其它监控指标分开成两份配置文件，各自定义收集间隔来实现。&lt;br&gt;最后打算自己用python撸一个，上报到influxdb里 :)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-Concept&quot;&gt;&lt;a href=&quot;#2-Concept&quot; class=&quot;headerlink&quot; title=&quot;2. Concept&quot;&gt;&lt;/a&gt;2. Concept&lt;/h2&gt;&lt;p&gt;完整代码见 GitHub项目地址：&lt;a href=&quot;https://github.com/seanlook/DBschema_gather&quot;&gt;DBschema_gather&lt;/a&gt;&lt;br&gt;实现也特别简单，就是查询 &lt;code&gt;information_schema&lt;/code&gt; 库的 &lt;code&gt;COLUMNS&lt;/code&gt;、&lt;code&gt;TABLES&lt;/code&gt; 两个表：&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="监控" scheme="http://seanlook.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>一种直观记录表结构变更历史的方法</title>
    <link href="http://seanlook.com/2016/11/28/mysql-schema-gather-structure/"/>
    <id>http://seanlook.com/2016/11/28/mysql-schema-gather-structure/</id>
    <published>2016-11-28T08:32:49.000Z</published>
    <updated>2016-11-28T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Story"><a href="#1-Story" class="headerlink" title="1. Story"></a>1. Story</h2><p>在没有形成自己的数据库管理平台以前，数据库实例一多（包括生产和测试环境），许多表要执行DDL会变得异常繁杂。</p>
<p>说个自己的经历，需要改现网的一个索引来看优化的效果，因为存在风险，不会一次全改，先只改1个库，然后逐步放开。前后验证效果可能花上一两周的时间，除非实现完整的记录了当时的ddl语句和对应的库，否则根本难以记得。这就完全依赖于个人的习惯及能力。</p>
<p>又比如现网出了个问题，开发追查到一个时间点，想确认那个时候有没有对库表进行过更改操作，如果没有记录表结构变更的历史，也就难以提供需要的信息。</p>
<p>记录差异，很早就思考过能不能用git来做。终于花了一天时间来实现，并验证、修改达到预期的效果，还算满意。</p>
<p>github项目地址在文后。</p>
<h2 id="2-Concept"><a href="#2-Concept" class="headerlink" title="2. Concept"></a>2. Concept</h2><p>思路很简单，就是利用 <code>mydumper</code> 导出表时会把各表（结构）单独导成一个文件的特性，每天低峰期导出所有对象元数据：表、视图、存储过程、事件、触发器。需要过滤掉 <code>AUTO_INCREMENT</code> 值。</p>
<p>结构内容存放在一个git仓库下，通过shell脚本提交到 gitlab。所有DDL更改由原来依赖于DBA的主动记录，变成被动采集。</p>
<p>测试环境和生产环境表结构总会有些差异，为了兼顾同时收集两个环境的数据，设置了 <code>environment</code> 选项，根据当前所在运行的机器，自动判断采集哪些实例信息。</p>
<h2 id="3-Usage"><a href="#3-Usage" class="headerlink" title="3. Usage"></a>3. Usage</h2><p>首先你需要能够存放表结构信息的git仓库，如gitlab，而且建议设置为私有。<br><a id="more"></a></p>
<ol>
<li><p>安装 git 和 mydumper<br>mydumper 0.9.1 版本需要编译安装，可以参考这里 <a href="https://gist.github.com/nicksantamaria/66726bca586d152a3a01#file-mydumper-install-ubuntu14-04-sh" target="_blank" rel="external">file-mydumper-install-ubuntu14-04-sh</a>。当然 yum 或 apt-get 安装其他版本也是一样的。<br>脚本会尝试自动获取 <code>mydumper</code> 命令的路径。<br>注意配置git权限的时候，最好不允许其它用户手动提交修改仓库内容。</p>
</li>
<li><p>配置db实例地址<br><code>settings.ini</code>示例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="section">[environment]</span></div><div class="line"><span class="attr">production</span>=puppetmaster</div><div class="line"><span class="attr">test</span>=puppettestmaster</div><div class="line"><span class="section"></span></div><div class="line">[production]</div><div class="line"><span class="attr">production_auth</span>=your_defaultuser:yourpassword</div><div class="line"></div><div class="line"><span class="attr">db_name1</span>=<span class="number">192.168</span>.<span class="number">1.100</span>:<span class="number">3306</span></div><div class="line"><span class="attr">db_name2</span>=<span class="number">192.168</span>.<span class="number">1.101</span>:<span class="number">3306</span></div><div class="line"><span class="attr">db_name3</span>=name3.dbhost.com:<span class="number">3306</span></div><div class="line"><span class="attr">db_name4</span>=<span class="number">192.168</span>.<span class="number">1.100</span>:<span class="number">3306</span>:myuser:mypassword</div><div class="line"><span class="section"></span></div><div class="line">[test]</div><div class="line"><span class="attr">test_auth</span>=user1:password1</div><div class="line"></div><div class="line"><span class="attr">db_name1</span>=<span class="number">10.0</span>.<span class="number">100.1</span>:<span class="number">3306</span></div><div class="line"><span class="attr">db_name2</span>=<span class="number">10.0</span>.<span class="number">100.1</span>:<span class="number">3307</span></div><div class="line"><span class="attr">db_name3</span>=<span class="number">10.0</span>.<span class="number">100.2</span>:<span class="number">3306</span></div><div class="line"></div><div class="line"><span class="attr">db_name4</span>=<span class="number">10.0</span>.<span class="number">100.3</span>:<span class="number">3306</span>:myuser1:mypassword1</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>上面的配置采集 <code>production</code>和<code>test</code>两个环境的表结构，识别两个环境是根据 hostname 来决定的。这样做的好吃就是这个脚本在两个环境下运行不需要做任何修改。  </li>
<li><code>[production]</code>节的名字就是 <code>[environment]</code>节指定的名字 <em>production=xx</em>  </li>
<li><code>dbname1=</code>就是配置各个db，地址+端口的形式。用户名和密码可以继续用 <code>:</code> 跟上</li>
<li><code>production_auth=</code>表示 production 环境下，如 <code>dbname1</code>没有配置用户名时，默认采用这个用户名和密码。这样设计主要是简化配置。<br>该数据库用户需要 select,show view,event,trigger,procedure 权限。<br><code>settings_parser.py</code> 用于解析上面的配置文件，输出<code>collect_tableMeta.sh</code>易处理的格式。</li>
</ul>
<ol>
<li><p>每天运行<br>可使用 <code>python settings_parser.py</code> 测试解析配置是否正常。<br>在配置文件里两个环境下（一般网络不互通）分别加上定时任务：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># Puppet Name: collect_DBschema</span></div><div class="line"><span class="number">5</span> <span class="number">5</span> * * * <span class="meta-keyword">/opt/</span>DBschema/collect_tableMeta.sh &gt;&gt; <span class="meta-keyword">/tmp/</span>collect_DBschema.log <span class="number">2</span>&gt;<span class="variable">&amp;1</span></div></pre></td></tr></table></figure>
</li>
<li><p>展示效果<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-schema-structure1.png" alt="mysql_schema_info"><br><code>A</code> 是新增，<code>M</code> 是修改，<code>D</code> 是删除，一目了然。点开可以前后对比。</p>
</li>
</ol>
<h2 id="4-More"><a href="#4-More" class="headerlink" title="4. More"></a>4. More</h2><p>思路和实现都不难，主要是意识，和如何快速找到解决当前需求的办法。一切都是为了效率 :)</p>
<p>目前所能想到更多的：  </p>
<ol>
<li>有内容push到git仓库后，使用 web hook 发出邮件。  </li>
<li>根据A,B两个表的结构，快速得到A修改成B的样子的DDL。  </li>
<li>event 权限问题。event权限没有所谓的读和修改之分，阿里云RDS就把它从 <em>只读</em> 账号里拿除了，导致收集不到事件定义。所以它的高权限账号管理模式还是很有作用的。  </li>
<li>密码明文。<br>最近公司邀请了一个安全公司给做培训，数据库安全里面，密码明文配置在文件里面是广泛存在的，难搞。</li>
</ol>
<p>GitHub地址：<a href="https://github.com/seanlook/DBschema_gather" target="_blank" rel="external">https://github.com/seanlook/DBschema_gather</a></p>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/11/28/mysql-schema-gather-structure/">http://seanlook.com/2016/11/28/mysql-schema-gather-structure/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Story&quot;&gt;&lt;a href=&quot;#1-Story&quot; class=&quot;headerlink&quot; title=&quot;1. Story&quot;&gt;&lt;/a&gt;1. Story&lt;/h2&gt;&lt;p&gt;在没有形成自己的数据库管理平台以前，数据库实例一多（包括生产和测试环境），许多表要执行DDL会变得异常繁杂。&lt;/p&gt;
&lt;p&gt;说个自己的经历，需要改现网的一个索引来看优化的效果，因为存在风险，不会一次全改，先只改1个库，然后逐步放开。前后验证效果可能花上一两周的时间，除非实现完整的记录了当时的ddl语句和对应的库，否则根本难以记得。这就完全依赖于个人的习惯及能力。&lt;/p&gt;
&lt;p&gt;又比如现网出了个问题，开发追查到一个时间点，想确认那个时候有没有对库表进行过更改操作，如果没有记录表结构变更的历史，也就难以提供需要的信息。&lt;/p&gt;
&lt;p&gt;记录差异，很早就思考过能不能用git来做。终于花了一天时间来实现，并验证、修改达到预期的效果，还算满意。&lt;/p&gt;
&lt;p&gt;github项目地址在文后。&lt;/p&gt;
&lt;h2 id=&quot;2-Concept&quot;&gt;&lt;a href=&quot;#2-Concept&quot; class=&quot;headerlink&quot; title=&quot;2. Concept&quot;&gt;&lt;/a&gt;2. Concept&lt;/h2&gt;&lt;p&gt;思路很简单，就是利用 &lt;code&gt;mydumper&lt;/code&gt; 导出表时会把各表（结构）单独导成一个文件的特性，每天低峰期导出所有对象元数据：表、视图、存储过程、事件、触发器。需要过滤掉 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 值。&lt;/p&gt;
&lt;p&gt;结构内容存放在一个git仓库下，通过shell脚本提交到 gitlab。所有DDL更改由原来依赖于DBA的主动记录，变成被动采集。&lt;/p&gt;
&lt;p&gt;测试环境和生产环境表结构总会有些差异，为了兼顾同时收集两个环境的数据，设置了 &lt;code&gt;environment&lt;/code&gt; 选项，根据当前所在运行的机器，自动判断采集哪些实例信息。&lt;/p&gt;
&lt;h2 id=&quot;3-Usage&quot;&gt;&lt;a href=&quot;#3-Usage&quot; class=&quot;headerlink&quot; title=&quot;3. Usage&quot;&gt;&lt;/a&gt;3. Usage&lt;/h2&gt;&lt;p&gt;首先你需要能够存放表结构信息的git仓库，如gitlab，而且建议设置为私有。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="监控" scheme="http://seanlook.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL非主从环境下数据一致性校验及修复程序</title>
    <link href="http://seanlook.com/2016/11/20/py-mysql-table-checksum-non-replicas/"/>
    <id>http://seanlook.com/2016/11/20/py-mysql-table-checksum-non-replicas/</id>
    <published>2016-11-20T08:32:49.000Z</published>
    <updated>2016-11-20T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>项目地址：<a href="https://github.com/seanlook/px-table-checksum" target="_blank" rel="external">https://github.com/seanlook/px-table-checksum</a></p>
<p>主从环境下数据一致性校验经常会用 pt-table-checksum 工具，它的原理及实施过程之前写过一篇文章：<a href="http://seanlook.com/2015/12/29/mysql_replica_pt-table-checksum/">生产环境使用 pt-table-checksum 检查MySQL数据一致性</a>。但是DBA工作中还会有些针对两个表检查是否一致，而这两个表之间并没有主从关系，pt工具是基于binlog把在主库进行的检查动作，在从库重放一遍，此时就不适用了。</p>
<p>总会有这样特殊的需求，比如从阿里云RDS实例迁移到自建mysql实例，它的数据传输服务实现方式是基于表的批量数据提取，加上binlog订阅，但强制row模式会导致pt-table-checksum没有权限把会话临时改成statement。另一种需求是，整库进行字符集转换：库表定义都是utf8，但应用连接使用了默认的 latin1，要将连接字符集和表字符集统一起来，只能以latin1导出数据，再以utf8导入，这种情况数据一致性校验，且不说binlog解析程序不支持statement（如canal），新旧库本身内容不同，pt-table-checksum 算出的校验值也会不一样，失效。</p>
<p>所以才萌生了参考 pt-table-checksum 自己写了一个：px-table-checksum 。</p>
<h2 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h2><p>整体思路是借鉴pt-table-checksum，从源库批量（即chunk）取出一块数据如1000行，计算CRC32值，同样的语句在目标库运行一遍，结果都存入另一个库，最后检查对应编号的chunk crc值是否一致。知道不一致还不行，得能否快速方便的修复差异，所以继续根据那些不一致的chunk，去目标库和源库找到不一致的行，是缺失，还是多余，还是被修改了，然后生成修复sql，根据指示是否自动修复。</p>
<p>那么问题就在于：</p>
<ol>
<li><p>如何确定批次，也就是下一个chunk该怎么取？<br>我还没想做到pt-table-checksum那样，可以根据负载动态调整chunk大小，甚至活跃线程数超过阀值就暂停检查，上来工作量就太大了。目前每次计算的chunk的行数是固定的，可以配置1000或2000等。<br>所以就要用到分页查询，根据（自增或联合）主键、唯一索引，每次limit 1000后升序取最后一条，作为下一批的起始。所以要分析表上的键情况，组合查询条件。目前仅能检查有主键或唯一所以的表。</p>
</li>
<li><p>如何保证源库和目标库，运行的sql一样？<br>之前一版是目标库和源库，以多线程各自计算chunk，入库，后来才意识到严重的bug：比如同样是取1000行，如果目标库少数据，那么下一个chunk起始就不一样，比较的结果简直一塌糊涂。<br>所以必须保证相同编号的chunk，起点必须相同，所以想到用队列，存放在源库跑过的所有校验sql，模拟pt工具在目标库重放。考虑到要多线程同时比较多个表，队列可能吃内存过大，于是使用了redis队列。</p>
</li>
<li><p>直接在数据库中计算crc32，还是取出数据在内存里计算？<br>翻了pt-table-checksum的源码，它是在数据库里计算的。但是第一节里说过，如果目标库和源库要使用不同的字符集才能读出正确的数据，只能查询出来之后再比较。所以 px-table-checksum 两种都支持，只需指定一个配置项。</p>
</li>
<li><p>同时检查多个表，源库sql挤在队列，目标库拿出来执行时过了1s，此时源库那条数据又被修改了一次同步到了目标库，会导致计算结果不一致，实则一致，怎么处理<br>无法处理，是px-table-checksum相比pt-table-checksum最大的缺陷。<br>但为了尽可能减少此类问题（比如主从延迟也可能会），特意设计了多个redis队列，目标库多个检查线程，即比如同时指定检查8个表，源库检查会有8个线程对应，但可以根据表的写入情况，配置4个redis队列（目前是随机入列），10个目标库检查线程，来减少不准确因素。<br>但站在我的角度往往来说，不一致的数据会被记录下来，如果不多，人工核对一下；如果较多，就再跑一遍检查，如果两次都有同一条数据不一致，那就有情况了。</p>
</li>
</ol>
<h2 id="3-限制"><a href="#3-限制" class="headerlink" title="3. 限制"></a>3. 限制</h2><ol>
<li>如果检查期间源表数据，变化频繁，有可能检查的结果不准确<br>也就是上面第4点的问题。很明显，这个程序每个检查的事务是分开的，不像pt工具能严格保证每条检查sql的事务顺序。但有不一致的数据再排查一下就ok了。实际在我线上使用过程中，99.9%是准确的。<a id="more"></a></li>
<li><p>表上必须有主键或唯一索引<br>程序会检查，如果没有会退出。</p>
</li>
<li><p>varbinay,blob等二进制字段不支持修复<br>其实也不是完全不支持，要看怎么用的。开发如果有把字符先转成字节，再存入mysql，这种就不支持修复。是有办法可以处理，那就是从源库查时用 <code>hex()</code>函数，修复sql里面<code>unhex()</code>写回去。</p>
</li>
</ol>
<h2 id="4-使用说明"><a href="#4-使用说明" class="headerlink" title="4. 使用说明"></a>4. 使用说明</h2><p>该python程序基于2.7开发，2.6、3.x上没有测试。使用前需要安装 <code>MySQLdb</code>和<code>hotqueue</code>：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip <span class="keyword">install</span> MySQL-python hotqueue</div></pre></td></tr></table></figure></p>
<p>要比较的表和选项，使用全配置化，即不通过命令行的方式指定（原谅命令行参数使用方式会额外增加代码量）。</p>
<h3 id="4-1-px-table-checksum-py"><a href="#4-1-px-table-checksum-py" class="headerlink" title="4.1 px-table-checksum.py"></a>4.1 <code>px-table-checksum.py</code></h3><p>主程序，运行<code>python px-table-checksum.py</code> 执行一致性检查，但一定了解下面的配置文件选项。</p>
<h3 id="4-2-settings-checksum-py"><a href="#4-2-settings-checksum-py" class="headerlink" title="4.2 settings_checksum.py"></a>4.2 <code>settings_checksum.py</code></h3><p>配置选项</p>
<ul>
<li><code>CHUNK_SIZE</code>: 每次提取的chunk行数</li>
<li><code>REDIS_INFO</code>: 指定使用redis队列地址</li>
<li><code>REDIS_QUEUE_CNT</code>: redis队列数量，消费者（目标库）有一一对应的线程守着队列</li>
<li><code>REDIS_POOL_CNT</code>: 生产者（源库）redis客户端连接池。这个设计是为了缓解GIL带来的问题，把入列端与出列端分开，因为如果表多可能短时间有大量sql入队列，避免hotqueue争用</li>
<li><p><code>CALC_CRC32_DB</code>: True 表示在db里面计算checksum值，False表示取出chunk数据在python里面计算。默认给的值是根据连接字符集定的。</p>
</li>
<li><p><code>DO_COMPARE</code>: 运行模式</p>
<ul>
<li>0: 只提取数据计算，不比较是否一致。可以在之后在模式2下只比较</li>
<li>1: 计算，并比较。常用，每次计算之前会删除上一次这个待检查表的结果，比较的结果只告诉哪些chunk号不一致。</li>
<li>2: 不计算，只从t_checkum结果比较。常用，计算是消耗数据库资源的，可以只对已有的checksum计算结果比较不一致的地方。类似pt工具的<code>--replicate-check-only</code>选项。</li>
</ul>
</li>
<li><code>GEN_DATAFIX</code>:<br>与<code>DO_COMPARE</code>结合使用，为 True 表示对不一致的chunk找到具体不一致行，并生成修复sql；为 False 则什么都不做。</li>
<li><p><code>RUN_DATAFIX</code>:<br>与<code>GEN_DATAFIX</code>结合使用，为 True 表示对生成的修复sql，在目标库执行。需要谨慎，如果哪一次设置了修复，记得完成后改回False，不然下次检查另一个表就出意外了，所以特意对这个选项再加了一个确认提示。</p>
</li>
<li><p><code>DB_CHECKSUM</code>: 一个字典，指定checksum的结果存到哪里<br>配置文件有示例，必须指定 <code>db_name</code>，表会自动创建。</p>
</li>
</ul>
<h3 id="4-3-settings-cs-tables-py"><a href="#4-3-settings-cs-tables-py" class="headerlink" title="4.3 settings_cs_tables.py"></a>4.3 <code>settings_cs_tables.py</code></h3><p>上面的配置文件可以认为是用于控制程序的，这个配置文件是指定要校验的源库和目标库信息，以及要检验哪些表。</p>
<ul>
<li><code>TABLES_CHECK</code>: 字典，指定要检查哪些表的一致性，db名为key，多个table名组成列表为value。暂不支持对整个db做检查，同时比较的表数量不建议超过8个</li>
<li><code>DB_SOURCE</code>: 字典，指定源库的连接信息</li>
<li><code>DB_SOURCE</code>: 字典，指定目标库的连接信息</li>
</ul>
<h2 id="5-示例："><a href="#5-示例：" class="headerlink" title="5. 示例："></a>5. 示例：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Starting <span class="keyword">checksum</span> <span class="keyword">thread</span> <span class="keyword">for</span> <span class="keyword">table</span>: db1.t_test_201308 (<span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span>)</div><div class="line"><span class="keyword">Before</span> <span class="keyword">checksum</span>: <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> t_checksum</div><div class="line"><span class="keyword">Before</span> <span class="keyword">checksum</span>: delele <span class="keyword">old</span> <span class="keyword">data</span> <span class="keyword">from</span> t_checksum <span class="keyword">if</span> <span class="keyword">exists</span> <span class="keyword">for</span> <span class="keyword">table</span>:  db1.t_test_201308</div><div class="line">Caculate <span class="keyword">crc32</span> <span class="keyword">in</span> program instead <span class="keyword">of</span> db.(this program need more <span class="keyword">memory</span> <span class="keyword">and</span> more db net traffic, but <span class="keyword">convert</span> <span class="keyword">charset</span>)</div><div class="line">Caculating checksums:  <span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span> db1.t_test_201308</div><div class="line">TARGET: (<span class="string">'192.168.1.121:3306'</span>, <span class="string">'t_test_201308'</span>, <span class="number">1</span>, <span class="string">'db1'</span>, <span class="string">'0'</span>, u<span class="string">'1495969'</span>, <span class="number">451060506</span>)</div><div class="line">TARGET: (<span class="string">'192.168.1.121:3306'</span>, <span class="string">'t_test_201308'</span>, <span class="number">2</span>, <span class="string">'db1'</span>, u<span class="string">'1495969'</span>, u<span class="string">'1502593'</span>, <span class="number">-678155635</span>)</div><div class="line">...</div><div class="line"><span class="keyword">Starting</span> <span class="keyword">checksum</span> <span class="keyword">thread</span> <span class="keyword">for</span> <span class="keyword">table</span>: db1.t_test_201408 (<span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span>)</div><div class="line"><span class="keyword">Before</span> <span class="keyword">checksum</span>: delele <span class="keyword">old</span> <span class="keyword">data</span> <span class="keyword">from</span> t_checksum <span class="keyword">if</span> <span class="keyword">exists</span> <span class="keyword">for</span> <span class="keyword">table</span>:  db1.t_test_201408</div><div class="line">Caculate <span class="keyword">crc32</span> <span class="keyword">in</span> program instead <span class="keyword">of</span> db.(this program need more <span class="keyword">memory</span> <span class="keyword">and</span> more db net traffic, but <span class="keyword">convert</span> <span class="keyword">charset</span>)</div><div class="line">Caculating checksums:  <span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span> db1.t_test_201408</div><div class="line">TARGET: (<span class="string">'192.168.1.121:3306'</span>, <span class="string">'t_test_201408'</span>TARGET: (<span class="string">'192.168.1.121:3306'</span>, <span class="string">'t_test_201408'</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="string">'db1'</span>, u<span class="string">'3836877'</span>, u<span class="string">'3845812'</span>, , <span class="string">'db1'</span>, u<span class="string">'3845812'</span><span class="number">373759054</span>)</div><div class="line">...</div><div class="line">源实例 <span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span> db1.t_test_201308  计算<span class="keyword">checksum</span>结束！</div><div class="line">db conection closed.</div><div class="line"><span class="keyword">Checksum</span> <span class="keyword">thread</span> ended <span class="keyword">for</span> <span class="keyword">table</span>: db1.t_test_201308 (<span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span>)</div><div class="line">...</div><div class="line">源实例 <span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span>:<span class="number">3306</span> db1.t_test_201408  计算<span class="keyword">checksum</span>结束！</div><div class="line">消费<span class="keyword">sql</span> <span class="number">0</span> 退出！！</div><div class="line">消费<span class="keyword">sql</span> <span class="number">-1</span> 退出！！</div><div class="line"></div><div class="line">################################################################################</div><div class="line"><span class="keyword">Start</span> compare <span class="keyword">chunk</span><span class="string">'s crc32 for table: [ db1.t_test_201308 ]</span></div><div class="line">表 db1.t_test_201308 数据一致</div><div class="line"></div><div class="line">################################################################################</div><div class="line">################################################################################</div><div class="line">Start compare chunk's <span class="keyword">crc32</span> <span class="keyword">for</span> <span class="keyword">table</span>: [ db1.t_test_201408 ]</div><div class="line">表 db1.t_test_201408 数据不一致<span class="keyword">chunk</span>数：<span class="number">10</span></div><div class="line"><span class="comment">--------------------------------------------------------------------------------</span></div><div class="line"></div><div class="line">该<span class="keyword">chunk</span> [<span class="number">1</span>] 存在行内容不一致, <span class="keyword">CRC32</span>: src(<span class="number">828649697</span>) rgt(<span class="number">-1396224393</span>)</div><div class="line">去源库和目标库获取<span class="keyword">chunk</span>[<span class="number">1</span>]不一致行：</div><div class="line">  <span class="keyword">TO</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span>:  [u<span class="string">'3761994'</span>]</div><div class="line">  <span class="keyword">TO</span> <span class="keyword">delete</span>:  []</div><div class="line"></div><div class="line">该<span class="keyword">chunk</span> [<span class="number">5</span>] 存在行内容不一致, <span class="keyword">CRC32</span>: src(<span class="number">1513453680</span>) rgt(<span class="number">-1614463460</span>)</div><div class="line">去源库和目标库获取<span class="keyword">chunk</span>[<span class="number">5</span>]不一致行：</div><div class="line">  <span class="keyword">TO</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span>:  [u<span class="string">'3806841'</span>]</div><div class="line">  <span class="keyword">TO</span> <span class="keyword">delete</span>:  []</div></pre></td></tr></table></figure>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/11/20/py-mysql-table-checksum-non-replicas/">http://seanlook.com/2016/11/20/py-mysql-table-checksum-non-replicas/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/seanlook/px-table-checksum&quot;&gt;https://github.com/seanlook/px-table-checksum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主从环境下数据一致性校验经常会用 pt-table-checksum 工具，它的原理及实施过程之前写过一篇文章：&lt;a href=&quot;http://seanlook.com/2015/12/29/mysql_replica_pt-table-checksum/&quot;&gt;生产环境使用 pt-table-checksum 检查MySQL数据一致性&lt;/a&gt;。但是DBA工作中还会有些针对两个表检查是否一致，而这两个表之间并没有主从关系，pt工具是基于binlog把在主库进行的检查动作，在从库重放一遍，此时就不适用了。&lt;/p&gt;
&lt;p&gt;总会有这样特殊的需求，比如从阿里云RDS实例迁移到自建mysql实例，它的数据传输服务实现方式是基于表的批量数据提取，加上binlog订阅，但强制row模式会导致pt-table-checksum没有权限把会话临时改成statement。另一种需求是，整库进行字符集转换：库表定义都是utf8，但应用连接使用了默认的 latin1，要将连接字符集和表字符集统一起来，只能以latin1导出数据，再以utf8导入，这种情况数据一致性校验，且不说binlog解析程序不支持statement（如canal），新旧库本身内容不同，pt-table-checksum 算出的校验值也会不一样，失效。&lt;/p&gt;
&lt;p&gt;所以才萌生了参考 pt-table-checksum 自己写了一个：px-table-checksum 。&lt;/p&gt;
&lt;h2 id=&quot;2-实现方法&quot;&gt;&lt;a href=&quot;#2-实现方法&quot; class=&quot;headerlink&quot; title=&quot;2. 实现方法&quot;&gt;&lt;/a&gt;2. 实现方法&lt;/h2&gt;&lt;p&gt;整体思路是借鉴pt-table-checksum，从源库批量（即chunk）取出一块数据如1000行，计算CRC32值，同样的语句在目标库运行一遍，结果都存入另一个库，最后检查对应编号的chunk crc值是否一致。知道不一致还不行，得能否快速方便的修复差异，所以继续根据那些不一致的chunk，去目标库和源库找到不一致的行，是缺失，还是多余，还是被修改了，然后生成修复sql，根据指示是否自动修复。&lt;/p&gt;
&lt;p&gt;那么问题就在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何确定批次，也就是下一个chunk该怎么取？&lt;br&gt;我还没想做到pt-table-checksum那样，可以根据负载动态调整chunk大小，甚至活跃线程数超过阀值就暂停检查，上来工作量就太大了。目前每次计算的chunk的行数是固定的，可以配置1000或2000等。&lt;br&gt;所以就要用到分页查询，根据（自增或联合）主键、唯一索引，每次limit 1000后升序取最后一条，作为下一批的起始。所以要分析表上的键情况，组合查询条件。目前仅能检查有主键或唯一所以的表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何保证源库和目标库，运行的sql一样？&lt;br&gt;之前一版是目标库和源库，以多线程各自计算chunk，入库，后来才意识到严重的bug：比如同样是取1000行，如果目标库少数据，那么下一个chunk起始就不一样，比较的结果简直一塌糊涂。&lt;br&gt;所以必须保证相同编号的chunk，起点必须相同，所以想到用队列，存放在源库跑过的所有校验sql，模拟pt工具在目标库重放。考虑到要多线程同时比较多个表，队列可能吃内存过大，于是使用了redis队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接在数据库中计算crc32，还是取出数据在内存里计算？&lt;br&gt;翻了pt-table-checksum的源码，它是在数据库里计算的。但是第一节里说过，如果目标库和源库要使用不同的字符集才能读出正确的数据，只能查询出来之后再比较。所以 px-table-checksum 两种都支持，只需指定一个配置项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同时检查多个表，源库sql挤在队列，目标库拿出来执行时过了1s，此时源库那条数据又被修改了一次同步到了目标库，会导致计算结果不一致，实则一致，怎么处理&lt;br&gt;无法处理，是px-table-checksum相比pt-table-checksum最大的缺陷。&lt;br&gt;但为了尽可能减少此类问题（比如主从延迟也可能会），特意设计了多个redis队列，目标库多个检查线程，即比如同时指定检查8个表，源库检查会有8个线程对应，但可以根据表的写入情况，配置4个redis队列（目前是随机入列），10个目标库检查线程，来减少不准确因素。&lt;br&gt;但站在我的角度往往来说，不一致的数据会被记录下来，如果不多，人工核对一下；如果较多，就再跑一遍检查，如果两次都有同一条数据不一致，那就有情况了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3-限制&quot;&gt;&lt;a href=&quot;#3-限制&quot; class=&quot;headerlink&quot; title=&quot;3. 限制&quot;&gt;&lt;/a&gt;3. 限制&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果检查期间源表数据，变化频繁，有可能检查的结果不准确&lt;br&gt;也就是上面第4点的问题。很明显，这个程序每个检查的事务是分开的，不像pt工具能严格保证每条检查sql的事务顺序。但有不一致的数据再排查一下就ok了。实际在我线上使用过程中，99.9%是准确的。
    
    </summary>
    
      <category term="Python" scheme="http://seanlook.com/categories/Python/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="python" scheme="http://seanlook.com/tags/python/"/>
    
      <category term="pt-table-checksum" scheme="http://seanlook.com/tags/pt-table-checksum/"/>
    
  </entry>
  
  <entry>
    <title>让mysqldump变成并发导出导入的魔法</title>
    <link href="http://seanlook.com/2016/11/17/python-mysqldump-out-in-concurrency-magic/"/>
    <id>http://seanlook.com/2016/11/17/python-mysqldump-out-in-concurrency-magic/</id>
    <published>2016-11-17T08:32:49.000Z</published>
    <updated>2016-11-17T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>取名mypumpkin，是python封装的一个让mysqldump以多线程的方式导出库表，再以mysql命令多线程导入新库，用于成倍加快导出，特别是导入的速度。这一切只需要在 mysqldump 或 mysql 命令前面加上 <code>mypumpkin.py</code> 即可，所以称作魔法。</p>
<p><strong>项目地址</strong>：<a href="https://github.com/seanlook/mypumpkin" target="_blank" rel="external">https://github.com/seanlook/mypumpkin</a>  </p>
<p>该程序源于需要对现网单库几百G的数据进行转移到新库，并对中间进行一些特殊操作（如字符集转换），无法容忍mysqldump导入速度。有人可能会提到为什么不用 mydumper，其实也尝试过它但还是放弃了，原因有：</p>
<ol>
<li>不能设置字符集<br>mydumper强制使用 binary 方式来连接库以达到不关心备份恢复时的字符集问题，然而我的场景下需要特意以不同的字符集导出、再导入。写这个程序的时候正好在公众号看到网易有推送的一篇文章 (<a href="http://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650756926&amp;idx=1&amp;sn=b8081a8ae9456a6051d1ba519febee54&amp;chksm=f3f9e2abc48e6bbd5912edb4e6207ff6ec5bf7123fedbf10b5c65a43146af22845dbf0787b39&amp;scene=0#wechat_redirect" target="_blank" rel="external">解密网易MySQL实例迁移高效完成背后的黑科技</a>)，提到他们对mydumper的改进已支持字符集设置，可是在0.9.1版本的patch里还是没找到。</li>
<li>没有像 mysqldump 那样灵活控制过滤选项（导哪些表、忽略哪些表）<br>因为数据量之巨大，而且将近70%是不变更的历史表数据，这些表是可以提前导出转换的；又有少量单表大于50G的，最好是分库导出转换。mydumper 不具备 mysqldump 这样的灵活性</li>
<li>对忽略导出gtid信息、触发器等其它支持<br>阿里云rds 5.6 导出必须要设置 set-gtid-purged=OFF</li>
</ol>
<p>另外有人还可能提到 mysqlpump —— 它才是我认为mysqldump应该具有的模样，语法兼容，基于表的并发导出。但是只有 mysql服务端 5.7.9 以上才支持，这就是现实和理想的距离。。。</p>
<h2 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h2><p>首先说明，mysqldump的导出速度并不慢，经测试能达到50M/s的速度，10G数据花费3分钟的样子，可以看到瓶颈在于网络和磁盘IO，再怎样的导出工具也快不了多少，但是导入却花了60分钟，磁盘和网络大概只用到了20%，瓶颈在目标库写入速度（而一般顺序写入达不到IOPS限制），所以mypumpkin就诞生了 —— 兼顾myloader的导入速度和mysqldump导出的灵活性。</p>
<a id="more"></a>
<p>用python构造1个队列，将需要导出的所有表一次放到队列中，同时启动N个python线程，各自从这个Queue里取出表名，subprocess调用操作系统的mysqldump命令，导出数据到以 dbname.tablename.sql 命名的文件中。load in 与 dump out 类似，根据指定的库名或表名，从dump_dir目录找到所有sql文件，压进队列，N个线程同时调用mysql构造新的命令，模拟 <code>&lt;</code> 操作。</p>
<p>参数解析从原来自己解析，到改用argparse模块，几乎做了一次重构。<br>对于没有指定<code>--tables</code>的情况，程序会主动去库里查询一下所有表名，然后过滤进队列。</p>
<p>load in目标库，选项做到与dump out一样丰富，可以指定导入哪些db、哪些表、忽略哪些表。</p>
<p>其中的重点是做到与原mysqldump兼容，因为需要对与表有关的选项（<code>-B</code>, <code>-A</code>, <code>--tables</code>, <code>--ignore=</code>），进行分析并组合成新的执行命令，考虑的异常情况非常多。</p>
<h2 id="3-限制"><a href="#3-限制" class="headerlink" title="3. 限制"></a>3. 限制</h2><ol>
<li><strong>重要</strong>：导出的数据不保证库级别的一致性<ol>
<li>对历史不变表，是不影响的</li>
<li>具体到一个表能保证一致性，这是mysqldump本身采用哪些选项决定的</li>
<li>不同表导出动作在不同的mysqldump命令中，无法保证事务。<br>在我的案例场景下，是有开发同学辅助使用一套binlog解析程序，等完成后重放所有变更，来保证最终一致性。<br>另，许多情况下我们导数据，并不需要完整的或者一致的数据，只是用于离线分析或临时导出，重点是快速拿数据给到开发。</li>
</ol>
</li>
<li>不寻常选项识别<br>程序已经尽力做到与mysqldump命令兼容，只需要加上 mypumpkin.py、指定dump-dir，就完成并发魔法，但有些情况的参数不方便解析，暂不支持格式：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">db1</span> table1 table2</div><div class="line">db2 db3</div></pre></td></tr></table></figure>
</li>
</ol>
<p>即以上无法在命令行下判断 db1、table1 是库名还是表面，用的时候只需记住“[-A|-B], [–tables], [–ignore-table]”三组，必须出现一个：<code>db1 table1 table2</code>改成<code>db1 --tables table1 table2</code>，<code>db2</code>改成<code>-B db2 db3</code>。</p>
<ol>
<li>密码暂只能显式输入</li>
</ol>
<h2 id="4-使用说明"><a href="#4-使用说明" class="headerlink" title="4. 使用说明"></a>4. 使用说明</h2><p>安装基于python 2.7 开发，其它版本没测。需要按 MySQLdb 库。</p>
<h3 id="4-1-help"><a href="#4-1-help" class="headerlink" title="4.1 help"></a>4.1 help</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">./mypumpkin.py --<span class="keyword">help</span></div><div class="line">Only mysqldump or mysql allowed after mypumpkin.py</div><div class="line"></div><div class="line">usage: mypumpkin.py &#123;mysqldump|mysqls&#125; [--<span class="keyword">help</span>]</div><div class="line"></div><div class="line">This's a <span class="keyword">program</span> that wrap mysqldump/mysql to make them dump-<span class="keyword">out</span>/load-<span class="keyword">in</span></div><div class="line">concurrently. Attention: it can not <span class="keyword">keep</span> consistent <span class="keyword">for</span> whole database(s).</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  --<span class="keyword">help</span>                show this <span class="keyword">help</span> message and <span class="keyword">exit</span></div><div class="line">  -B db1 [db1 ...], --databases db1 [db1 ...]</div><div class="line">                        Dump <span class="keyword">one</span> or <span class="keyword">more</span> databases</div><div class="line">  -A, --all-databases   Dump all databases</div><div class="line">  --tables t1 [t1 ...]  Specifiy tables to dump. Override --databases (-B)</div><div class="line">  --ignore-<span class="keyword">table</span> db1.table1 [db1.table1 ...]</div><div class="line">                        <span class="keyword">Do</span> not dump the specified <span class="keyword">table</span>. (<span class="keyword">format</span> like</div><div class="line">                        --ignore-<span class="keyword">table</span>=dbname.tablename). <span class="keyword">Use</span> the directive</div><div class="line">                        multiple times <span class="keyword">for</span> <span class="keyword">more</span> than <span class="keyword">one</span> <span class="keyword">table</span> to ignore.</div><div class="line">  --threads =<span class="keyword">N</span>          Threads to dump <span class="keyword">out</span> [2], or load <span class="keyword">in</span> [CPUs*2].</div><div class="line">  --dump-<span class="keyword">dir</span> DUMP_DIR   Required. Directory to dump <span class="keyword">out</span> (create <span class="keyword">if</span> not exist),</div><div class="line">                        Or Where to load <span class="keyword">in</span> sqlfile</div><div class="line"></div><div class="line">At least <span class="keyword">one</span> of these 3 group options given: [-A,-B] [--tables] [--ignore-<span class="keyword">table</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>--dump-dir</code>，必选项，原来用的shell标准输入输出 <code>&gt; or &lt;</code> 不允许使用。dump-dir指定目录不存在时会尝试自动创建。</li>
<li><code>--threads=N</code>，N指定并发导出或导入线程数。dump out 默认线程数2， mypumpkin load in 默认线程数是 cpu个数 * 2。<br>注：线程数不是越大越好，这里主要的衡量指标是网络带宽、磁盘IO、目标库IOPS，最好用 dstat 观察一下。</li>
<li><code>-B</code>, <code>--tables</code>，<code>--ignore-table</code>，使用与mysqldump相同，如：  <ol>
<li>在mysqldump里面，<code>--tables</code>会覆盖<code>--databases/-B</code>选项</li>
<li>在mysqldump里面，<code>--tables</code>与<code>--ignore-table</code>不能同时出现</li>
<li>在mysqldump里面，如果没有指定<code>-B</code>，则<code>--tables</code>或<code>--ignore-table</code>必须紧跟db名之后</li>
</ol>
</li>
<li>其它选项，mypumpkin会原封不动的保留下来，放到shell去执行。所以如果其它选项有错误，检查是交给原生mysqldump去做的，执行过程遇到一个失败则会退出线程。</li>
</ul>
<h3 id="4-2-example"><a href="#4-2-example" class="headerlink" title="4.2 example"></a>4.2 example</h3><p>导出：<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 导出源库所有db到visit_dumpdir2目录 （不包括information_schema和performance_schema）</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span>-<span class="string">P3306 </span>\</div><div class="line"> <span class="built_in">--single-transaction</span> <span class="built_in">--opt</span> -A <span class="built_in">--dump-dir</span> <span class="string">visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 导出源库db1,db2，会从原库查询所有表名来过滤</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span>-<span class="string">P3306 </span>\</div><div class="line"> <span class="built_in">--single-transaction</span> <span class="built_in">--opt</span> -B <span class="string">db1 </span><span class="string">db2 </span><span class="built_in">--dump-dir</span> <span class="string">visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 只导出db1库的t1,t2表，如果指定表不存在则有提示</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span>-<span class="string">P3306 </span>\</div><div class="line"> <span class="built_in">--single-transaction</span> <span class="built_in">--opt</span> -B <span class="string">db1 </span><span class="built_in">--tables</span> <span class="string">t1 </span><span class="string">t2 </span><span class="built_in">--dump-dir</span> <span class="string">visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 导出db1,db2库，但忽略 db1.t1, db2.t2, db2.t3表</span></div><div class="line"><span class="comment">## mysqldump只支持--ignore-table=db1.t1这种，使用多个重复指令来指定多表。这里做了兼容扩展</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span><span class="built_in">--single-transaction</span> \</div><div class="line"> <span class="built_in">--opt</span> -B <span class="string">db1 </span><span class="string">db2 </span><span class="built_in">--ignore-table=db1.t1</span> <span class="built_in">--ignore-table</span> <span class="string">db2.</span><span class="string">t2 </span><span class="string">db2.</span><span class="string">t3 </span><span class="built_in">--dump-dir</span> <span class="string">visit_dumpdir2 </span>(如果-A表示全部<span class="string">db)</span></div><div class="line"></div><div class="line"><span class="comment">## 不带 -A/-B</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span>-<span class="string">P3306 </span>\</div><div class="line"> <span class="built_in">--single-transaction</span> <span class="built_in">--opt</span> <span class="string">db1 </span><span class="built_in">--ignore-table=db1.t1</span> <span class="built_in">--dump-dir=visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 其它选项不做处理</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysqldump </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span>-<span class="string">P3306 </span>\</div><div class="line"> <span class="built_in">--single-transaction</span> <span class="built_in">--set-gtid-purged=OFF</span> <span class="built_in">--no-set-names</span> <span class="built_in">--skip-add-locks</span> -e -q -t -n <span class="built_in">--skip-triggers</span> \</div><div class="line"> <span class="built_in">--max-allowed-packet=134217728</span> <span class="built_in">--net-buffer-length=1638400</span> <span class="built_in">--default-character-set=latin1</span> \</div><div class="line"> <span class="built_in">--insert-ignore</span> <span class="built_in">--hex-blob</span> <span class="built_in">--no-autocommit</span> \</div><div class="line"> <span class="string">db1 </span><span class="built_in">--tables</span> <span class="string">t1 </span><span class="built_in">--dump-dir</span> <span class="string">visit_dumpdir2</span></div></pre></td></tr></table></figure></p>
<p>导入：<br><code>-A</code>, <code>-B</code>, <code>--tables</code>, <code>--ignore-table</code>, <code>--threads</code>, <code>--dump-dir</code>用法与作用与上面完全相同，举部分例子：</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 导入dump-dir目录下所有表</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysql </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span><span class="built_in">--port</span> <span class="string">3307 </span>-A \</div><div class="line"> <span class="built_in">--dump-dir=visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 导入db1库（所有表）</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysql </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span><span class="built_in">--port</span> <span class="string">3307 </span>-B <span class="string">db1 </span>\</div><div class="line"> <span class="built_in">--dump-dir=visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 只导入db.t1表</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysql </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span><span class="built_in">--port</span> <span class="string">3307 </span>\</div><div class="line"> <span class="built_in">--default-character-set=utf8mb4</span> <span class="built_in">--max-allowed-packet=134217728</span> <span class="built_in">--net-buffer-length=1638400</span> \</div><div class="line"> -B <span class="string">db1 </span><span class="built_in">--tables</span> <span class="string">t1 </span><span class="built_in">--dump-dir=visit_dumpdir2</span></div><div class="line"></div><div class="line"><span class="comment">## 导入db1,db2库，但忽略db1.t1表（会到dump-dir目录检查db1,db2有无对应的表存在，不在目标库检查）</span></div><div class="line">$ ./<span class="string">mypumpkin.</span><span class="string">py </span><span class="string">mysql </span>-h <span class="string">dbhost_name </span>-<span class="string">utest_user </span>-<span class="string">pyourpassword </span><span class="built_in">--port</span> <span class="string">3307 </span>\</div><div class="line"> -B <span class="string">db1 </span><span class="string">db2 </span><span class="built_in">--ignore-table=db1.t1</span> <span class="built_in">--dump-dir=visit_dumpdir2</span></div></pre></td></tr></table></figure>
<h2 id="5-速度对比"><a href="#5-速度对比" class="headerlink" title="5.速度对比"></a>5.速度对比</h2><hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/11/17/python-mysqldump-out-in-concurrency-magic/">http://seanlook.com/2016/11/17/python-mysqldump-out-in-concurrency-magic/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;取名mypumpkin，是python封装的一个让mysqldump以多线程的方式导出库表，再以mysql命令多线程导入新库，用于成倍加快导出，特别是导入的速度。这一切只需要在 mysqldump 或 mysql 命令前面加上 &lt;code&gt;mypumpkin.py&lt;/code&gt; 即可，所以称作魔法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/seanlook/mypumpkin&quot;&gt;https://github.com/seanlook/mypumpkin&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;该程序源于需要对现网单库几百G的数据进行转移到新库，并对中间进行一些特殊操作（如字符集转换），无法容忍mysqldump导入速度。有人可能会提到为什么不用 mydumper，其实也尝试过它但还是放弃了，原因有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能设置字符集&lt;br&gt;mydumper强制使用 binary 方式来连接库以达到不关心备份恢复时的字符集问题，然而我的场景下需要特意以不同的字符集导出、再导入。写这个程序的时候正好在公众号看到网易有推送的一篇文章 (&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;amp;mid=2650756926&amp;amp;idx=1&amp;amp;sn=b8081a8ae9456a6051d1ba519febee54&amp;amp;chksm=f3f9e2abc48e6bbd5912edb4e6207ff6ec5bf7123fedbf10b5c65a43146af22845dbf0787b39&amp;amp;scene=0#wechat_redirect&quot;&gt;解密网易MySQL实例迁移高效完成背后的黑科技&lt;/a&gt;)，提到他们对mydumper的改进已支持字符集设置，可是在0.9.1版本的patch里还是没找到。&lt;/li&gt;
&lt;li&gt;没有像 mysqldump 那样灵活控制过滤选项（导哪些表、忽略哪些表）&lt;br&gt;因为数据量之巨大，而且将近70%是不变更的历史表数据，这些表是可以提前导出转换的；又有少量单表大于50G的，最好是分库导出转换。mydumper 不具备 mysqldump 这样的灵活性&lt;/li&gt;
&lt;li&gt;对忽略导出gtid信息、触发器等其它支持&lt;br&gt;阿里云rds 5.6 导出必须要设置 set-gtid-purged=OFF&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外有人还可能提到 mysqlpump —— 它才是我认为mysqldump应该具有的模样，语法兼容，基于表的并发导出。但是只有 mysql服务端 5.7.9 以上才支持，这就是现实和理想的距离。。。&lt;/p&gt;
&lt;h2 id=&quot;2-实现方法&quot;&gt;&lt;a href=&quot;#2-实现方法&quot; class=&quot;headerlink&quot; title=&quot;2. 实现方法&quot;&gt;&lt;/a&gt;2. 实现方法&lt;/h2&gt;&lt;p&gt;首先说明，mysqldump的导出速度并不慢，经测试能达到50M/s的速度，10G数据花费3分钟的样子，可以看到瓶颈在于网络和磁盘IO，再怎样的导出工具也快不了多少，但是导入却花了60分钟，磁盘和网络大概只用到了20%，瓶颈在目标库写入速度（而一般顺序写入达不到IOPS限制），所以mypumpkin就诞生了 —— 兼顾myloader的导入速度和mysqldump导出的灵活性。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://seanlook.com/categories/Python/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="mysqldump" scheme="http://seanlook.com/tags/mysqldump/"/>
    
      <category term="python" scheme="http://seanlook.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>mysql使用utf8mb4经验吐血总结</title>
    <link href="http://seanlook.com/2016/10/23/mysql-utf8mb4/"/>
    <id>http://seanlook.com/2016/10/23/mysql-utf8mb4/</id>
    <published>2016-10-23T08:32:49.000Z</published>
    <updated>2016-10-23T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-utf8-与-utf8mb4-异同"><a href="#1-utf8-与-utf8mb4-异同" class="headerlink" title="1. utf8 与 utf8mb4 异同"></a>1. utf8 与 utf8mb4 异同</h2><p>先看 官方手册 <a href="https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html</a> 的说明：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The character <span class="keyword">set</span> named utf8 uses a maximum <span class="keyword">of</span> three <span class="keyword">bytes</span> per <span class="built_in">character</span> <span class="keyword">and</span> contains <span class="keyword">only</span> BMP characters. The utf8mb4 <span class="built_in">character</span> <span class="keyword">set</span> uses a maximum <span class="keyword">of</span> four <span class="keyword">bytes</span> per <span class="built_in">character</span> supports supplementary <span class="keyword">characters</span>:</div><div class="line"></div><div class="line">- <span class="keyword">For</span> a BMP <span class="built_in">character</span>, utf8 <span class="keyword">and</span> utf8mb4 have identical <span class="keyword">storage</span> characteristics: same code <span class="keyword">values</span>, same <span class="keyword">encoding</span>, same length.</div><div class="line">- <span class="keyword">For</span> a supplementary <span class="built_in">character</span>, utf8 cannot <span class="keyword">store</span> the <span class="built_in">character</span> <span class="keyword">at</span> all, whereas utf8mb4 requires four <span class="keyword">bytes</span> <span class="keyword">to</span> <span class="keyword">store</span> it. Because utf8 cannot <span class="keyword">store</span> the <span class="built_in">character</span> <span class="keyword">at</span> all, you have <span class="keyword">no</span> supplementary <span class="keyword">characters</span> <span class="keyword">in</span> utf8 <span class="keyword">columns</span> <span class="keyword">and</span> need <span class="keyword">not</span> worry about converting <span class="keyword">characters</span> <span class="keyword">or</span> losing <span class="keyword">data</span> <span class="keyword">when</span> upgrading utf8 <span class="keyword">data</span> <span class="keyword">from</span> older <span class="keyword">versions</span> <span class="keyword">of</span> MySQL.</div></pre></td></tr></table></figure></p>
<p>MySQL在 5.5.3 之后增加了 <code>utf8mb4</code> 字符编码，mb4即 most bytes 4。简单说 utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。</p>
<p>但抛开数据库，标准的 UTF-8 字符集编码是可以用 1~4 个字节去编码21位字符，这几乎包含了是世界上所有能看见的语言了。然而在MySQL里实现的utf8最长使用3个字节，也就是只支持到了 Unicode 中的 <a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84" target="_blank" rel="external">基本多文本平面</a>（U+0000至U+FFFF），包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符 emoji和一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。</p>
<p>注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。</p>
<p>也就是当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 utf8mb4，同时要注意连接字符集也要设置为utf8mb4，否则在 <a href="http://seanlook.com/2016/04/22/mysql-sql-mode-troubleshooting/">严格模式</a> 下会出现 <code>Incorrect string value: /xF0/xA1/x8B/xBE/xE5/xA2… for column &#39;name&#39;</code>这样的错误，非严格模式下此后的数据会被截断。</p>
<p>提示：另外一种能够存储emoji的方式是，不关心数据库表字符集，只要连接字符集使用 latin1，但相信我，你绝对不想这个干，一是这种字符集混用管理极不规范，二是存储空间被放大（读者可以想下为什么）。</p>
<h2 id="2-utf8mb4-unicode-ci-与-utf8mb4-general-ci-如何选择"><a href="#2-utf8mb4-unicode-ci-与-utf8mb4-general-ci-如何选择" class="headerlink" title="2. utf8mb4_unicode_ci 与 utf8mb4_general_ci 如何选择"></a>2. utf8mb4_unicode_ci 与 utf8mb4_general_ci 如何选择</h2><p>字符除了需要存储，还需要排序或比较大小，涉及到与编码字符集对应的 排序字符集（collation）。ut8mb4对应的排序字符集常用的有 <code>utf8mb4_unicode_ci</code>、<code>utf8mb4_general_ci</code>，到底采用哪个在 stackoverflow 上有个讨论，<a href="http://stackoverflow.com/questions/766809/whats-the-difference-between-utf8-general-ci-and-utf8-unicode-ci" target="_blank" rel="external">What’s the difference between utf8_general_ci and utf8_unicode_ci</a></p>
<p>主要从排序准确性和性能两方面看：</p>
<ul>
<li>准确性<br><code>utf8mb4_unicode_ci</code> 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序<br><code>utf8mb4_general_ci</code> 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。<br><strong>但是在绝大多数情况下，这种特殊字符的顺序一定要那么精确吗</strong>。比如Unicode把<code>ß</code>、<code>Œ</code>当成<code>ss</code>和<code>OE</code>来看；而general会把它们当成<code>s</code>、<code>e</code>，再如<code>ÀÁÅåāă</code>各自都与 <code>A</code> 相等。</li>
<li>性能<br><code>utf8mb4_general_ci</code> 在比较和排序的时候更快<br><code>utf8mb4_unicode_ci</code> 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。<br><strong>但是在绝大多数情况下，不会发生此类复杂比较</strong>。general理论上比Unicode可能快些，但相比现在的CPU来说，它远远不足以成为考虑性能的因素，索引涉及、SQL设计才是。<a id="more"></a>
我个人推荐是 <code>utf8mb4_unicode_ci</code>，将来 8.0 里也极有可能使用变为默认的规则。</li>
</ul>
<p>这也从另一个角度告诉我们，不要可能产生乱码的字段作为主键或唯一索引。我遇到过一例，以 url 来作为唯一索引，但是它记录的有可能是乱码，导致后来想把它们修复就特别麻烦。</p>
<h2 id="3-怎么从utf8转换为utf8mb4"><a href="#3-怎么从utf8转换为utf8mb4" class="headerlink" title="3. 怎么从utf8转换为utf8mb4"></a>3. 怎么从utf8转换为utf8mb4</h2><h3 id="3-1-“伪”转换"><a href="#3-1-“伪”转换" class="headerlink" title="3.1 “伪”转换"></a>3.1 “伪”转换</h3><p>如果你的表定义和连接字符集都是utf8，那么直接在你的表上执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</div></pre></td></tr></table></figure></p>
<p>则能够该表上所有的列的character类型变成 utf8mb4，表定义的默认字符集也会修改。连接的时候需要使用<code>set names utf8mb4</code>便可以插入四字节字符。（如果依然使用 utf8 连接，只要不出现四字节字符则完全没问题）。</p>
<p>上面的 convert 有两个问题，一是它不能ONLINE，也就是执行之后全表禁止修改，有关这方面的讨论见 <a href="http://seanlook.com/2016/05/24/mysql-online-ddl-concept/">mysql 5.6 原生Online DDL解析</a>；二是，它可能会自动该表字段类型定义，如 <a href="http://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="external">VARCHAR 被转成 MEDIUMTEXT</a>，可以通过 MODIFY 指定类型为原类型。</p>
<p>另外 <code>ALTER TABLE tbl_name  DEFAULT CHARACTER SET utf8mb4</code> 这样的语句就不要随便执行了，特别是当表原本不是utf8时，除非表是空的或者你确认表里只有拉丁字符，否则正常和乱的就混在一起了。</p>
<p><strong>最重要的是</strong>，你连接时使用的latin1字符集写入了历史数据，表定义是latin1或utf8，不要期望通过 <code>ALTER ... CONVERT ...</code> 能够让你达到用utf8读取历史中文数据的目的，没卵用，老老实实做逻辑dump。所以我才叫它“伪”转换</p>
<h3 id="3-2-character-set-server"><a href="#3-2-character-set-server" class="headerlink" title="3.2 character-set-server"></a>3.2 character-set-server</h3><p>一旦你决定使用utf8mb4，强烈建议你要修改服务端 <code>character-set-server=utf8mb4</code>，不同的语言对它的处理方法不一样，c++, php, python可以设置character-set，但java驱动依赖于 character-set-server 选项，后面有介绍。</p>
<p>同时还要谨慎一些特殊选项，如 <a href="http://seanlook.com/2016/10/17/mysql-charset-handshake-cdb/">遇到腾讯云CDB连接字符集设置一个坑</a>。个人不建议设置全局 <code>init_connect</code>。</p>
<h2 id="4-key-768-long-错误"><a href="#4-key-768-long-错误" class="headerlink" title="4. key 768 long 错误"></a>4. key 768 long 错误</h2><p>字符集从utf8转到utf8mb4之后，最容易引起的就是索引键超长的问题。</p>
<p>对于表行格式是 <code>COMPACT</code>或 <code>REDUNDANT</code>，InnoDB有单个索引最大字节数 768 的限制，而字段定义的是能存储的字符数，比如 <code>VARCHAR(200)</code> 代表能够存200个汉字，索引定义是字符集类型最大长度算的，即 utf8 maxbytes=3, utf8mb4 maxbytes=4，算下来utf8和utf8mb4两种情况的索引长度分别为600 bytes和800bytes，后者超过了768，导致出错：<code>Error 1071: Specified key was too long; max key length is 767 bytes</code>。</p>
<p><code>COMPRESSED</code>和<code>DYNAMIC</code>格式不受限制，但也依然不建议索引太长，太浪费空间和cpu搜索资源。</p>
<p>如果已有定义超过这个长度的，可加上前缀索引，如果暂不能加上前缀索引（像唯一索引），可把该字段的字符集改回utf8或latin1。<br>但是，（ <strong> 敲黑板啦，很重要 </strong> ），要防止出现 <code>Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) for operation &#39;=&#39;</code> 错误：连接字符集使用utf8mb4，但 SELECT/UPDATE where条件有utf8类型的列，且条件右边存在不属于utf8字符，就会触发该异常。表示踩过这个坑。</p>
<p>再多加一个友好提示：EXPLAIN 结果里面的 key_len 指的搜索索引长度，单位是bytes，而且是以字符集支持的单字符最大字节数算的，这也是为什么 INDEX_LENGTH 膨胀厉害的一个原因。</p>
<h2 id="5-C-C-内存空间分配问题"><a href="#5-C-C-内存空间分配问题" class="headerlink" title="5. C/C++ 内存空间分配问题"></a>5. C/C++ 内存空间分配问题</h2><p>这是我们这边的开发遇到的一个棘手的问题。C或C++连接MySQL使用的是linux系统上的 libmysqlclient 动态库，程序获取到数据之后根据自定义的一个网络协议，按照mysql字段定义的固定字节数来传输数据。从utf8转utf8mb4之后，c++里面针对character单字符内存空间分配，从3个增加到4个，引起异常。</p>
<p>这个问题其实是想说明，使用utf8mb4之后，官方建议尽量用 varchar 代替 char，这样可以减少固定存储空间浪费（关于char与varchar的选择，可参考 <a href="http://seanlook.com/2016/04/28/mysql-char-varchar-set/">这里</a>）。但开发设计表时 varchar 的大小不能随意加大，它虽然是变长的，但客户端在定义变量来获取数据时，是以定义的为准，而非实际长度。按需分配，避免程序使用过多的内存。</p>
<h2 id="6-java驱动使用"><a href="#6-java驱动使用" class="headerlink" title="6. java驱动使用"></a>6. java驱动使用</h2><p>Java语言里面所实现的UTF-8编码就是支持4字节的，所以不需要配置 <code>mb4</code> 这样的字眼，但如果从MySQL读写emoji，MySQL驱动版本要在 5.1.13 及以上版本，数据库连接依然是 <code>characterEncoding=UTF-8</code> 。</p>
<p>但还没完，遇到一个大坑。<a href="http://dev.mysql.com/doc/relnotes/connector-j/5.1/en/news-5-1-13.html" target="_blank" rel="external">官方手册</a> 里还有这么一段话：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Connector/J did <span class="keyword">not</span> support utf8mb4 <span class="keyword">for</span> servers <span class="number">5.5</span><span class="number">.2</span> <span class="keyword">and</span> newer.</div><div class="line"></div><div class="line">Connector/J now auto-detects servers configured <span class="keyword">with</span> character_set_server=utf8mb4 <span class="keyword">or</span> treats <span class="keyword">the</span> Java encoding utf<span class="number">-8</span> passed</div><div class="line">  <span class="keyword">using</span> characterEncoding=... <span class="keyword">as</span> utf8mb4 <span class="keyword">in</span> <span class="keyword">the</span> SET NAMES= calls <span class="keyword">it</span> makes when establishing <span class="keyword">the</span> connection. (Bug <span class="comment">#54175)</span></div></pre></td></tr></table></figure></p>
<p>意思是，java驱动会自动检测服务端 <code>character_set_server</code> 的配置，如果为utf8mb4，驱动在建立连接的时候设置 <code>SET NAMES utf8mb4</code>。然而其他语言没有依赖于这样的特性。</p>
<h2 id="7-主从复制报错"><a href="#7-主从复制报错" class="headerlink" title="7. 主从复制报错"></a>7. 主从复制报错</h2><p>这个问题没有遇到，只是看官方文档有提到，曾经也看到过类似的技术文章。<br>大概就是从库的版本比主库的版本低，导致有些字符集不支持；或者人工修改了从库上的表或字段的字符集定义，都有可能引起异常。</p>
<h2 id="8-join-查询问题"><a href="#8-join-查询问题" class="headerlink" title="8. join 查询问题"></a>8. join 查询问题</h2><p>这个问题是之前在姜承尧老师公众号看到的一篇文章 <a href="http://mp.weixin.qq.com/s/ns9eRxjXZfUPNSpfgGA7UA" target="_blank" rel="external">MySQL表字段字符集不同导致的索引失效问题</a>，自己也验证了一下，的确会有问题：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</div><div class="line">  f_id <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  f_action <span class="built_in">char</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">''</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`f_id`</span>),</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1_copy_mb4 (</div><div class="line">  f_id <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  f_action <span class="built_in">char</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">''</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`f_id`</span>),</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=DYNAMIC;</div><div class="line"></div><div class="line">1.</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">extended</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t1_copy_mb4 t2 <span class="keyword">on</span> t1.f_id=t2.f_id <span class="keyword">where</span> t1.f_id=<span class="string">'421036'</span>;</div><div class="line"></div><div class="line">2.</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">extended</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t1_copy_mb4 t2 <span class="keyword">on</span> t1.f_id=t2.f_id <span class="keyword">where</span> t2.f_id=<span class="string">'421036'</span>;</div></pre></td></tr></table></figure></p>
<p>对应上面1,2 的截图：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-charset-utf8mb4-1.png" alt=""></p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-charset-utf8mb4-2.png" alt=""></p>
<p>其中 2 的warnings 有convert:</p>
<ul>
<li>(convert(<strong>t1.f_id</strong> using utf8mb4) = ‘421036’)</li>
</ul>
<p>官网能找到这一点解释的还是开头那个地址：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Similarly, the following comparison <span class="keyword">in</span> the <span class="keyword">WHERE</span> clause works according <span class="keyword">to</span> the collation <span class="keyword">of</span> utf8mb4_col:</div><div class="line"></div><div class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> utf8_tbl, utf8mb4_tbl</div><div class="line">  <span class="keyword">WHERE</span> utf8_tbl.utf8_col = utf8mb4_tbl.utf8mb4_col;</div></pre></td></tr></table></figure></p>
<p>只是索引失效发生在utf8mb4列 在条件左边。（关于MySQL的隐式类型转换，见<a href="http://seanlook.com/2016/05/05/mysql-type-conversion/">这里</a>）。</p>
<h2 id="9-参考"><a href="#9-参考" class="headerlink" title="9. 参考"></a>9. 参考</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-conversion.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-conversion.html</a></li>
<li><a href="http://forums.mysql.com/read.php?103,187048,188748#msg-188748" target="_blank" rel="external">http://forums.mysql.com/read.php?103,187048,188748#msg-188748</a></li>
<li><a href="http://drupal.stackexchange.com/questions/166405/why-are-we-using-utf8mb4-general-ci-and-not-utf8mb4-unicode-ci" target="_blank" rel="external">Why are we using utf8mb4_general_ci and not utf8mb4_unicode_ci?</a></li>
<li><a href="https://mathiasbynens.be/notes/mysql-utf8mb4" target="_blank" rel="external">How to support full Unicode in MySQL databases</a></li>
<li><a href="http://cenalulu.github.io/mysql/mysql-mojibake/" target="_blank" rel="external">10分钟学会理解和解决MySQL乱码问题</a></li>
</ul>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/10/23/mysql-utf8mb4/">http://seanlook.com/2016/10/23/mysql-utf8mb4/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-utf8-与-utf8mb4-异同&quot;&gt;&lt;a href=&quot;#1-utf8-与-utf8mb4-异同&quot; class=&quot;headerlink&quot; title=&quot;1. utf8 与 utf8mb4 异同&quot;&gt;&lt;/a&gt;1. utf8 与 utf8mb4 异同&lt;/h2&gt;&lt;p&gt;先看 官方手册 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html&quot;&gt;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-utf8mb4.html&lt;/a&gt; 的说明：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;The character &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; named utf8 uses a maximum &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; three &lt;span class=&quot;keyword&quot;&gt;bytes&lt;/span&gt; per &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; contains &lt;span class=&quot;keyword&quot;&gt;only&lt;/span&gt; BMP characters. The utf8mb4 &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; uses a maximum &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; four &lt;span class=&quot;keyword&quot;&gt;bytes&lt;/span&gt; per &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; supports supplementary &lt;span class=&quot;keyword&quot;&gt;characters&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- &lt;span class=&quot;keyword&quot;&gt;For&lt;/span&gt; a BMP &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt;, utf8 &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; utf8mb4 have identical &lt;span class=&quot;keyword&quot;&gt;storage&lt;/span&gt; characteristics: same code &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;, same &lt;span class=&quot;keyword&quot;&gt;encoding&lt;/span&gt;, same length.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- &lt;span class=&quot;keyword&quot;&gt;For&lt;/span&gt; a supplementary &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt;, utf8 cannot &lt;span class=&quot;keyword&quot;&gt;store&lt;/span&gt; the &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt; all, whereas utf8mb4 requires four &lt;span class=&quot;keyword&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;store&lt;/span&gt; it. Because utf8 cannot &lt;span class=&quot;keyword&quot;&gt;store&lt;/span&gt; the &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt; all, you have &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; supplementary &lt;span class=&quot;keyword&quot;&gt;characters&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; utf8 &lt;span class=&quot;keyword&quot;&gt;columns&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; need &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; worry about converting &lt;span class=&quot;keyword&quot;&gt;characters&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; losing &lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; upgrading utf8 &lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; older &lt;span class=&quot;keyword&quot;&gt;versions&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; MySQL.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;MySQL在 5.5.3 之后增加了 &lt;code&gt;utf8mb4&lt;/code&gt; 字符编码，mb4即 most bytes 4。简单说 utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。&lt;/p&gt;
&lt;p&gt;但抛开数据库，标准的 UTF-8 字符集编码是可以用 1~4 个字节去编码21位字符，这几乎包含了是世界上所有能看见的语言了。然而在MySQL里实现的utf8最长使用3个字节，也就是只支持到了 Unicode 中的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84&quot;&gt;基本多文本平面&lt;/a&gt;（U+0000至U+FFFF），包含了控制符、拉丁文，中、日、韩等绝大多数国际字符，但并不是所有，最常见的就算现在手机端常用的表情字符 emoji和一些不常用的汉字，如 “墅” ，这些需要四个字节才能编码出来。&lt;/p&gt;
&lt;p&gt;注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的就是。&lt;/p&gt;
&lt;p&gt;也就是当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 utf8mb4，同时要注意连接字符集也要设置为utf8mb4，否则在 &lt;a href=&quot;http://seanlook.com/2016/04/22/mysql-sql-mode-troubleshooting/&quot;&gt;严格模式&lt;/a&gt; 下会出现 &lt;code&gt;Incorrect string value: /xF0/xA1/x8B/xBE/xE5/xA2… for column &amp;#39;name&amp;#39;&lt;/code&gt;这样的错误，非严格模式下此后的数据会被截断。&lt;/p&gt;
&lt;p&gt;提示：另外一种能够存储emoji的方式是，不关心数据库表字符集，只要连接字符集使用 latin1，但相信我，你绝对不想这个干，一是这种字符集混用管理极不规范，二是存储空间被放大（读者可以想下为什么）。&lt;/p&gt;
&lt;h2 id=&quot;2-utf8mb4-unicode-ci-与-utf8mb4-general-ci-如何选择&quot;&gt;&lt;a href=&quot;#2-utf8mb4-unicode-ci-与-utf8mb4-general-ci-如何选择&quot; class=&quot;headerlink&quot; title=&quot;2. utf8mb4_unicode_ci 与 utf8mb4_general_ci 如何选择&quot;&gt;&lt;/a&gt;2. utf8mb4_unicode_ci 与 utf8mb4_general_ci 如何选择&lt;/h2&gt;&lt;p&gt;字符除了需要存储，还需要排序或比较大小，涉及到与编码字符集对应的 排序字符集（collation）。ut8mb4对应的排序字符集常用的有 &lt;code&gt;utf8mb4_unicode_ci&lt;/code&gt;、&lt;code&gt;utf8mb4_general_ci&lt;/code&gt;，到底采用哪个在 stackoverflow 上有个讨论，&lt;a href=&quot;http://stackoverflow.com/questions/766809/whats-the-difference-between-utf8-general-ci-and-utf8-unicode-ci&quot;&gt;What’s the difference between utf8_general_ci and utf8_unicode_ci&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要从排序准确性和性能两方面看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准确性&lt;br&gt;&lt;code&gt;utf8mb4_unicode_ci&lt;/code&gt; 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序&lt;br&gt;&lt;code&gt;utf8mb4_general_ci&lt;/code&gt; 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。&lt;br&gt;&lt;strong&gt;但是在绝大多数情况下，这种特殊字符的顺序一定要那么精确吗&lt;/strong&gt;。比如Unicode把&lt;code&gt;ß&lt;/code&gt;、&lt;code&gt;Œ&lt;/code&gt;当成&lt;code&gt;ss&lt;/code&gt;和&lt;code&gt;OE&lt;/code&gt;来看；而general会把它们当成&lt;code&gt;s&lt;/code&gt;、&lt;code&gt;e&lt;/code&gt;，再如&lt;code&gt;ÀÁÅåāă&lt;/code&gt;各自都与 &lt;code&gt;A&lt;/code&gt; 相等。&lt;/li&gt;
&lt;li&gt;性能&lt;br&gt;&lt;code&gt;utf8mb4_general_ci&lt;/code&gt; 在比较和排序的时候更快&lt;br&gt;&lt;code&gt;utf8mb4_unicode_ci&lt;/code&gt; 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。&lt;br&gt;&lt;strong&gt;但是在绝大多数情况下，不会发生此类复杂比较&lt;/strong&gt;。general理论上比Unicode可能快些，但相比现在的CPU来说，它远远不足以成为考虑性能的因素，索引涉及、SQL设计才是。
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="字符集" scheme="http://seanlook.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>遇到腾讯云CDB连接字符集设置一个坑</title>
    <link href="http://seanlook.com/2016/10/17/mysql-charset-handshake-cdb/"/>
    <id>http://seanlook.com/2016/10/17/mysql-charset-handshake-cdb/</id>
    <published>2016-10-17T08:32:49.000Z</published>
    <updated>2016-10-17T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个与qq有关的服务迁到腾讯云上，相应的数据库也要从原阿里云RDS迁移到腾讯云CDB上，经过一番摸索，不带任何政治色彩的说，CDB跟RDS相比弱的不止一条街。比如看个错误日志还要提工单，数据库访问没有白名单，数据传输服务竞不支持源库的开启GTID，自带的后台管理是phpMyAdmin，要临时看查询日志也要提工单，当然这些都是可以容忍通过其它方法解决的，但是如果使用上带来了mysql数据库本身的影响，就用的不太爽了。</p>
<p>最近2个月一直在弄与字符集相关的工作，却还是在cdb踩到一个大坑。情况是这样的，我们旧的RDS上的数据库表定义都是utf8，但由于历史原因，开发一直使用 latin1 去连接的。现在要把这样的一个db迁移到CDB，腾讯云的数据传输服务出了点问题，于是想了办法用阿里云的DTS反向迁。现象是：</p>
<ol>
<li>用Navicat客户端latin1连接，旧数据显示都ok</li>
<li>但程序端看到历史数据全是乱码，新数据正常</li>
<li>而且<strong>新数据通过navicat去看用 utf8 连接才正常</strong></li>
<li>在mysql命令行下手动 <code>set names latin1</code> 读取旧数据ok，但新数据乱码</li>
</ol>
<p>这明显是新写入的时候就是以 utf8 连接的，读取的时候新旧数据也以 utf8 连接。但应用端已明确设置使用 latin1 连接来读写。为了验证是否CDB的问题，在相同环境下自建了个mysql实例，一切都ok。</p>
<p>腾讯云工程师先是怀疑迁移有问题，后来说可能是character_set_server设置的问题，我站在2个月来处理字符集的经验看了虽然不太可能，还是配合截了几个图，在工单、电话了里撕了几个来回：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-qcloud-charset1.png" alt=""></p>
<p>因为跟腾讯有合作关系，上头就直接联系到了腾讯云的人，这才找到问题根源：都是<code>--skip-character-set-client-handshake</code>惹的祸。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--character-set-client-handshake</span></div><div class="line"></div><div class="line"><span class="keyword">Do</span> <span class="keyword">not</span> <span class="keyword">ignore</span> <span class="built_in">character</span> <span class="keyword">set</span> information sent <span class="keyword">by</span> the client. <span class="keyword">To</span> <span class="keyword">ignore</span> <span class="keyword">client</span> information <span class="keyword">and</span> <span class="keyword">use</span> the <span class="keyword">default</span> <span class="keyword">server</span> <span class="built_in">character</span> <span class="keyword">set</span>, <span class="keyword">use</span> <span class="comment">--skip-character-set-client-handshake; this makes MySQL behave like MySQL 4.0</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>一看到这个选项就恍然大悟了，官方文档FAQ里有专门介绍：<a href="https://dev.mysql.com/doc/refman/5.6/en/faqs-cjk.html" target="_blank" rel="external">A.11.11</a>（个人感觉最后一段贴的结果有问题），大意是说为了兼容 mysql 4.0 的习惯，mysqld启动时加上 <code>--skip-character-set-client-handshake</code> 来忽略客户端字符集的设置，强制使用服务端<code>character-set-server</code>的设置。</p>
<p>但这个选项默认是没有开启的，当你在web控制台修改了实例字符集时，CDB自作自作主张修改了这个参数并重启 character_set_client_handshake = 0 。而这个参数在 <code>show variables</code> 看不到的，隐藏的比较深。正好我建实例的时候选择了utf8，然后修改为utf8mb4，但应用端要求latin1，便中枪了。</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-qcloud-charset.png" alt=""></p>
<p>主要是以前没听过这个参数，后来发现老叶也有篇文章讲到它 <a href="http://imysql.com/2013/10/29/misunderstand-about-charset-handshake.shtm" target="_blank" rel="external">MySQL字符集的一个坑</a>，其实是很小的东西，结果排查验证问题前后花了2天。。。</p>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/10/17/mysql-charset-handshake-cdb/">http://seanlook.com/2016/10/17/mysql-charset-handshake-cdb/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一个与qq有关的服务迁到腾讯云上，相应的数据库也要从原阿里云RDS迁移到腾讯云CDB上，经过一番摸索，不带任何政治色彩的说，CDB跟RDS相比弱的不止一条街。比如看个错误日志还要提工单，数据库访问没有白名单，数据传输服务竞不支持源库的开启GTID，自带的后台管理是phpMyAdmin，要临时看查询日志也要提工单，当然这些都是可以容忍通过其它方法解决的，但是如果使用上带来了mysql数据库本身的影响，就用的不太爽了。&lt;/p&gt;
&lt;p&gt;最近2个月一直在弄与字符集相关的工作，却还是在cdb踩到一个大坑。情况是这样的，我们旧的RDS上的数据库表定义都是utf8，但由于历史原因，开发一直使用 latin1 去连接的。现在要把这样的一个db迁移到CDB，腾讯云的数据传输服务出了点问题，于是想了办法用阿里云的DTS反向迁。现象是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Navicat客户端latin1连接，旧数据显示都ok&lt;/li&gt;
&lt;li&gt;但程序端看到历史数据全是乱码，新数据正常&lt;/li&gt;
&lt;li&gt;而且&lt;strong&gt;新数据通过navicat去看用 utf8 连接才正常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在mysql命令行下手动 &lt;code&gt;set names latin1&lt;/code&gt; 读取旧数据ok，但新数据乱码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这明显是新写入的时候就是以 utf8 连接的，读取的时候新旧数据也以 utf8 连接。但应用端已明确设置使用 latin1 连接来读写。为了验证是否CDB的问题，在相同环境下自建了个mysql实例，一切都ok。&lt;/p&gt;
&lt;p&gt;腾讯云工程师先是怀疑迁移有问题，后来说可能是character_set_server设置的问题，我站在2个月来处理字符集的经验看了虽然不太可能，还是配合截了几个图，在工单、电话了里撕了几个来回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7q5fot.com1.z0.glb.clouddn.com/mysql-qcloud-charset1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为跟腾讯有合作关系，上头就直接联系到了腾讯云的人，这才找到问题根源：都是&lt;code&gt;--skip-character-set-client-handshake&lt;/code&gt;惹的祸。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--character-set-client-handshake&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ignore&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; information sent &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; the client. &lt;span class=&quot;keyword&quot;&gt;To&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ignore&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;client&lt;/span&gt; information &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; the &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--skip-character-set-client-handshake; this makes MySQL behave like MySQL 4.0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="腾讯云" scheme="http://seanlook.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
      <category term="字符集" scheme="http://seanlook.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>你可能需要一个实时抓取MySQL慢查询现场的程序</title>
    <link href="http://seanlook.com/2016/09/27/python-mysql-querykill/"/>
    <id>http://seanlook.com/2016/09/27/python-mysql-querykill/</id>
    <published>2016-09-27T08:32:49.000Z</published>
    <updated>2016-09-27T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python完成的一个小程序，初衷用于杀掉 MySQL 上的异常线程，如慢查询、处于Sleep状态的，但上线运行以后，以另一种模式运行来实时发现现网的慢查询特别有用，挖掘了许多潜在问题。<br><strong>项目地址</strong>：<a href="https://github.com/seanlook/myquerykill" target="_blank" rel="external">https://github.com/seanlook/myquerykill</a>  </p>
<p>在使用阿里云RDS的过程中，数据库出现异常，需要快速恢复。网上有许多类似的kill脚本，都是通过 mysqladmin 实现的。然而 Ali-RDS 环境有以下限制：</p>
<ul>
<li>不提供 SUPER 权限的用户，也就是用户只能 kill 自己的线程</li>
<li>当连接数暴增时，外部用户无法登陆，包括控制台</li>
</ul>
<p>为了解决上面两大问题，该 python 脚本通过在db实例上，使用多线程的方式，为每个用户保留一个连接，并<strong>实时</strong>读取指令配置文件 <code>mysqk.ini</code>，发现有 kill 需求时，利用对应用户已有连接找到 <code>information_schema.processlist</code> 中符合条件的线程，并 kill 。</p>
<p>说明：该脚本在9月份做过一次重写，7月份的版本（分支 old_0.5.0）是每实例每用户，对应一个线程，db实例一多线程数也太多，看得始终不太优雅，于是改成了一个db实例一个线程，维护同时维护多个用户的会话。同时新版也加入了更多的功能，如按时间窗口检查，包含或排除特定连接，邮件通知，配置项覆盖。</p>
<h1 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h1><ol>
<li>始终通过 mysql ping 维持一个长连接，并有断开自动重来机制，解决没有连接可用的尴尬</li>
<li>每个db实例有自己的线程，避免需要单独登陆个别用户去kill的繁复操作。<br>如果你具有 SUPER 权限，也可以简化配置做到兼容</li>
<li>能够分开应对需要杀死线程的场景：<ul>
<li>长时间运行超过 N 秒的</li>
<li>Sleep 状态的事务 （一般不建议，但有时候kill它，可以快速释放连接给管理员使用）</li>
<li>排除一些线程不能kill，如 Binlog dump。可配置</li>
<li>包含特定关键字的线程要kill</li>
</ul>
</li>
<li>出现符合条件的线程时，会对当时的processlist, engine status，lock_wait 做一个快照，并邮件发出。妈妈再也不愁没有事故现场了。</li>
<li>有试运行dry_run模式，即执行所有的检查过程但不真正kill<br>这便是开头所讲的，实时关注生产环境慢查询，而不是等出现问题被动去看slow log，严重的情况连接数可能已经爆了</li>
<li>支持只在时间窗口内运行，考虑到晚上一些长任务不检查</li>
<li>密码加密</li>
</ol>
<a id="more"></a>
<h1 id="2-快速上手"><a href="#2-快速上手" class="headerlink" title="2. 快速上手"></a>2. 快速上手</h1><p>需要pip安装<code>MySQL-python</code>和<code>pycrypto</code>两个库，只在python 2.7上有测试。</p>
<p>在 <em>settings.py</em> 里面设置连接的用户名和密码信息。这里假设同一批db的要check的认证信息是一样的，指定的用户既用于登录认证，也用于告知脚本哪些用户需要被检查。<br>密码要通过 <code>prpcryptec.py</code> 加密，加密的密钥需写入脚本本身的 <code>KEY_DB_AUTH</code>变量。（担心泄露的话，把mysqk.py编译成 pyc 来跑）</p>
<p>在 <em>mysqk.ini</em> 主配置文件里面  </p>
<ul>
<li><code>db_info</code> 节设置需要被检查的数据库地址，如 <code>db01=10.0.200.100:3306</code></li>
<li>可分别 <code>db01</code>等指定需要kill thread的选项。<code>[id_db01]</code> 则默认复用 <code>[db_commkill]</code> 的选项</li>
<li><code>db_comconfig</code> 节设置 <code>db_puser</code> 为能查看到所有processlist的权限用户，且在 <em>settings.py</em> 的DB_AUTH中已指定</li>
<li><p>只想执行检查，并不想真正kill异常线程，确认 dry_run不等于0</p>
<p>Here we go!</p>
</li>
</ul>
<h1 id="3-配置项说明"><a href="#3-配置项说明" class="headerlink" title="3. 配置项说明"></a>3. 配置项说明</h1><p><strong><code>mysqk.ini</code></strong>：</p>
<h2 id="3-1-mail-config"><a href="#3-1-mail-config" class="headerlink" title="3.1 mail_config"></a>3.1 mail_config</h2><p>邮件通知相关设置，smtp服务地址和认证信息。<br><code>mail_receiver=</code> 设置空，表示不发邮件</p>
<h2 id="3-2-db-info"><a href="#3-2-db-info" class="headerlink" title="3.2 db_info"></a>3.2 db_info</h2><p>设置要检查kill哪些数据库实例.<br>格式：<code>&lt;dbid&gt;=&lt;host&gt;:&lt;port&gt;</code>，dbid是唯一表示db实例的，后面设置各db需要被kill的选项，小节配置名就是 <code>id_&lt;dbid&gt;</code>；端口必需指定。</p>
<p>在这里出现的db实例都会被执行检查，可用 ; 注释，但需要重启脚本。</p>
<h2 id="3-3-db-comconfig"><a href="#3-3-db-comconfig" class="headerlink" title="3.3 db_comconfig"></a>3.3 db_comconfig</h2><p>检查用公共配置，实时生效。</p>
<ul>
<li><code>db_puser</code>：指定一个用户名用于 show processlist，需要的权限：PROCESS、information_schema库查看。可以认为是一个代表用户，检查异常thread，把结果提供给有该thread杀掉权限用户。</li>
<li><code>run_max_count</code>：执行检查的次数，是一个全局控制开关。每次修改这个值都会重新开始检查，即一个 clean start，让刚修改的配置生效。<ul>
<li>为 0 表示脚本不进行任何检查，只简单维护与数据库的连接存活。存活检查频率在 <em>settings.py</em> 由 <code>CHECK_CONFIG_INTERVAL × CHECK_PING_MULTI</code>决定</li>
<li>为 999 表示会在后台一致检查连接线程（但不一定有符合kill条件的），检查的频率在 <em>settings.py</em> 里面 <code>CHECK_CONFIG_INTERVAL</code> 指定</li>
<li>为其它值时，表示检查次数满后停止检查</li>
</ul>
</li>
<li><code>dry_run</code>：是否开启试运行模式，为0表示真实kill，为1或其它值表示试运行。试运行模式可用于监控慢查询并告警。注意同一会话线程ID只告警一次</li>
<li><code>run_time_window</code>：运行的检查的时间窗口，格式如 <code>08:00-22:00</code>，在这个时间以外不执行检查，留空表示不限制。主要考虑晚上一些统计任务可能出现“异常”线程。</li>
</ul>
<h2 id="3-4-db-commkill"><a href="#3-4-db-commkill" class="headerlink" title="3.4 db_commkill"></a>3.4 db_commkill</h2><p>kill用公共配置，实时生效，会被 <code>id_&lt;dbid&gt;</code> 节的选项覆盖。</p>
<ul>
<li><p><code>k_user</code>：很关键的一个选项，表示你要检查并kill哪些数据库用户，多个用逗号分隔（不要带引号）。<br>为 <code>all</code> 时，表示要检查 <em>settings.py</em> 里 DB_AUTH 指定的所有用户<br>为 <code>none</code> 时，表示不kill任何异常线程，效果与设置了 dry_run 模式相当  </p>
</li>
<li><p><code>k_longtime</code>：执行超过设定值的sql则认为异常。一般大于 CHECK_CONFIG_INTERVAL</p>
</li>
<li><code>k_sleep</code>：Sleep超过设定秒的sql则认为异常，为 0 表示不杀掉sleep状态的线程</li>
<li><code>k_exclude</code>：排除掉那些特定关键字的线程，比如复制线程、管理员的连接等</li>
<li><code>k_include</code>：包含这些特定关键字的线程，需要被kill。注意，它作用在满足 k_user 和 k_exclude 的前提之下。<br>k_exclude与k_include 的值是支持python re模块正则的格式，不要带引号</li>
</ul>
<h2 id="3-5-id-dbid"><a href="#3-5-id-dbid" class="headerlink" title="3.5 id_dbid"></a>3.5 id_dbid</h2><p>这部分区域的配置项与 db_commconfig 相同，用于针对个别db的kill选项。</p>
<h1 id="4-使用建议"><a href="#4-使用建议" class="headerlink" title="4. 使用建议"></a>4. 使用建议</h1><p>两种组合模式：</p>
<ol>
<li>设置 <code>dry_run=0</code>，默认 <code>k_user=none</code>，当数据库出现异常时，主动修改对应db的k_user值，动态kill</li>
<li>设置 <code>dry_run=1</code>，默认 <code>k_user=all</code>，相当于运行在daemon模式，有慢查询则邮件通知，并且记录下当时的信息。<strong>建议此模式</strong></li>
</ol>
<p>当然你也可以<code>dry_run=0</code>，<code>k_user=all</code>，让程序一直在后台跑并kill，但生产环境极不推荐。</p>
<p>有日志和快照文件可以查看。</p>
<h1 id="5-配置文件示例"><a href="#5-配置文件示例" class="headerlink" title="5. 配置文件示例"></a>5. 配置文件示例</h1><p>mysqlk.ini :</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mail_config]</span></div><div class="line"><span class="attr">mail_host</span>=smtp.exmail.qq.com</div><div class="line"><span class="attr">mail_user</span>=xxx@ecqun.com</div><div class="line"><span class="attr">mail_pass</span>=xxxxxx</div><div class="line"></div><div class="line"><span class="attr">mail_receiver</span>=</div><div class="line"><span class="section"></span></div><div class="line">[db_info]</div><div class="line"><span class="attr">crm0</span>=<span class="number">192.168</span>.<span class="number">1.125</span>:<span class="number">3306</span></div><div class="line"><span class="attr">crm1</span>=<span class="number">192.168</span>.<span class="number">1.126</span>:<span class="number">3306</span></div><div class="line"><span class="attr">crm2</span>=<span class="number">192.168</span>.<span class="number">1.127</span>:<span class="number">3306</span></div><div class="line"><span class="attr">crm3</span>=<span class="number">192.168</span>.<span class="number">1.128</span>:<span class="number">3306</span></div><div class="line"><span class="attr">base</span>=<span class="number">10.0</span>.<span class="number">200.142</span>:<span class="number">3306</span></div><div class="line"><span class="section"></span></div><div class="line">[db_commconfig]</div><div class="line"><span class="attr">db_puser</span>=ecuser</div><div class="line"></div><div class="line"><span class="comment">; how many kill times once this config file changed</span></div><div class="line"><span class="comment">; 0: DISABLE all kill</span></div><div class="line"><span class="comment">; 999: always kill threads that meet kill conditions</span></div><div class="line"><span class="comment">; default: 1</span></div><div class="line"><span class="comment">; can not be inherit</span></div><div class="line"><span class="attr">run_max_count</span>=<span class="number">999</span></div><div class="line"><span class="attr">dry_run</span>=<span class="number">1</span></div><div class="line"><span class="attr">run_time_window</span>=<span class="number">08</span>:<span class="number">00</span>-<span class="number">22</span>:<span class="number">00</span></div><div class="line"><span class="section"></span></div><div class="line"></div><div class="line">[db_commkill]</div><div class="line"><span class="attr">k_user</span>=all</div><div class="line"><span class="attr">k_longtime</span>=<span class="number">10</span></div><div class="line"><span class="attr">k_lock</span>=<span class="number">1</span></div><div class="line"><span class="attr">k_sleep</span>=<span class="number">0</span></div><div class="line"></div><div class="line"><span class="attr">k_exclude</span>=Binlog|ecdba|Daemon</div><div class="line"><span class="attr">k_include</span>=select sleep\(<span class="number">17</span>\)</div><div class="line"><span class="section"></span></div><div class="line"></div><div class="line">[id_crm0]</div><div class="line"><span class="comment">; k_user: who's threads to be killed. use comma to separate</span></div><div class="line"><span class="comment">;         none: do not kill anyone's threads</span></div><div class="line"><span class="comment">;         all: kill all user's threads (with other where conditions)</span></div><div class="line"><span class="comment">; default: none</span></div><div class="line"><span class="attr">k_user</span>=all</div><div class="line"></div><div class="line"><span class="comment">; k_longtime: filter the threads who's running time is longer than this</span></div><div class="line"><span class="comment">;             0: ignore the time &gt; x  condition</span></div><div class="line"><span class="comment">; default: 10</span></div><div class="line"><span class="attr">k_longtime</span>=<span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment">; k_sleep: whether kill sleepd threads or not</span></div><div class="line"><span class="comment">;          0: do not kill command='Sleep' threads from processlist</span></div><div class="line"><span class="comment">;          when it set to 1, usually it's subset of k_longtime condition</span></div><div class="line"><span class="comment">; default: 0</span></div><div class="line"><span class="attr">k_sleep</span>=<span class="number">0</span></div><div class="line"><span class="section"></span></div><div class="line">[id_crm1]</div><div class="line"><span class="attr">k_user</span>=ecuser</div><div class="line"><span class="attr">k_longtime</span>=<span class="number">10</span></div><div class="line"><span class="attr">k_sleep</span>=<span class="number">0</span></div><div class="line"><span class="section"></span></div><div class="line">[id_crm2]</div><div class="line"><span class="attr">k_user</span>=all</div><div class="line"><span class="attr">k_longtime</span>=<span class="number">10</span></div><div class="line"><span class="attr">k_sleep</span>=<span class="number">0</span></div><div class="line"><span class="section"></span></div><div class="line">[id_crm3]</div></pre></td></tr></table></figure>
<h1 id="6-运行示例"><a href="#6-运行示例" class="headerlink" title="6. 运行示例"></a>6. 运行示例</h1><p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-myquery-shot.png" alt="run-demo"></p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/python-mysql-slowquery-discover.png" alt="slowquery-discover"></p>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/09/27/python-mysql-querykill/">http://seanlook.com/2016/09/27/python-mysql-querykill/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python完成的一个小程序，初衷用于杀掉 MySQL 上的异常线程，如慢查询、处于Sleep状态的，但上线运行以后，以另一种模式运行来实时发现现网的慢查询特别有用，挖掘了许多潜在问题。&lt;br&gt;&lt;strong&gt;项目地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/seanlook/myquerykill&quot;&gt;https://github.com/seanlook/myquerykill&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;在使用阿里云RDS的过程中，数据库出现异常，需要快速恢复。网上有许多类似的kill脚本，都是通过 mysqladmin 实现的。然而 Ali-RDS 环境有以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不提供 SUPER 权限的用户，也就是用户只能 kill 自己的线程&lt;/li&gt;
&lt;li&gt;当连接数暴增时，外部用户无法登陆，包括控制台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决上面两大问题，该 python 脚本通过在db实例上，使用多线程的方式，为每个用户保留一个连接，并&lt;strong&gt;实时&lt;/strong&gt;读取指令配置文件 &lt;code&gt;mysqk.ini&lt;/code&gt;，发现有 kill 需求时，利用对应用户已有连接找到 &lt;code&gt;information_schema.processlist&lt;/code&gt; 中符合条件的线程，并 kill 。&lt;/p&gt;
&lt;p&gt;说明：该脚本在9月份做过一次重写，7月份的版本（分支 old_0.5.0）是每实例每用户，对应一个线程，db实例一多线程数也太多，看得始终不太优雅，于是改成了一个db实例一个线程，维护同时维护多个用户的会话。同时新版也加入了更多的功能，如按时间窗口检查，包含或排除特定连接，邮件通知，配置项覆盖。&lt;/p&gt;
&lt;h1 id=&quot;1-特性&quot;&gt;&lt;a href=&quot;#1-特性&quot; class=&quot;headerlink&quot; title=&quot;1. 特性&quot;&gt;&lt;/a&gt;1. 特性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;始终通过 mysql ping 维持一个长连接，并有断开自动重来机制，解决没有连接可用的尴尬&lt;/li&gt;
&lt;li&gt;每个db实例有自己的线程，避免需要单独登陆个别用户去kill的繁复操作。&lt;br&gt;如果你具有 SUPER 权限，也可以简化配置做到兼容&lt;/li&gt;
&lt;li&gt;能够分开应对需要杀死线程的场景：&lt;ul&gt;
&lt;li&gt;长时间运行超过 N 秒的&lt;/li&gt;
&lt;li&gt;Sleep 状态的事务 （一般不建议，但有时候kill它，可以快速释放连接给管理员使用）&lt;/li&gt;
&lt;li&gt;排除一些线程不能kill，如 Binlog dump。可配置&lt;/li&gt;
&lt;li&gt;包含特定关键字的线程要kill&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出现符合条件的线程时，会对当时的processlist, engine status，lock_wait 做一个快照，并邮件发出。妈妈再也不愁没有事故现场了。&lt;/li&gt;
&lt;li&gt;有试运行dry_run模式，即执行所有的检查过程但不真正kill&lt;br&gt;这便是开头所讲的，实时关注生产环境慢查询，而不是等出现问题被动去看slow log，严重的情况连接数可能已经爆了&lt;/li&gt;
&lt;li&gt;支持只在时间窗口内运行，考虑到晚上一些长任务不检查&lt;/li&gt;
&lt;li&gt;密码加密&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://seanlook.com/categories/Python/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="python" scheme="http://seanlook.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>READ-COMMITED 与 REPEATABLE-READ 事务隔离级别之间的异同</title>
    <link href="http://seanlook.com/2016/09/03/diffs-between-rr-and-rc-trx_isolation_level/"/>
    <id>http://seanlook.com/2016/09/03/diffs-between-rr-and-rc-trx_isolation_level/</id>
    <published>2016-09-03T08:32:49.000Z</published>
    <updated>2016-09-03T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常会被问到 InnoDB隔离级别中 READ-COMMITED和REPEATABLE-READ 的区别，今天就整理了一下，不再从“脏读”、“幻读”这样的名词解释一样去回答了。</p>
<h2 id="1-行锁"><a href="#1-行锁" class="headerlink" title="1. 行锁"></a>1. 行锁</h2><p>InnoDB行锁实际锁的是索引记录，为了防止死锁的产生以及维护所需要的隔离级别，在执行sql语句的全过程中，innodb必须对所需要修改的行每条索引记录上锁。如此一来，如果你执行的 UPDATE 没有很好的索引，那么会导致锁定许多行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> store_id = <span class="number">0</span> <span class="keyword">where</span> store_id = <span class="number">1</span>;</div><div class="line"><span class="comment">---TRANSACTION 1EAB04, ACTIVE 7 sec</span></div><div class="line">633 <span class="keyword">lock</span> <span class="keyword">struct</span>(s), &lt;strong&gt;<span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">96696</span>&lt;/strong&gt;, <span class="number">218786</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s), <span class="keyword">undo</span> <span class="keyword">log</span> entries <span class="number">1</span></div><div class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">4</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f8dfc35d700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">47</span> localhost root</div><div class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></div></pre></td></tr></table></figure></p>
<p>上面的 <code>employees</code> 表 <code>store_id</code> 列没有索引。注意 UPDATE 已经执行完成（没有提交），但依然有 218786 个行锁没有释放，还有一个undo记录。这意味着只有一行被更改，但却持有了额外的锁。堆大小（heap size）代表了分配给锁使用的内存数量。</p>
<p>在 REPEATABLE-READ 级别，事务持有的 <strong>每个锁</strong> 在整个事务期间一直被持有。</p>
<p>在 READ-COMMITED 级别，事务里面特定语句结束之后，不匹配该sql语句扫描条件的锁，会被释放。</p>
<p>下面是上述相同的 UPDATE 在 READ-COMMITED 级别下的结果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">---TRANSACTION 1EAB06, ACTIVE 11 sec</span></div><div class="line">631 <span class="keyword">lock</span> <span class="keyword">struct</span>(s), &lt;strong&gt;<span class="keyword">heap</span> <span class="keyword">size</span> <span class="number">96696</span>&lt;/strong&gt;, <span class="number">1</span> <span class="keyword">row</span> <span class="keyword">lock</span>(s), <span class="keyword">undo</span> <span class="keyword">log</span> entries <span class="number">1</span></div><div class="line">MySQL <span class="keyword">thread</span> <span class="keyword">id</span> <span class="number">4</span>, OS <span class="keyword">thread</span> handle <span class="number">0x7f8dfc35d700</span>, <span class="keyword">query</span> <span class="keyword">id</span> <span class="number">62</span> localhost root</div><div class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></div></pre></td></tr></table></figure></p>
<p>可以看到 heap size 没有变化，但是现在我们只持有一个行锁。无论什么隔离级别下，InnoDB 会为扫描过的每条索引记录创建锁，不同的是在 RC 模式，一旦语句执行完毕（事务未必完成），不符合扫描条件的记录上的锁会被随即释放。释放这些锁后，堆内存并不会马上释放，所以heap size看到与 RR 模式是一样的，但是持有的锁数量明显小了很多。</p>
<p>这也就意味着在 RC 级别下的事务A，只要A的UPDATE <strong>语句</strong> 完成了，其它事务可以修改A中也扫描过的行，但在 RR 级别下不允许。</p>
<h2 id="2-Read-View"><a href="#2-Read-View" class="headerlink" title="2. Read View"></a>2. Read View</h2><h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE-READ"></a>REPEATABLE-READ</h3><p>在 REPEATABLE-READ 级别，<em>read view</em> 对象在事务一开启就被创建，这个一致性快照在整个事务期间一直保持打开。在同一个事务里，前后间隔几个小时执行一遍相同的 SELECT，你会得到完全一样的结果，这就是所谓的 MVCC (multiple version concurrency control)，它是通过行版本号和UNDO段来实现的。</p>
<p>在 REPEATABLE-READ 级别， InnoDB会为范围扫描创建间隙锁（gap locks）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> some_table <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面的update将会创建一个 gap lock，用来防止在 id&gt;100 范围内有新行被插入，锁会持续到事务回滚或提交。比如在同一个事务里，上午5点执行 SELECT … FOR UPDATE，下午5点执行 UPDATE some_table where id&gt;100，那么这个update只会修改上午5点 SELECT FOR UPDATE所锁定的行，因为大于100的记录的整个 <strong>间隙</strong> 被加了锁。</p>
<h3 id="READ-COMMITED"><a href="#READ-COMMITED" class="headerlink" title="READ-COMMITED"></a>READ-COMMITED</h3><p>在 READ-COMMITED 级别，<em>read view</em> 结构在每个语句开始的时候被创建，这意味着即使在同一个事务中，上午5点执行的 SELECT与下午5点执行的SELECT可能会得到不同的结果。因为 read view 在 READ-COMMITED 级别下仅在 <strong>语句执行</strong> 期间存在。</p>
<p>这就是所谓的 “幻读”（phantom read）。</p>
<p>READ-COMMITED 隔离级别下是没有gap locks，所以执行上面的 SELECT FOR UPDATE where id&gt;100 并不会阻止其它事务插入新行，如果同一个事务里后面执行 UPDATE … where id&gt;100，就有可能导致实际更新的行数比前面锁定的行数要多。</p>
<p>补充：<br>如果了解过 mysqldump 的实现原理，可知它就是充分利用InnoDB的MVCC特性，使用 REPEATABLE-READ 模式获取备份事务的一致性快照，避免锁表和幻读。</p>
<p>本文主要参考自 percona博客上的一篇文章 <a href="https://www.percona.com/blog/2012/08/28/differences-between-read-committed-and-repeatable-read-transaction-isolation-levels/" target="_blank" rel="external">https://www.percona.com/blog/2012/08/28/differences-between-read-committed-and-repeatable-read-transaction-isolation-levels/</a> 。</p>
<hr>
<p>本文链接地址：<a href="http://seanlook.com/2016/09/03/diffs-between-rr-and-rc-trx_isolation_level/">http://seanlook.com/2016/09/03/diffs-between-rr-and-rc-trx_isolation_level/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常会被问到 InnoDB隔离级别中 READ-COMMITED和REPEATABLE-READ 的区别，今天就整理了一下，不再从“脏读”、“幻读”这样的名词解释一样去回答了。&lt;/p&gt;
&lt;h2 id=&quot;1-行锁&quot;&gt;&lt;a href=&quot;#1-行锁&quot; class=&quot;headerlink&quot; title=&quot;1. 行锁&quot;&gt;&lt;/a&gt;1. 行锁&lt;/h2&gt;&lt;p&gt;InnoDB行锁实际锁的是索引记录，为了防止死锁的产生以及维护所需要的隔离级别，在执行sql语句的全过程中，innodb必须对所需要修改的行每条索引记录上锁。如此一来，如果你执行的 UPDATE 没有很好的索引，那么会导致锁定许多行：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt; employees &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; store_id = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; store_id = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;---TRANSACTION 1EAB04, ACTIVE 7 sec&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;633 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;(s), &amp;lt;strong&amp;gt;&lt;span class=&quot;keyword&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;96696&lt;/span&gt;&amp;lt;/strong&amp;gt;, &lt;span class=&quot;number&quot;&gt;218786&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;(s), &lt;span class=&quot;keyword&quot;&gt;undo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;log&lt;/span&gt; entries &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MySQL &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, OS &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; handle &lt;span class=&quot;number&quot;&gt;0x7f8dfc35d700&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;47&lt;/span&gt; localhost root&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;innodb&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;status&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的 &lt;code&gt;employees&lt;/code&gt; 表 &lt;code&gt;store_id&lt;/code&gt; 列没有索引。注意 UPDATE 已经执行完成（没有提交），但依然有 218786 个行锁没有释放，还有一个undo记录。这意味着只有一行被更改，但却持有了额外的锁。堆大小（heap size）代表了分配给锁使用的内存数量。&lt;/p&gt;
&lt;p&gt;在 REPEATABLE-READ 级别，事务持有的 &lt;strong&gt;每个锁&lt;/strong&gt; 在整个事务期间一直被持有。&lt;/p&gt;
&lt;p&gt;在 READ-COMMITED 级别，事务里面特定语句结束之后，不匹配该sql语句扫描条件的锁，会被释放。&lt;/p&gt;
&lt;p&gt;下面是上述相同的 UPDATE 在 READ-COMMITED 级别下的结果：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;---TRANSACTION 1EAB06, ACTIVE 11 sec&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;631 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;(s), &amp;lt;strong&amp;gt;&lt;span class=&quot;keyword&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;96696&lt;/span&gt;&amp;lt;/strong&amp;gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;(s), &lt;span class=&quot;keyword&quot;&gt;undo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;log&lt;/span&gt; entries &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MySQL &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, OS &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; handle &lt;span class=&quot;number&quot;&gt;0x7f8dfc35d700&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;62&lt;/span&gt; localhost root&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;innodb&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;status&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到 heap size 没有变化，但是现在我们只持有一个行锁。无论什么隔离级别下，InnoDB 会为扫描过的每条索引记录创建锁，不同的是在 RC 模式，一旦语句执行完毕（事务未必完成），不符合扫描条件的记录上的锁会被随即释放。释放这些锁后，堆内存并不会马上释放，所以heap size看到与 RR 模式是一样的，但是持有的锁数量明显小了很多。&lt;/p&gt;
&lt;p&gt;这也就意味着在 RC 级别下的事务A，只要A的UPDATE &lt;strong&gt;语句&lt;/strong&gt; 完成了，其它事务可以修改A中也扫描过的行，但在 RR 级别下不允许。&lt;/p&gt;
&lt;h2 id=&quot;2-Read-View&quot;&gt;&lt;a href=&quot;#2-Read-View&quot; class=&quot;headerlink&quot; title=&quot;2. Read View&quot;&gt;&lt;/a&gt;2. Read View&lt;/h2&gt;&lt;h3 id=&quot;REPEATABLE-READ&quot;&gt;&lt;a href=&quot;#REPEATABLE-READ&quot; class=&quot;headerlink&quot; title=&quot;REPEATABLE-READ&quot;&gt;&lt;/a&gt;REPEATABLE-READ&lt;/h3&gt;&lt;p&gt;在 REPEATABLE-READ 级别，&lt;em&gt;read view&lt;/em&gt; 对象在事务一开启就被创建，这个一致性快照在整个事务期间一直保持打开。在同一个事务里，前后间隔几个小时执行一遍相同的 SELECT，你会得到完全一样的结果，这就是所谓的 MVCC (multiple version concurrency control)，它是通过行版本号和UNDO段来实现的。&lt;/p&gt;
&lt;p&gt;在 REPEATABLE-READ 级别， InnoDB会为范围扫描创建间隙锁（gap locks）：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; some_table &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UPDATE&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="事务" scheme="http://seanlook.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅析MySQL事务隔离级别与锁 分享</title>
    <link href="http://seanlook.com/2016/08/30/mysql-ppt-trx_isolation-lock/"/>
    <id>http://seanlook.com/2016/08/30/mysql-ppt-trx_isolation-lock/</id>
    <published>2016-08-30T13:32:49.000Z</published>
    <updated>2016-08-30T13:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间在公司内部准备了一个分享，主题是关于 MySQL事务与锁，准备过程内容很多，也深入弄清楚了一些以前比较迷糊的地方，加上后面的讨论也就一个半小时。</p>
<p>主要涉及的是乐观锁与悲观锁，InnoDB多版本并发控制的实现，以及隔离级别与各种情况加锁分析，因为涉及的主要还是开发人员，所以不是很深奥。也算花了不少心血，分享一下。</p>
<p>slideshare: <a href="http://www.slideshare.net/ssuser5a0bc0/my-sql-seanlook" target="_blank" rel="external">http://www.slideshare.net/ssuser5a0bc0/my-sql-seanlook</a></p>


	<div class="row">
	  <iframe src="http://nagland.github.io/viewer/web/viewer.html?val=http://7q5fot.com1.z0.glb.clouddn.com/mysql-ppt-trx_isolation-lock-seanlook.pdf" style="width:100%; height:550px"></iframe>
	</div>



<hr>
<p>原文连接地址：<a href="http://seanlook.com/2016/08/30/mysql-ppt-trx_isolation-lock/">http://seanlook.com/2016/08/30/mysql-ppt-trx_isolation-lock/</a></p>
<hr>
<!--
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/3HLJJcJmM9KLGT" width="900" height="512" frameborder="0" allowfullscreen></iframe>
<p>–&gt;</p>
-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间在公司内部准备了一个分享，主题是关于 MySQL事务与锁，准备过程内容很多，也深入弄清楚了一些以前比较迷糊的地方，加上后面的讨论也就一个半小时。&lt;/p&gt;
&lt;p&gt;主要涉及的是乐观锁与悲观锁，InnoDB多版本并发控制的实现，以及隔离级别与各种情况加锁分析，因为涉及的主
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="事务" scheme="http://seanlook.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Advanced MySQL Query Tuning .pdf</title>
    <link href="http://seanlook.com/2016/06/11/mysql-advanced-query-tuning-percona/"/>
    <id>http://seanlook.com/2016/06/11/mysql-advanced-query-tuning-percona/</id>
    <published>2016-06-11T08:32:49.000Z</published>
    <updated>2016-06-11T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>端午在家无聊，又不想学习。于是在Youtube随便逛，看到一个很不错的分享，来自 Percona Database Performance。下面是演示稿：</p>
<p>slideshare: <a href="http://www.slideshare.net/ssuser5a0bc0/webinar-2013-advancedquerytuning" target="_blank" rel="external">http://www.slideshare.net/ssuser5a0bc0/webinar-2013-advancedquerytuning</a> </p>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/3HLJJcJmM9KLGT" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<p>Youtube: <a href="https://www.youtube.com/watch?v=TPFibi2G_oo" target="_blank" rel="external">https://www.youtube.com/watch?v=TPFibi2G_oo</a></p>
<p>能 <em>条件</em> 的可以看看。</p>
<p>Percona webinars上有许多类似的分享，传送门： <a href="https://www.percona.com/resources/webinars" target="_blank" rel="external">https://www.percona.com/resources/webinars</a> ，不少是他们CEO Peter Zaitsev 亲自上马的。</p>
<hr>
<p>原文连接地址：<a href="http://seanlook.com/2016/06/11/mysql-advanced-query-tuning-percona/">http://seanlook.com/2016/06/11/mysql-advanced-query-tuning-percona/</a></p>
<hr>
<!--
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/3HLJJcJmM9KLGT" width="900" height="512" frameborder="0" allowfullscreen></iframe>
<p>–&gt;</p>
--></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;端午在家无聊，又不想学习。于是在Youtube随便逛，看到一个很不错的分享，来自 Percona Database Performance。下面是演示稿：&lt;/p&gt;
&lt;p&gt;slideshare: &lt;a href=&quot;http://www.slideshare.net/ssuse
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="SQL优化" scheme="http://seanlook.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用pt-osc修改主键时注意</title>
    <link href="http://seanlook.com/2016/05/27/mysql-pt-osc-add-primarykey/"/>
    <id>http://seanlook.com/2016/05/27/mysql-pt-osc-add-primarykey/</id>
    <published>2016-05-27T08:32:49.000Z</published>
    <updated>2016-05-27T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 pt-online-schema-change 做在线ddl最添加普通索引、列，修改列类型、添加默认值等使用比较常规，但涉及到要修改的是主键时就有点棘手。在我修改线上实例过程中，有这样的需求，不妨先思考一下怎么做才好：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">原表上有个复合主键，现在要添加一个自增<span class="built_in">id</span>作为主键，如何进行</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>会涉及到以下修改动作：</p>
<ol>
<li>删除复合主键定义</li>
<li>添加新的自增主键</li>
<li>原复合主键字段，修改成唯一索引</li>
</ol>
<p>如果你够聪明，应该会把这三个操作放在同一个 alter table 命令执行。percona手册里有两个地方对修改主键进行了特殊注解：</p>
<blockquote>
<p>–alter<br>A notable exception is when a PRIMARY KEY or UNIQUE INDEX is being created from existing columns as part of the ALTER clause; in that case it will use these column(s) for the DELETE trigger.</p>
<p>–[no]check-alter</p>
<ul>
<li>DROP PRIMARY KEY<br>If –alter contain DROP PRIMARY KEY (case- and space-insensitive), a warning is printed and the tool exits unless –dry-run is specified. Altering the primary key can be dangerous, but the tool can handle it. The tool’s triggers, particularly the DELETE trigger, are most affected by altering the primary key because the tool prefers to use the primary key for its triggers. You should first run the tool with –dry-run and –print and verify that the triggers are correct.</li>
</ul>
</blockquote>
<p>由上一篇文章 <a href="http://seanlook.com/2016/05/27/mysql-pt-online-schema-change/">pt-online-schema-change使用说明、限制与比较</a> 可知，pt-osc会在原表t1上创建 AFTER DELETE/UPDATE/INSERT 三个触发器，修改主键影响最大的就是 DELETE 触发器：新表t2上的主键字段在旧表t1上不存在，无法根据主键条件触发删除新表t2数据。<code>but the tool can handle it</code>，原因是pt-osc把触发器改成了下面的形式：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TRIGGER `pt_osc_confluence_sbtest3_del` AFTER DELETE ON `confluence`.`sbtest3` FOR EACH ROW DELETE IGNORE FROM `confluence`.`_sbtest3_new` </div><div class="line">WHERE `confluence`.`_sbtest3_new`.`id` &lt;=&gt; OLD.`id` <span class="literal">AND</span> `confluence`.`_sbtest3_new`.`k` &lt;=&gt; OLD.`k`</div><div class="line"></div><div class="line">注：sbtest3表上以(id,k)作为复合主键</div></pre></td></tr></table></figure></p>
<p>但是如果id或k列上没有索引，这个删除的代价非常高，所以一定要同时添加复合（唯一）索引 <code>(id,k)</code> .</p>
<p>而对于INSERT,UPDATE的触发器，依然是 <code>REPLACE INTO</code>语法，因为它采用的是先插入，如果违反主键或唯一约束，则根据主键或意义约束删除这条数据，再执行插入。（但是注意你不能依赖于新表的主键递增，因为如果原表有update，新表就会先插入这一条，导致id与原表记录所在顺序不一样）</p>
<p>所以如果使用pt-osc去修改删除主键，务必同时添加原主键为 UNIQUE KEY，否则很有可能导致性能问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ pt-online-schema-<span class="keyword">change</span> <span class="comment">--user=ecuser --password=ecuser --host=10.0.201.34  \</span></div><div class="line"><span class="comment">--alter "DROP PRIMARY KEY,add column pk int auto_increment primary key,add unique key uk_id_k(id,k)" \</span></div><div class="line">D=confluence,t=sbtest3 <span class="comment">--print --dry-run</span></div><div class="line"></div><div class="line"><span class="comment">--alter contains 'DROP PRIMARY KEY'.  Dropping and altering the primary key can be dangerous, </span></div><div class="line">especially <span class="keyword">if</span> the original <span class="keyword">table</span> does <span class="keyword">not</span> have other <span class="keyword">unique</span> indexes.  ==&gt;注意 dry-run的输出</div><div class="line"></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>,<span class="keyword">add</span> <span class="keyword">column</span> pk <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,<span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">key</span> uk_id_k(<span class="keyword">id</span>,k)</div><div class="line">Altered <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> OK.</div><div class="line"><span class="keyword">Using</span> original <span class="keyword">table</span> <span class="keyword">index</span> PRIMARY <span class="keyword">for</span> the <span class="keyword">DELETE</span> <span class="keyword">trigger</span> instead <span class="keyword">of</span> <span class="keyword">new</span> <span class="keyword">table</span> <span class="keyword">index</span> PRIMARY because ==&gt; 使用原表主键值判断</div><div class="line">the <span class="keyword">new</span> <span class="keyword">table</span> <span class="keyword">index</span> uses <span class="keyword">column</span> pk which does <span class="keyword">not</span> exist <span class="keyword">in</span> the original table.</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`pt_osc_confluence_sbtest3_del`</span> <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">`confluence`</span>.<span class="string">`sbtest3`</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">DELETE</span> <span class="keyword">IGNORE</span> <span class="keyword">FROM</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> </div><div class="line"><span class="keyword">WHERE</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span>.<span class="string">`id`</span> &lt;=&gt; OLD.<span class="string">`id`</span> <span class="keyword">AND</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span>.<span class="string">`k`</span> &lt;=&gt; OLD.<span class="string">`k`</span></div></pre></td></tr></table></figure>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/05/27/mysql-pt-osc-add-primarykey/">http://seanlook.com/2016/05/27/mysql-pt-osc-add-primarykey/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 pt-online-schema-change 做在线ddl最添加普通索引、列，修改列类型、添加默认值等使用比较常规，但涉及到要修改的是主键时就有点棘手。在我修改线上实例过程中，有这样的需求，不妨先思考一下怎么做才好：&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;原表上有个复合主键，现在要添加一个自增&lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;作为主键，如何进行&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="Percona-toolkit" scheme="http://seanlook.com/tags/Percona-toolkit/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change使用说明、限制与比较</title>
    <link href="http://seanlook.com/2016/05/27/mysql-pt-online-schema-change/"/>
    <id>http://seanlook.com/2016/05/27/mysql-pt-online-schema-change/</id>
    <published>2016-05-27T08:32:49.000Z</published>
    <updated>2016-05-27T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果正在看这篇文章，相信你已经知道自己的需求了。</p>
<p>在 mysql 5.5 版本以前，修改表结构如添加索引、修改列，需要锁表，期间不能写入，对于大表这简直是灾难。从5.5特别是5.6里，情况有了好转，支持Online DDL，相关介绍见 <a href="http://seanlook.com/2016/05/24/mysql-online-ddl-concept">这篇文章</a>，而我在实际alter table过程中还是会引起 data meta lock 问题。pt-online-schema-change是Percona-toolkit一员，通过改进原生ddl的方式，达到不锁表在线修改表结构。</p>
<h2 id="1-pt-osc工作过程"><a href="#1-pt-osc工作过程" class="headerlink" title="1. pt-osc工作过程"></a>1. pt-osc工作过程</h2><ol>
<li>创建一个和要执行 alter 操作的表一样的新的空表结构(是alter之前的结构)</li>
<li>在新表执行alter table 语句（速度应该很快）</li>
<li>在原表中创建触发器3个触发器分别对应insert,update,delete操作</li>
<li>以一定块大小从原表拷贝数据到临时表，拷贝过程中通过原表上的触发器在原表进行的写操作都会更新到新建的临时表</li>
<li>Rename 原表到old表中，在把临时表Rename为原表</li>
<li>如果有参考该表的外键，根据alter-foreign-keys-method参数的值，检测外键相关的表，做相应设置的处理</li>
<li>默认最后将旧原表删除</li>
</ol>
<h2 id="2-常用选项说明"><a href="#2-常用选项说明" class="headerlink" title="2. 常用选项说明"></a>2. 常用选项说明</h2><p>只介绍部分常用的选项</p>
<ul>
<li><code>--host=xxx --user=xxx --password=xxx</code><br>连接实例信息，缩写<code>-h xxx -u xxx -p xxx</code>，密码可以使用参数<code>--ask-pass</code> 手动输入。</li>
<li><code>--alter</code><br>结构变更语句，不需要 <code>ALTER TABLE</code>关键字。与原始ddl一样可以指定多个更改，用逗号分隔。<ul>
<li>绝大部分情况下表上需要有主键或唯一索引，因为工具在运行当中为了保证新表也是最新的，需要旧表上创建 DELETE和UPDATE 触发器，同步到新表的时候有主键会更快。个别情况是，当alter操作就是在c1列上建立主键时，DELETE触发器将基于c1列。</li>
<li>子句不支持 rename 去给表重命名。 </li>
<li>alter命令原表就不支持给索引重命名，需要先drop再add，在pt-osc也一样。(mysql 5.7 支持 RENAME INDEX old_index_name TO new_index_name)<br>但给字段重命名，千万不要drop-add，整列数据会丢失，使用<code>change col1 col1_new type constraint</code>（保持类型和约束一致，否则相当于修改 column type，不能online）</li>
<li>子句如果是add column并且定义了not null，那么必须指定default值，否则会失败。</li>
<li>如果要删除外键（名 fk_foo），使用工具的时候外键名要加下划线，比如<code>--alter &quot;DROP FOREIGN KEY _fk_foo&quot;</code></li>
</ul>
</li>
</ul>
<ul>
<li><p><code>D=db_name,t=table_name</code><br>指定要ddl的数据库名和表名</p>
</li>
<li><p><code>--max-load</code><br>默认为<code>Threads_running=25</code>。每个chunk拷贝完后，会检查 <em>SHOW GLOBAL STATUS</em> 的内容，检查指标是否超过了指定的阈值。如果超过，则先暂停。这里可以用逗号分隔，指定多个条件，每个条件格式： <code>status指标=MAX_VALUE</code>或者<code>status指标:MAX_VALUE</code>。如果不指定MAX_VALUE，那么工具会这只其为当前值的120%。<br>因为拷贝行有可能会给部分行上锁，Threads_running 是判断当前数据库负载的绝佳指标。</p>
</li>
<li><p><code>--max-lag</code><br>默认1s。每个chunk拷贝完成后，会查看所有复制Slave的延迟情况（<code>Seconds_Behind_Master</code>）。要是延迟大于该值，则暂停复制数据，直到所有从的滞后小于这个值。<code>--check-interval</code>配合使用，指定出现从库滞后超过 max-lag，则该工具将睡眠多长时间，默认1s，再检查。如<code>--max-lag=5 --check-interval=2</code>。<br>熟悉percona-toolkit的人都知道<code>--recursion-method</code>可以用来指定从库dsn记录。另外，如果从库被停止，将会永远等待，直到从开始同步，并且延迟小于该值。</p>
</li>
<li><p><code>--chunk-time</code><br>默认0.5s，即拷贝数据行的时候，为了尽量保证0.5s内拷完一个chunk，动态调整chunk-size的大小，以适应服务器性能的变化。<br>也可以通过另外一个选项<code>--chunk-size</code>禁止动态调整，即每次固定拷贝 1k 行，如果指定则默认1000行，且比 chunk-time 优先生效</p>
<a id="more"></a></li>
<li><p><code>--set-vars</code><br>使用pt-osc进行ddl要开一个session去操作，<code>set-vars</code>可以在执行alter之前设定这些变量，比如默认会设置<code>--set-vars &quot;wait_timeout=10000,innodb_lock_wait_timeout=1,lock_wait_timeout=60&quot;</code>。<br>因为使用pt-osc之后ddl的速度会变慢，所以预计2.5h只能还不能改完，记得加大<code>wait_timeout</code>。</p>
</li>
<li><p><code>--dry-run</code><br>创建和修改新表，但不会创建触发器、复制数据、和替换原表。并不真正执行，可以看到生成的执行语句，了解其执行步骤与细节，和<code>--print</code>配合最佳。。</p>
</li>
<li><p><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</p>
</li>
</ul>
<h2 id="3-使用疑惑（限制）"><a href="#3-使用疑惑（限制）" class="headerlink" title="3. 使用疑惑（限制）"></a>3. 使用疑惑（限制）</h2><h3 id="3-1-原表上不能有触发器存在"><a href="#3-1-原表上不能有触发器存在" class="headerlink" title="3.1 原表上不能有触发器存在"></a>3.1 原表上不能有触发器存在</h3><p>这个很容易理解，pt-osc会在原表上创建3个触发器，而一个表上不能同时有2个相同类型的触发器，为简单通用起见，只能一棍子打死。<br>所以如果要让它支持有触发器存在的表也是可以实现的，思路就是：先找到原表触发器定义；重写原表触发器；最后阶段将原表触发器定义应用到新表。</p>
<h3 id="3-2-通过触发器写数据到临时新表，会不会出现数据不一致或异常"><a href="#3-2-通过触发器写数据到临时新表，会不会出现数据不一致或异常" class="headerlink" title="3.2 通过触发器写数据到临时新表，会不会出现数据不一致或异常"></a>3.2 通过触发器写数据到临时新表，会不会出现数据不一致或异常</h3><p>这其实是我的一个顾虑，因为如果update t1，触发update t2，但这条数据还没copy到t2，不就有异常了吗？后台通过打开general_log，看到它创建的触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    6165 Query     <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`pt_osc_confluence_sbtest3_del`</span> <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="string">`confluence`</span>.<span class="string">`sbtest3`</span> </div><div class="line">        <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">DELETE</span> <span class="keyword">IGNORE</span> <span class="keyword">FROM</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> <span class="keyword">WHERE</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span>.<span class="string">`id`</span> &lt;=&gt; OLD.<span class="string">`id`</span></div><div class="line">    <span class="number">6165</span> <span class="keyword">Query</span>     <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`pt_osc_confluence_sbtest3_upd`</span> <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="string">`confluence`</span>.<span class="string">`sbtest3`</span> </div><div class="line">        <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> (<span class="string">`id`</span>, <span class="string">`k`</span>, <span class="string">`c`</span>, <span class="string">`pad`</span>) <span class="keyword">VALUES</span> (NEW.<span class="string">`id`</span>, NEW.<span class="string">`k`</span>, NEW.<span class="string">`c`</span>, NEW.<span class="string">`pad`</span>)</div><div class="line">    <span class="number">6165</span> <span class="keyword">Query</span>     <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`pt_osc_confluence_sbtest3_ins`</span> <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="string">`confluence`</span>.<span class="string">`sbtest3`</span> </div><div class="line">        <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> (<span class="string">`id`</span>, <span class="string">`k`</span>, <span class="string">`c`</span>, <span class="string">`pad`</span>) <span class="keyword">VALUES</span> (NEW.<span class="string">`id`</span>, NEW.<span class="string">`k`</span>, NEW.<span class="string">`c`</span>, NEW.<span class="string">`pad`</span>)</div><div class="line"></div><div class="line">并且copy操作是：</div><div class="line"></div><div class="line">    <span class="number">6165</span> <span class="keyword">Query</span>     <span class="keyword">INSERT</span> <span class="keyword">LOW_PRIORITY</span> <span class="keyword">IGNORE</span> <span class="keyword">INTO</span> <span class="string">`confluence`</span>.<span class="string">`_sbtest3_new`</span> (<span class="string">`id`</span>, <span class="string">`k`</span>, <span class="string">`c`</span>, <span class="string">`pad`</span>) </div><div class="line">         <span class="keyword">SELECT</span> <span class="string">`id`</span>, <span class="string">`k`</span>, <span class="string">`c`</span>, <span class="string">`pad`</span> <span class="keyword">FROM</span> <span class="string">`confluence`</span>.<span class="string">`sbtest3`</span> <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(<span class="string">`PRIMARY`</span>) <span class="keyword">WHERE</span> ((<span class="string">`id`</span> &gt;= <span class="string">'4692805'</span>)) <span class="keyword">AND</span> ((<span class="string">`id`</span> &lt;= <span class="string">'4718680'</span>)) </div><div class="line">        <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> <span class="comment">/*pt-online-schema-change 46459 copy nibble*/</span></div></pre></td></tr></table></figure></p>
<p>在原表上update，新临时表上是replace into整行数据，所以达到有则更新，无则插入。同时配合后面的 insert ignore，保证这条数据不会因为重复而失败。</p>
<h3 id="3-3-为什么外键那么特殊"><a href="#3-3-为什么外键那么特殊" class="headerlink" title="3.3 为什么外键那么特殊"></a>3.3 为什么外键那么特殊</h3><p>假设 <em>t1</em> 是要修改的表，<em>t2</em> 有外键依赖于 <em>t1</em>，<em>_t1_new</em> 是 alter <em>t1</em> 产生的新临时表。<br>这里的外键不是看t1上是否存在外键，而是作为子表的 t2。主要问题在 rename t1 时，t1“不存在”导致t2的外键认为参考失败，不允许rename。<br>pt-osc提供<code>--alter-foreign-keys-method</code>选项来决定怎么处理这种情况：</p>
<ul>
<li><code>rebuild_constraints</code>，优先采用这种方式<ul>
<li>它先通过 <em>alter table t2 drop fk1,add _fk1</em> 重建外键参考，指向新表 </li>
<li>再 <em>rename t1 t1_old, _t1_new t1</em> ，交换表名，不影响客户端</li>
<li>删除旧表 t1_old<br>但如果字表t2太大，以致alter操作可能耗时过长，有可能会强制选择 drop_swap。<br>涉及的主要方法在 <code>pt-online-schema-change</code> 文件的 <em>determine_alter_fk_method</em>, <em>rebuild_constraints</em>, <em>swap_tables</em>三个函数中。</li>
</ul>
</li>
<li><code>drop_swap</code>，<ul>
<li>禁用t2表外键约束检查 <code>FOREIGN_KEY_CHECKS=0</code></li>
<li>然后 drop t1 原表</li>
<li>再 <em>rename _t1_new t1</em><br>这种方式速度更快，也不会阻塞请求。但有风险，第一，drop表的瞬间到rename过程，原表t1是不存在的，遇到请求会报错；第二，如果因为bug或某种原因，旧表已删，新表rename失败，那就太晚了，但这种情况很少见。<br>我们的开发规范决定，即使表间存在外键参考关系，也不通过表定义强制约束。</li>
</ul>
</li>
</ul>
<h3 id="3-4-在使用之前需要对磁盘容量进行评估"><a href="#3-4-在使用之前需要对磁盘容量进行评估" class="headerlink" title="3.4 在使用之前需要对磁盘容量进行评估"></a>3.4 在使用之前需要对磁盘容量进行评估</h3><p>使用OSC会使增加一倍的空间，包括索引<br>而且在 Row Based Replication 下，还会写一份binlog。不要想当然使用<code>--set-vars</code>去设置 sql_log_bin=0，因为在这个session级别，alter语句也要在从库上执行，除非你对从库另有打算。</p>
<h2 id="4-使用-pt-osc原生-5-6-online-ddl相比，如何选择"><a href="#4-使用-pt-osc原生-5-6-online-ddl相比，如何选择" class="headerlink" title="4. 使用 pt-osc原生 5.6 online ddl相比，如何选择"></a>4. 使用 pt-osc原生 5.6 online ddl相比，如何选择</h2><ul>
<li>online ddl在必须copy table时成本较高，不宜采用</li>
<li>pt-osc工具在存在触发器时，不适用</li>
<li>修改索引、外键、列名时，优先采用online ddl，并指定 ALGORITHM=INPLACE</li>
<li>其它情况使用pt-osc，虽然存在copy data</li>
<li>pt-osc比online ddl要慢一倍左右，因为它是根据负载调整的</li>
<li>无论哪种方式都选择的业务低峰期执行</li>
<li>特殊情况需要利用主从特性，先alter从库，主备切换，再改原主库</li>
</ul>
<p>借助percona博客一张图说明一下：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/DDLFlow1.png" alt="DDL flow"></p>
<h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h2><ul>
<li><p><strong>添加新列</strong><br>完整输出过程</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">[root@ssd-<span class="number">34</span> sysbench]# pt-online-schema-change --user=user --password=password --host=<span class="number">10.0</span>.<span class="number">201.34</span>  --alter <span class="string">"ADD COLUMN f_id int default 0"</span> D=confluence,t=sbtest3 --print --execute</div><div class="line">No slaves found.  See --recursion-method <span class="keyword">if</span> host ssd-<span class="number">34</span> has slaves.</div><div class="line"><span class="literal">Not</span> checking slave lag because no slaves were found <span class="literal">and</span> --check-slave-lag was <span class="literal">not</span> specified.</div><div class="line"><span class="symbol">Operation, tries, wait:</span></div><div class="line">  analyze_table, <span class="number">10</span>, <span class="number">1</span></div><div class="line">  copy_rows, <span class="number">10</span>, <span class="number">0.25</span></div><div class="line">  create_triggers, <span class="number">10</span>, <span class="number">1</span></div><div class="line">  drop_triggers, <span class="number">10</span>, <span class="number">1</span></div><div class="line">  swap_tables, <span class="number">10</span>, <span class="number">1</span></div><div class="line">  update_foreign_keys, <span class="number">10</span>, <span class="number">1</span></div><div class="line">Altering `confluence`.`sbtest3`...</div><div class="line">Creating new table...         ==&gt; 创建新表</div><div class="line">CREATE TABLE `confluence`.`_sbtest3_new` (</div><div class="line">  `id` int(<span class="number">10</span>) unsigned <span class="literal">NOT</span> NULL AUTO_INCREMENT,</div><div class="line">  `k` int(<span class="number">10</span>) unsigned <span class="literal">NOT</span> NULL DEFAULT '<span class="number">0</span>',</div><div class="line">  `c` char(<span class="number">120</span>) COLLATE utf8_bin <span class="literal">NOT</span> NULL DEFAULT '',</div><div class="line">  `pad` char(<span class="number">60</span>) COLLATE utf8_bin <span class="literal">NOT</span> NULL DEFAULT '',</div><div class="line">  PRIMARY KEY (`id`),</div><div class="line">  KEY `k_3` (`k`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">5000001</span> DEFAULT CHARSET=utf8 COLLATE=utf8_bin MAX_ROWS=<span class="number">1000000</span></div><div class="line">Created new table confluence._sbtest3_new OK.</div><div class="line">Altering new table...         ==&gt; 使用ddl修改新表结构</div><div class="line">ALTER TABLE `confluence`.`_sbtest3_new` ADD COLUMN f_id int default <span class="number">0</span></div><div class="line">Altered `confluence`.`_sbtest3_new` OK.</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">54</span>:<span class="number">23</span> Creating triggers...   ==&gt; 在旧表上创建<span class="number">3</span>个触发器</div><div class="line">CREATE TRIGGER `pt_osc_confluence_sbtest3_del` AFTER DELETE ON `confluence`.`sbtest3` FOR EACH ROW </div><div class="line">    DELETE IGNORE FROM `confluence`.`_sbtest3_new` WHERE `confluence`.`_sbtest3_new`.`id` &lt;=&gt; OLD.`id`</div><div class="line">CREATE TRIGGER `pt_osc_confluence_sbtest3_upd` AFTER UPDATE ON `confluence`.`sbtest3` FOR EACH ROW </div><div class="line">    REPLACE INTO `confluence`.`_sbtest3_new` (`id`, `k`, `c`, `pad`) VALUES (NEW.`id`, NEW.`k`, NEW.`c`, NEW.`pad`)</div><div class="line">CREATE TRIGGER `pt_osc_confluence_sbtest3_ins` AFTER INSERT ON `confluence`.`sbtest3` FOR EACH ROW </div><div class="line">    REPLACE INTO `confluence`.`_sbtest3_new` (`id`, `k`, `c`, `pad`) VALUES (NEW.`id`, NEW.`k`, NEW.`c`, NEW.`pad`)</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">54</span>:<span class="number">23</span> Created triggers OK.</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">54</span>:<span class="number">23</span> Copying approximately <span class="number">4485573</span> rows...  ==&gt; 分块拷贝数据到新表</div><div class="line">INSERT LOW_PRIORITY IGNORE INTO `confluence`.`_sbtest3_new` (`id`, `k`, `c`, `pad`) </div><div class="line">  SELECT `id`, `k`, `c`, `pad` FROM `confluence`.`sbtest3` FORCE INDEX(`PRIMARY`) WHERE ((`id` &gt;= ?)) <span class="literal">AND</span> ((`id` &lt;= ?)) </div><div class="line">  LOCK IN SHARE MODE /*pt-online-schema-change <span class="number">44155</span> copy nibble*/</div><div class="line">SELECT /*!<span class="number">40001</span> SQL_NO_CACHE */ `id` FROM `confluence`.`sbtest3` FORCE INDEX(`PRIMARY`) WHERE ((`id` &gt;= ?)) ORDER BY `id` LIMIT ?, <span class="number">2</span> /*next chunk boundary*/</div><div class="line"><span class="symbol">Copying `confluence`.`sbtest3`:  36% 00:</span><span class="number">52</span> remain</div><div class="line"><span class="symbol">Copying `confluence`.`sbtest3`:  69% 00:</span><span class="number">26</span> remain</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">01</span> Copied rows OK.</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">01</span> Analyzing new table...</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">01</span> Swapping tables...  ==&gt; 交换新旧表</div><div class="line">RENAME TABLE `confluence`.`sbtest3` TO `confluence`.`_sbtest3_old`, `confluence`.`_sbtest3_new` TO `confluence`.`sbtest3`</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">01</span> Swapped original <span class="literal">and</span> new tables OK.</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">01</span> Dropping old table...  ==&gt; 删除旧表</div><div class="line">DROP TABLE <span class="keyword">IF</span> EXISTS `confluence`.`_sbtest3_old`</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">02</span> Dropped old table `confluence`.`_sbtest3_old` OK.</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">02</span> Dropping triggers...</div><div class="line">DROP TRIGGER <span class="keyword">IF</span> EXISTS `confluence`.`pt_osc_confluence_sbtest3_del`;</div><div class="line">DROP TRIGGER <span class="keyword">IF</span> EXISTS `confluence`.`pt_osc_confluence_sbtest3_upd`;</div><div class="line">DROP TRIGGER <span class="keyword">IF</span> EXISTS `confluence`.`pt_osc_confluence_sbtest3_ins`;</div><div class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">24</span>T20:<span class="number">56</span>:<span class="number">02</span> Dropped triggers OK.</div><div class="line">Successfully altered `confluence`.`sbtest3`.</div></pre></td></tr></table></figure>
</li>
<li><p><strong>修改列类型</strong></p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pt-online-schema-change h=10.0.201.34,P=3306,u=jacky,p=xxx,D=confluence,t=sbtest3 \</div><div class="line">-<span class="ruby">-alter <span class="string">"CHANGE pad f_pad varchar(60) NOT NULL DEFAULT '' "</span> \</span></div><div class="line">-<span class="ruby">-print --dry-run</span></div><div class="line"></div><div class="line">pt-online-schema-change -ujacky -p xxx -h "10.0.201.34" D=confluence,t=sbtest3 \</div><div class="line">-<span class="ruby">-alter <span class="string">"CHANGE pad f_pad varchar(60) NOT NULL DEFAULT '' "</span> \</span></div><div class="line">-<span class="ruby">-execute</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>添加删除索引</strong><br>放后台执行</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">pt</span><span class="literal">-</span><span class="comment">online</span><span class="literal">-</span><span class="comment">schema</span><span class="literal">-</span><span class="comment">change</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">user=user</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ask</span><span class="literal">-</span><span class="comment">pass</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">host=10</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">201</span><span class="string">.</span><span class="comment">34</span>  <span class="comment">\</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="comment">alter</span> <span class="comment">"DROP</span> <span class="comment">KEY</span> <span class="comment">cid</span><span class="string">,</span> <span class="comment">ADD</span> <span class="comment">KEY</span> <span class="comment">idx_corpid_userid(f_corp_id</span><span class="string">,</span><span class="comment">f_user_id)</span> <span class="comment">"</span> <span class="comment">\</span></div><div class="line"><span class="comment">D=confluence</span><span class="string">,</span><span class="comment">t=sbtest3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">print</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">execute</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>修改主键</strong></p>
</li>
</ul>
<p>在我的环境里有不少表设计之初没有自增id，而是采用复合主键，pt-osc 对删除、添加主键会特殊处理，详见 <a href="http://seanlook/2016/05/27/mysql-pt-osc-add-primarykey" target="_blank" rel="external">这里</a>。</p>
<h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6. 错误处理"></a>6. 错误处理</h2><p><strong>1. 存在trigger </strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zx@mysql-5 ~]$ pt-online-schema-<span class="keyword">change</span>  -u <span class="keyword">user</span> -p <span class="keyword">password</span> -h <span class="number">10.0</span><span class="number">.200</span><span class="number">.195</span> \</div><div class="line"><span class="comment">--alter="MODIFY COLUMN f_receiver  varchar(128)                                                      NOT NULL DEFAULT '' AFTER f_user_id" --dry-run D=db_name,t=table_name</span></div><div class="line">The <span class="keyword">table</span> <span class="string">`db_name`</span>.<span class="string">`table_name`</span> has triggers.  This tool needs <span class="keyword">to</span> <span class="keyword">create</span> its own <span class="keyword">triggers</span>, so the <span class="keyword">table</span> cannot already have triggers.</div></pre></td></tr></table></figure></p>
<p>表上存在触发器，不适用。</p>
<p><strong>2. no-version-check  </strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pt-online-schema-change -uuser -ppassword --alter <span class="string">"add key id_provice(f_provice)"</span> \</div><div class="line"><span class="keyword">D</span>=db_name,t=tb_name -<span class="keyword">h</span> rdsxxxxxx.mysql.rds.aliyuncs.com</div><div class="line">Can't <span class="keyword">use</span> <span class="keyword">an</span> undefined value <span class="keyword">as</span> <span class="keyword">an</span> ARRAY reference at /usr/bin/pt-online-schema-change <span class="keyword">line</span> 7335.</div></pre></td></tr></table></figure></p>
<p>这个错误在阿里云RDS上执行时出现的，我以为是我哪里语法写错了，但拿到原生5.6的版本上就没问题了，加上<code>--no-version-check</code>选项就好了，见 <a href="https://help.aliyun.com/knowledge_detail/13098164.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/13098164.html</a> ，没深究，应该是pt去验证mysql server版本的时候从rds拿到的信息不对，导致格式出错。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html" target="_blank" rel="external">refman pt-online-schema-change</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/13098164.html" target="_blank" rel="external">RDS MySQL 如何使用 Percona Toolkit</a></li>
<li><a href="http://www.cnblogs.com/zhoujinyi/p/3491059.html" target="_blank" rel="external">percona-toolkit 之 【pt-online-schema-change】说明</a></li>
<li><a href="https://www.percona.com/blog/2014/11/18/avoiding-mysql-alter-table-downtime/" target="_blank" rel="external">Avoiding MySQL ALTER table downtime</a></li>
<li><a href="http://www.imcjd.com/?p=1081" target="_blank" rel="external">MySQL Online DDL和NoSQL Schemaless Design</a></li>
</ul>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/05/27/mysql-pt-online-schema-change/">http://seanlook.com/2016/05/27/mysql-pt-online-schema-change/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果正在看这篇文章，相信你已经知道自己的需求了。&lt;/p&gt;
&lt;p&gt;在 mysql 5.5 版本以前，修改表结构如添加索引、修改列，需要锁表，期间不能写入，对于大表这简直是灾难。从5.5特别是5.6里，情况有了好转，支持Online DDL，相关介绍见 &lt;a href=&quot;http://seanlook.com/2016/05/24/mysql-online-ddl-concept&quot;&gt;这篇文章&lt;/a&gt;，而我在实际alter table过程中还是会引起 data meta lock 问题。pt-online-schema-change是Percona-toolkit一员，通过改进原生ddl的方式，达到不锁表在线修改表结构。&lt;/p&gt;
&lt;h2 id=&quot;1-pt-osc工作过程&quot;&gt;&lt;a href=&quot;#1-pt-osc工作过程&quot; class=&quot;headerlink&quot; title=&quot;1. pt-osc工作过程&quot;&gt;&lt;/a&gt;1. pt-osc工作过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建一个和要执行 alter 操作的表一样的新的空表结构(是alter之前的结构)&lt;/li&gt;
&lt;li&gt;在新表执行alter table 语句（速度应该很快）&lt;/li&gt;
&lt;li&gt;在原表中创建触发器3个触发器分别对应insert,update,delete操作&lt;/li&gt;
&lt;li&gt;以一定块大小从原表拷贝数据到临时表，拷贝过程中通过原表上的触发器在原表进行的写操作都会更新到新建的临时表&lt;/li&gt;
&lt;li&gt;Rename 原表到old表中，在把临时表Rename为原表&lt;/li&gt;
&lt;li&gt;如果有参考该表的外键，根据alter-foreign-keys-method参数的值，检测外键相关的表，做相应设置的处理&lt;/li&gt;
&lt;li&gt;默认最后将旧原表删除&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-常用选项说明&quot;&gt;&lt;a href=&quot;#2-常用选项说明&quot; class=&quot;headerlink&quot; title=&quot;2. 常用选项说明&quot;&gt;&lt;/a&gt;2. 常用选项说明&lt;/h2&gt;&lt;p&gt;只介绍部分常用的选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--host=xxx --user=xxx --password=xxx&lt;/code&gt;&lt;br&gt;连接实例信息，缩写&lt;code&gt;-h xxx -u xxx -p xxx&lt;/code&gt;，密码可以使用参数&lt;code&gt;--ask-pass&lt;/code&gt; 手动输入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--alter&lt;/code&gt;&lt;br&gt;结构变更语句，不需要 &lt;code&gt;ALTER TABLE&lt;/code&gt;关键字。与原始ddl一样可以指定多个更改，用逗号分隔。&lt;ul&gt;
&lt;li&gt;绝大部分情况下表上需要有主键或唯一索引，因为工具在运行当中为了保证新表也是最新的，需要旧表上创建 DELETE和UPDATE 触发器，同步到新表的时候有主键会更快。个别情况是，当alter操作就是在c1列上建立主键时，DELETE触发器将基于c1列。&lt;/li&gt;
&lt;li&gt;子句不支持 rename 去给表重命名。 &lt;/li&gt;
&lt;li&gt;alter命令原表就不支持给索引重命名，需要先drop再add，在pt-osc也一样。(mysql 5.7 支持 RENAME INDEX old_index_name TO new_index_name)&lt;br&gt;但给字段重命名，千万不要drop-add，整列数据会丢失，使用&lt;code&gt;change col1 col1_new type constraint&lt;/code&gt;（保持类型和约束一致，否则相当于修改 column type，不能online）&lt;/li&gt;
&lt;li&gt;子句如果是add column并且定义了not null，那么必须指定default值，否则会失败。&lt;/li&gt;
&lt;li&gt;如果要删除外键（名 fk_foo），使用工具的时候外键名要加下划线，比如&lt;code&gt;--alter &amp;quot;DROP FOREIGN KEY _fk_foo&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;D=db_name,t=table_name&lt;/code&gt;&lt;br&gt;指定要ddl的数据库名和表名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--max-load&lt;/code&gt;&lt;br&gt;默认为&lt;code&gt;Threads_running=25&lt;/code&gt;。每个chunk拷贝完后，会检查 &lt;em&gt;SHOW GLOBAL STATUS&lt;/em&gt; 的内容，检查指标是否超过了指定的阈值。如果超过，则先暂停。这里可以用逗号分隔，指定多个条件，每个条件格式： &lt;code&gt;status指标=MAX_VALUE&lt;/code&gt;或者&lt;code&gt;status指标:MAX_VALUE&lt;/code&gt;。如果不指定MAX_VALUE，那么工具会这只其为当前值的120%。&lt;br&gt;因为拷贝行有可能会给部分行上锁，Threads_running 是判断当前数据库负载的绝佳指标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--max-lag&lt;/code&gt;&lt;br&gt;默认1s。每个chunk拷贝完成后，会查看所有复制Slave的延迟情况（&lt;code&gt;Seconds_Behind_Master&lt;/code&gt;）。要是延迟大于该值，则暂停复制数据，直到所有从的滞后小于这个值。&lt;code&gt;--check-interval&lt;/code&gt;配合使用，指定出现从库滞后超过 max-lag，则该工具将睡眠多长时间，默认1s，再检查。如&lt;code&gt;--max-lag=5 --check-interval=2&lt;/code&gt;。&lt;br&gt;熟悉percona-toolkit的人都知道&lt;code&gt;--recursion-method&lt;/code&gt;可以用来指定从库dsn记录。另外，如果从库被停止，将会永远等待，直到从开始同步，并且延迟小于该值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--chunk-time&lt;/code&gt;&lt;br&gt;默认0.5s，即拷贝数据行的时候，为了尽量保证0.5s内拷完一个chunk，动态调整chunk-size的大小，以适应服务器性能的变化。&lt;br&gt;也可以通过另外一个选项&lt;code&gt;--chunk-size&lt;/code&gt;禁止动态调整，即每次固定拷贝 1k 行，如果指定则默认1000行，且比 chunk-time 优先生效&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="Percona-toolkit" scheme="http://seanlook.com/tags/Percona-toolkit/"/>
    
  </entry>
  
  <entry>
    <title>mysql 5.6 原生Online DDL解析</title>
    <link href="http://seanlook.com/2016/05/24/mysql-online-ddl-concept/"/>
    <id>http://seanlook.com/2016/05/24/mysql-online-ddl-concept/</id>
    <published>2016-05-24T08:32:49.000Z</published>
    <updated>2016-05-24T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>做MySQL的都知道，数据库操作里面，DDL操作（比如CREATE,DROP,ALTER等）代价是非常高的，特别是在单表上千万的情况下，加个索引或改个列类型，就有可能堵塞整个表的读写。</p>
<p>然后 mysql 5.6 开始，大家期待的Online DDL出现了，可以实现修改表结构的同时，依然允许DML操作(select,insert,update,delete)。在这个特性出现以前，用的比较多的工具是<code>pt-online-schema-change</code>，比较请参考<a href="http://seanlook.com/2016/05/27/mysql-pt-online-schema-change">pt-online-schema-change使用说明、限制与比较</a>或 <a href="http://www.fromdual.ch/online-ddl_vs_pt-online-schema-change" target="_blank" rel="external">ONLINE DDL VS PT-ONLINE-SCHEMA-CHANGE</a> 。</p>
<h2 id="1-Online-DDL"><a href="#1-Online-DDL" class="headerlink" title="1. Online DDL"></a>1. Online DDL</h2><p>在 MySQL 5.1 （带InnoDB Plugin）和5.5中，有个新特性叫 Fast Index Creation（下称 FIC），就是在添加或者删除二级<strong>索引</strong>的时候，可以不用复制原表。对于之前的版本对于索引的添加删除这类DDL操作，MySQL数据库的操作过程为如下：</p>
<ol>
<li>首先新建Temp table，表结构是 ALTAR TABLE 新定义的结构</li>
<li>然后把原表中数据导入到这个Temp table</li>
<li>删除原表</li>
<li>最后把临时表rename为原来的表名</li>
</ol>
<p>为了保持数据的一致性，中间复制数据（Copy Table）全程锁表只读，如果有写请求进来将无法提供服务，连接数爆张。</p>
<p>引入FIC之后，创建二级索引时会对原表加上一个S锁，创建过程不需要重建表（no-rebuild）；删除InnoDB二级索引只需要更新内部视图，并标记这个索引的空间可用，去掉数据库元数据上该索引的定义即可。这个过程也只允许读操作，不能写入，但大大加快了修改索引的速度（不含主键索引，InnoDB IOT的特性决定了修改主键依然需要 Copy Table ）。</p>
<p>FIC只对索引的创建删除有效，MySQL 5.6 Online DDL把这种特性扩展到了添加列、删除列、修改列类型、列重命名、设置默认值等等，实际效果要看所使用的选项和操作类别来定。</p>
<h3 id="1-1-Online-DDL选项"><a href="#1-1-Online-DDL选项" class="headerlink" title="1.1 Online DDL选项"></a>1.1 Online DDL选项</h3><p>MySQL 在线DDL分为 <code>INPLACE</code> 和 <code>COPY</code> 两种方式，通过在ALTER语句的ALGORITHM参数指定。</p>
<ul>
<li><code>ALGORITHM=INPLACE</code>，可以避免重建表带来的IO和CPU消耗，保证ddl期间依然有良好的性能和并发。</li>
<li><code>ALGORITHM=COPY</code>，需要拷贝原始表，所以不允许并发DML写操作，可读。这种copy方式的效率还是不如 inplace ，因为前者需要记录undo和redo log，而且因为临时占用buffer pool引起短时间内性能受影响。</li>
</ul>
<p>上面只是 Online DDL 内部的实现方式，此外还有 LOCK 选项控制是否锁表，根据不同的DDL操作类型有不同的表现：默认mysql尽可能不去锁表，但是像修改主键这样的昂贵操作不得不选择锁表。</p>
<ul>
<li><code>LOCK=NONE</code>，即DDL期间允许并发读写涉及的表，比如为了保证 ALTER TABLE 时不影响用户注册或支付，可以明确指定，好处是如果不幸该 alter语句不支持对该表的继续写入，则会提示失败，而不会直接发到库上执行。<code>ALGORITHM=COPY</code>默认LOCK级别</li>
<li><code>LOCK=SHARED</code>，即DDL期间表上的写操作会被阻塞，但不影响读取。</li>
<li><code>LOCK=DEFAULT</code>，让mysql自己去判断lock的模式，原则是mysql尽可能不去锁表</li>
<li><code>LOCK=EXCLUSIVE</code>，即DDL期间该表不可用，堵塞任何读写请求。如果你想alter操作在最短的时间内完成，或者表短时间内不可用能接受，可以手动指定。</li>
</ul>
<p>但是有一点需要说明，无论任何模式下，online ddl开始之前都需要一个短时间排它锁(exclusive)来准备环境，所以alter命令发出后，会首先等待该表上的其它操作完成，在alter命令之后的请求会出现等待<code>waiting meta data lock</code>。同样在ddl结束之前，也要等待alter期间所有的事务完成，也会堵塞一小段时间。所以尽量在ALTER TABLE之前确保没有大事务在执行，否则一样出现连环锁表。</p>
<h3 id="1-2-考虑不同的DDL操作类别"><a href="#1-2-考虑不同的DDL操作类别" class="headerlink" title="1.2 考虑不同的DDL操作类别"></a>1.2 考虑不同的DDL操作类别</h3><p>从上面的介绍可以看出，不是5.6支持在线ddl就可以随心所欲的alter table，锁不锁表要看情况：</p>
<a id="more"></a>
<p>提示：下表根据官方 <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html" target="_blank" rel="external">Summary of Online Status for DDL Operations</a> 整理挑选的常用操作。</p>
<ul>
<li><em>In-Place</em> 为Yes是优选项，说明该操作支持INPLACE</li>
<li><em>Copies Table</em> 为No是优选项，因为为Yes需要重建表。大部分情况与In-Place是相反的</li>
<li><em>Allows Concurrent DML?</em> 为Yes是优选项，说明ddl期间表依然可读写，可以指定 LOCK=NONE（如果操作允许的话mysql自动就是NONE）</li>
<li><em>Allows Concurrent Query?</em> 默认所有DDL操作期间都允许查询请求，放在这只是便于参考</li>
<li><em>Notes</em> 会对前面几列Yes/No带 * 号的限制说明</li>
</ul>
<table>
<thead>
<tr>
<th>Operation</th>
<th>In-Place?</th>
<th>Copies Table?</th>
<th>Allows Concurrent DML?</th>
<th>Allows Concurrent Query?</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加索引</td>
<td>Yes*</td>
<td>No*</td>
<td>Yes</td>
<td>Yes</td>
<td>对全文索引的一些限制</td>
</tr>
<tr>
<td>删除索引</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>仅修改表的元数据</td>
</tr>
<tr>
<td>OPTIMIZE TABLE</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>从 5.6.17开始使用ALGORITHM=INPLACE，当然如果指定了<code>old_alter_table=1</code>或mysqld启动带<code>--skip-new</code>则将还是COPY模式。如果表上有全文索引只支持COPY</td>
</tr>
<tr>
<td>对一列设置默认值</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>仅修改表的元数据</td>
</tr>
<tr>
<td>对一列修改auto-increment 的值</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>仅修改表的元数据</td>
</tr>
<tr>
<td>添加 foreign key constraint</td>
<td>Yes*</td>
<td>No*</td>
<td>Yes</td>
<td>Yes</td>
<td>为了避免拷贝表，在约束创建时会禁用foreign_key_checks</td>
</tr>
<tr>
<td>删除 foreign key constraint</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>foreign_key_checks 不影响</td>
</tr>
<tr>
<td>改变列名</td>
<td>Yes*</td>
<td>No*</td>
<td>Yes*</td>
<td>Yes</td>
<td>为了允许DML并发, 如果保持相同数据类型，仅改变列名</td>
</tr>
<tr>
<td>添加列</td>
<td>Yes*</td>
<td>Yes*</td>
<td>Yes*</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作。当添加列是auto-increment，不允许DML并发</td>
</tr>
<tr>
<td>删除列</td>
<td>Yes</td>
<td>Yes*</td>
<td>Yes</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
</tr>
<tr>
<td>修改列数据类型</td>
<td>No</td>
<td>Yes*</td>
<td>No</td>
<td>Yes</td>
<td>修改类型或添加长度，都会拷贝表，而且不允许更新操作</td>
</tr>
<tr>
<td>更改列顺序</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
</tr>
<tr>
<td>修改ROW_FORMAT <br> 和KEY_BLOCK_SIZE</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
</tr>
<tr>
<td>设置列属性NULL<br>或NOT NULL</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
</tr>
<tr>
<td>添加主键</td>
<td>Yes*</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作。<br> 如果列定义必须转化NOT NULL，则不允许INPLACE</td>
</tr>
<tr>
<td>删除并添加主键</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>在同一个 ALTER TABLE 语句删除就主键、添加新主键时，才允许inplace；数据大幅重组,所以它仍然是一项昂贵的操作。</td>
</tr>
<tr>
<td>删除主键</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>不允许并发DML，要拷贝表，而且如果没有在同一 ATLER TABLE 语句里同时添加主键则会收到限制</td>
</tr>
<tr>
<td>变更表字符集</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>如果新的字符集编码不同，重建表</td>
</tr>
</tbody>
</table>
<p>从表看出，In-Place为No，DML一定是No，说明 <code>ALGORITHM=COPY</code> 一定会发生拷贝表，只读。但 <code>ALGORITHM=INPLACEE</code> 也要可能发生拷贝表，但可以并发DML:</p>
<ul>
<li>添加、删除列，改变列顺序</li>
<li>添加或删除主键</li>
<li>改变行格式ROW_FORMAT和压缩块大小KEY_BLOCK_SIZE</li>
<li>改变列NULL或NOT NULL</li>
<li>优化表OPTIMIZE TABLE</li>
<li>强制 rebuild 该表</li>
</ul>
<p>不允许并发DML的情况有：修改列数据类型、删除主键、变更表字符集，即这些类型操作ddl是不能online的。</p>
<p>另外，更改主键索引与普通索引处理方式是不一样的，主键即聚集索引，体现了表数据在物理磁盘上的排列，包含了数据行本身，需要拷贝表；而普通索引通过包含主键列来定位数据，所以普通索引的创建只需要一次扫描主键即可，而且是在已有数据的表上建立二级索引，更紧凑，将来查询效率更高。</p>
<p>修改主键也就意味着要重建所有的普通索引。删除二级索引更简单，修改InnoDB系统表信息和数据字典，标记该所以不存在，标记所占用的表空间可以被新索引或数据行重新利用。</p>
<h3 id="1-3-在线DDL的限制"><a href="#1-3-在线DDL的限制" class="headerlink" title="1.3 在线DDL的限制"></a>1.3 在线DDL的限制</h3><ul>
<li>在alter table时，如果涉及到table copy操作，要确保 <code>datadir</code> 目录有足够的磁盘空间，能够放的下整张表，因为拷贝表的的操作是直接在数据目录下进行的。</li>
<li>添加索引无需table copy，但要确保 <code>tmpdir</code> 目录足够存下索引一列的数据（如果是组合索引，当前临时排序文件一合并到原表上就会删除）</li>
<li>在主从环境下，主库执行alter命令在完成之前是不会进入binlog记录事件，如果允许dml操作则不影响记录时间，所以期间不会导致延迟。然而，由于从库是单个SQL Thread按顺序应用relay log，轮到ALTER语句时直到执行完才能下一条，所以从库会在master ddl完成后开始产生延迟。（pt-osc可以控制延迟时间，所以这种场景下它更合适）</li>
<li>During each online DDL ALTER TABLE statement, regardless of the LOCK clause, there are brief periods at the beginning and end requiring an exclusive lock on the table (the same kind of lock specified by the LOCK=EXCLUSIVE clause). Thus, an online DDL operation might wait before starting if there is a long-running transaction performing inserts, updates, deletes, or SELECT … FOR UPDATE on that table; and an online DDL operation might wait before finishing if a similar long-running transaction was started while the ALTER TABLE was in progress.</li>
<li>在执行一个允许并发DML在线 ALTER TABLE时，结束之前这个线程会应用 <em>online log</em> 记录的增量修改，而这些修改是其它thread里产生的，所以有可能会遇到重复键值错误 <em>(ERROR 1062 (23000): Duplicate entry)</em>。</li>
<li>涉及到table copy时，目前还没有机制限制暂停ddl，或者限制IO阀值<br>在MySQL 5.7.6开始能够通过 performance_schema 观察alter table的进度</li>
<li>一般来说，建议把多个alter语句合并在一起进行，避免多次table rebuild带来的消耗。但是也要注意分组，比如需要copy table和只需inplace就能完成的，应该分两个alter语句。</li>
<li>如果DDL执行时间很长，期间又产生了大量的dml操作，以至于超过了 <code>innodb_online_alter_log_max_size</code> 变量所指定的大小，会引起 <em>DB_ONLINE_LOG_TOO_BIG</em> 错误。默认为 128M，特别对于需要拷贝大表的alter操作，考虑临时加大该值，以此获得更大的日志缓存空间</li>
<li>执行完 <code>ALTER TABLE</code> 之后，最好 <code>ANALYZE TABLE tb1</code> 去更新索引统计信息</li>
</ul>
<h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2. 实现过程"></a>2. 实现过程</h2><p>online ddl主要包括3个阶段，prepare阶段，ddl执行阶段，commit阶段，rebuild方式比no-rebuild方式实质多了一个ddl执行阶段，prepare阶段和commit阶段类似。下面将主要介绍ddl执行过程中三个阶段的流程。</p>
<ul>
<li><p><strong> Prepare阶段 </strong> :  </p>
<ol>
<li>创建新的临时frm文件(与InnoDB无关)</li>
<li>持有EXCLUSIVE-MDL锁，禁止读写</li>
<li>根据alter类型，确定执行方式(copy,online-rebuild,online-norebuild)<br>假如是Add Index，则选择online-norebuild即INPLACE方式</li>
<li>更新数据字典的内存对象</li>
<li>分配row_log对象记录增量(仅rebuild类型需要)</li>
<li>生成新的临时ibd文件(仅rebuild类型需要)</li>
</ol>
</li>
<li><p><strong> ddl执行阶段 </strong> :  </p>
<ol>
<li>降级EXCLUSIVE-MDL锁，允许读写</li>
<li>扫描old_table的聚集索引每一条记录rec</li>
<li>遍历新表的聚集索引和二级索引，逐一处理</li>
<li>根据rec构造对应的索引项</li>
<li>将构造索引项插入sort_buffer块排序</li>
<li>将sort_buffer块更新到新的索引上</li>
<li>记录ddl执行过程中产生的增量(仅rebuild类型需要)</li>
<li>重放row_log中的操作到新索引上(no-rebuild数据是在原表上更新的)</li>
<li>重放row_log间产生dml操作append到row_log最后一个Block</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong> commit阶段 </strong> :  </p>
<ol>
<li>当前Block为row_log最后一个时，禁止读写，升级到EXCLUSIVE-MDL锁</li>
<li>重做row_log中最后一部分增量</li>
<li>更新innodb的数据字典表</li>
<li>提交事务(刷事务的redo日志)</li>
<li>修改统计信息</li>
<li>rename临时idb文件，frm文件</li>
<li>变更完成</li>
</ol>
</li>
</ul>
<p>这有一直导图挺直观的：<a href="http://blog.itpub.net/22664653/viewspace-2056953" target="_blank" rel="external">http://blog.itpub.net/22664653/viewspace-2056953</a> 。<br><strong>添加列</strong> 时由于需要copy table，row_log会重放到新表上（临时ibd文件），直到最后一个block，锁住原表禁止更新。</p>
<p>row_log记录了ddl变更过程中新产生的dml操作，并在ddl执行的最后将其应用到新的表中，保证数据完整性</p>
<h2 id="3-对比实验"><a href="#3-对比实验" class="headerlink" title="3. 对比实验"></a>3. 对比实验</h2><h3 id="3-1-添加二级索引"><a href="#3-1-添加二级索引" class="headerlink" title="3.1 添加二级索引"></a>3.1 添加二级索引</h3><p>我这里使用sysbench产生的表测试（500w数据）：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; select version();</span></div><div class="line">+------------+</div><div class="line"><span class="section">| version()  |</span></div><div class="line">+------------+</div><div class="line"><span class="section">| 5.6.30-log |</span></div><div class="line">+------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; show create table sbtest1;</div><div class="line">CREATE TABLE <span class="code">`sbtest1`</span> (</div><div class="line"><span class="code">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></div><div class="line"><span class="code">  `k` int(10) unsigned NOT NULL DEFAULT '0',</span></div><div class="line"><span class="code">  `c` char(120) COLLATE utf8_bin NOT NULL DEFAULT '',</span></div><div class="line"><span class="code">  `pad` char(60) COLLATE utf8_bin NOT NULL DEFAULT '',</span></div><div class="line"><span class="code">  PRIMARY KEY (`id`),</span></div><div class="line"><span class="code">  KEY `k_1` (`k`)</span></div><div class="line">) ENGINE=InnoDB AUTO<span class="emphasis">_INCREMENT=5000001 DEFAULT CHARSET=utf8 COLLATE=utf8_</span>bin MAX<span class="emphasis">_ROWS=1000000</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="section">mysql&gt; show variables like "old_alter_table";</span></div><div class="line">+-----------------+-------+</div><div class="line"><span class="section">| Variable_name   | Value |</span></div><div class="line">+-----------------+-------+</div><div class="line"><span class="section">| old_alter_table | OFF   |</span></div><div class="line">+-----------------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p><strong> 旧模式 </strong> 下，创建删除普通索引：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">*<span class="strong">*SESSION1:*</span>*</div><div class="line">mysql&gt; set old<span class="emphasis">_alter_</span>table=1;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; alter table sbtest1 drop index idx<span class="emphasis">_k_</span>1;</div><div class="line">Query OK, 5000000 rows affected (44.79 sec)</div><div class="line">Records: 5000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; alter table sbtest1 add index idx<span class="emphasis">_k_</span>1(k);</div><div class="line">Query OK, 5000000 rows affected (1 min 11.29 sec)</div><div class="line">Records: 5000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line"></div><div class="line">*<span class="strong">*SESSION2:*</span>*</div><div class="line"><span class="section">mysql&gt; select * from sbtest1 limit 1;</span></div><div class="line">+----+---------+-------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+</div><div class="line"><span class="section">| id | k       | c                                                                                                                       | pad                                                         |</span></div><div class="line">+----+---------+-------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+</div><div class="line"><span class="section">|  1 | 2481886 | 08566691963-88624...106334-50535565977 | 63188288836-9235114...351-49282961843 |</span></div><div class="line">+----+---------+-------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; update sbtest1 set k=2481885 where id=1;</div><div class="line">Query OK, 1 row affected (45.16 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line"></div><div class="line"></div><div class="line">*<span class="strong">*SESSION3:*</span>*</div><div class="line"><span class="section">mysql&gt; show processlist;</span></div><div class="line">+--------+-----------------+-----------+------------+---------+--------+---------------------------------+-----------------------------------------+</div><div class="line"><span class="section">| Id     | User            | Host      | db         | Command | Time   | State                           | Info                                    |</span></div><div class="line">+--------+-----------------+-----------+------------+---------+--------+---------------------------------+-----------------------------------------+</div><div class="line">| 118652 | root            | localhost | confluence | Query   |     19 | copy to tmp table               | alter table sbtest1 add index k<span class="emphasis">_1(k)    |</span></div><div class="line">| 118666 | root            | localhost | confluence | Query   |      3 | Waiting for table metadata lock | update sbtest1 set k=2481885 where id=1 |</div><div class="line">| 118847 | root            | localhost | NULL       | Query   |      0 | init                            | show processlist                        |</div><div class="line">+--------+-----------------+-----------+------------+---------+--------+---------------------------------+-----------------------------------------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line"></div><div class="line">同时在datadir目录下可以看到</div><div class="line">-rw-rw---- 1 mysql mysql 8.5K May 23 21:24 sbtest1.frm</div><div class="line">-rw-rw---- 1 mysql mysql 1.2G May 23 21:24 sbtest1.ibd</div><div class="line">-rw-rw---- 1 mysql mysql 8.5K May 23 20:48 #sql-1c6a<span class="emphasis">_1cf7c.frm</span></div><div class="line">-rw-rw---- 1 mysql mysql 638M May 23 20:48 #sql-1c6a_1cf7c.ibd</div></pre></td></tr></table></figure></p>
<p>传统ddl方式有 <em>copy to tmp table</em> 过程，dml更新操作期间被堵住45s：<code>Waiting for table metadata lock</code>。</p>
<p>下面改成 <strong>Online DDL方式</strong><br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">**SESSION1**</div><div class="line">mysql&gt; <span class="built_in">set</span> old_alter_table=<span class="number">0</span>;</div><div class="line"></div><div class="line">mysql&gt; alter table sbtest1 drop index k_1;</div><div class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.01</span> sec)</div><div class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line">索引秒删</div><div class="line"></div><div class="line">mysql&gt; alter table sbtest1 add index k_1(k);</div><div class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">13.99</span> sec)</div><div class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line">**SESSION2**</div><div class="line">mysql&gt; update sbtest1 <span class="built_in">set</span> k=<span class="number">2481887</span> <span class="keyword">where</span> id=<span class="number">1</span>;</div><div class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.00</span> sec)</div><div class="line">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line">**SESSION3**</div><div class="line">mysql&gt; show processlist;</div><div class="line">+--------+-----------------+-----------+------------+---------+--------+------------------------+--------------------------------------+</div><div class="line">| <span class="type">Id</span>     | <span class="type">User</span>            | <span class="type">Host</span>      | <span class="type">db</span>         | <span class="type">Command</span> | <span class="type">Time</span>   | <span class="type">State</span>                  | <span class="type">Info</span>                                 |</div><div class="line"><span class="type">+--------+-----------------+-----------+------------+---------+--------+------------------------+--------------------------------------+</span></div><div class="line">| 118652 | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |     <span class="type">10</span> | <span class="type">altering</span> table         | <span class="type">alter</span> table sbtest1 add index k_1(k) |</div><div class="line"><span class="type">| 118666</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Sleep</span>   |      <span class="type">9</span> |                        <span class="type">| NULL</span>                                 |</div><div class="line"><span class="type">| 118847</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">NULL</span>       | <span class="type">Query</span>   |      <span class="type">0</span> | <span class="type">init</span>                   | <span class="type">show</span> processlist                     |</div><div class="line"><span class="type">+--------+-----------------+-----------+------------+---------+--------+------------------------+--------------------------------------+</span></div><div class="line">4 rows <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p>
<p>添加普通索引，并未出现阻塞update操作，而且速度更快。从 rows affected 可以看出有没有copy table。</p>
<p>但如果在alter之前有大事务在执行，<strong> 会阻塞 </strong> ddl以及后续的所有请求：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">**SESSION1**</div><div class="line">mysql&gt; select * from sbtest1 <span class="keyword">where</span> c='long select <span class="built_in">before</span> alter';</div><div class="line">Empty <span class="built_in">set</span> (<span class="number">4.36</span> sec)</div><div class="line"></div><div class="line">**SESSION2**</div><div class="line">mysql&gt; alter table sbtest1 add index k_1(k);</div><div class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">16.28</span> sec)</div><div class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line">**SESSION3**</div><div class="line">mysql&gt; select * from sbtest1 <span class="keyword">where</span> c='long select <span class="built_in">after</span> alter execution but not complete';</div><div class="line">Empty <span class="built_in">set</span> (<span class="number">5.89</span> sec)</div><div class="line"></div><div class="line">**SESSION4**</div><div class="line">mysql&gt; show processlist;</div><div class="line">+----+-----------------+-----------+------------+---------+------+---------------------------------+------------------------------------------------------------------------------------+</div><div class="line">| <span class="type">Id</span> | <span class="type">User</span>            | <span class="type">Host</span>      | <span class="type">db</span>         | <span class="type">Command</span> | <span class="type">Time</span> | <span class="type">State</span>                           | <span class="type">Info</span>                                                                               |</div><div class="line"><span class="type">+----+-----------------+-----------+------------+---------+------+---------------------------------+------------------------------------------------------------------------------------+</span></div><div class="line">|  5 | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">3</span> | <span class="type">Sending</span> data                    | <span class="type">select</span> * from sbtest1 <span class="keyword">where</span> c='long select <span class="built_in">before</span> alter'                           |</div><div class="line"><span class="type">|  7</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">NULL</span>       | <span class="type">Query</span>   |    <span class="type">0</span> | <span class="type">init</span>                            | <span class="type">show</span> processlist                                                                   |</div><div class="line"><span class="type">| 13</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">2</span> | <span class="type">Waiting</span> <span class="keyword">for</span> table metadata lock | <span class="type">alter</span> table sbtest1 add index k_1(k)                                               |</div><div class="line"><span class="type">| 14</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">1</span> | <span class="type">Waiting</span> <span class="keyword">for</span> table metadata lock | <span class="type">select</span> * from sbtest1 <span class="keyword">where</span> c='long select <span class="built_in">after</span> alter execution but not complete' |</div><div class="line"><span class="type">+----+-----------------+-----------+------------+---------+------+---------------------------------+------------------------------------------------------------------------------------+</span></div><div class="line">5 rows <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure>
<h3 id="3-2-添加列示例"><a href="#3-2-添加列示例" class="headerlink" title="3.2 添加列示例"></a>3.2 添加列示例</h3><p>添加新列是ddl操作里面相对较多的一类操作。从上文表中可以看到<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">**SESSION1**</div><div class="line">mysql&gt; ALTER TABLE `sbtest2` \</div><div class="line">       ADD COLUMN `f_new_col1` int(<span class="number">11</span>) NULL DEFAULT <span class="number">0</span>, \</div><div class="line">       ADD COLUMN `f_new_col2` varchar(<span class="number">32</span>) NULL DEFAULT '' AFTER `f_new_col1`;</div><div class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">1</span> min <span class="number">57.86</span> sec)</div><div class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line">**SESSION2**</div><div class="line">mysql&gt; update sbtest2 <span class="built_in">set</span> c=<span class="string">"update when add colomun ddl start"</span> <span class="keyword">where</span> c='<span class="number">33333</span>';</div><div class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">4.41</span> sec)</div><div class="line">Rows matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></div><div class="line"></div><div class="line">**SESSION3**</div><div class="line">mysql&gt; select * from sbtest2 <span class="keyword">where</span> c='select when add colomun ddl start';</div><div class="line">Empty <span class="built_in">set</span> (<span class="number">3.44</span> sec)</div><div class="line"></div><div class="line">**SESSION4**</div><div class="line">mysql&gt; show processlist;</div><div class="line">+-----+-----------------+-----------+------------+---------+------+---------------------------+------------------------------------------------------------------------------------------------------+</div><div class="line">| <span class="type">Id</span>  | <span class="type">User</span>            | <span class="type">Host</span>      | <span class="type">db</span>         | <span class="type">Command</span> | <span class="type">Time</span> | <span class="type">State</span>                     | <span class="type">Info</span>                                                                                                 |</div><div class="line"><span class="type">+-----+-----------------+-----------+------------+---------+------+---------------------------+------------------------------------------------------------------------------------------------------+</span></div><div class="line">|   5 | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">4</span> | <span class="type">altering</span> table            | <span class="type">ALTER</span> TABLE `sbtest2`  ADD COLUMN `f_new_col1` int(<span class="number">11</span>) NULL DEFAULT <span class="number">0</span>, ADD COLUMN `f_new_col2` varch |</div><div class="line"><span class="type">|   7</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">NULL</span>       | <span class="type">Query</span>   |    <span class="type">0</span> | <span class="type">init</span>                      | <span class="type">show</span> processlist                                                                                     |</div><div class="line"><span class="type">| 161</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">2</span> | <span class="type">Searching</span> rows <span class="keyword">for</span> update | <span class="type">update</span> sbtest2 <span class="built_in">set</span> c=<span class="string">"update when add colomun ddl start"</span> <span class="keyword">where</span> c='<span class="number">33333</span>'                             |</div><div class="line"><span class="type">| 187</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">1</span> | <span class="type">Sending</span> data              | <span class="type">select</span> * from sbtest2 <span class="keyword">where</span> c='select when add colomun ddl start'                                    |</div><div class="line"><span class="type">+-----+-----------------+-----------+------------+---------+------+---------------------------+------------------------------------------------------------------------------------------------------+</span></div><div class="line">5 rows <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p>
<p>看到，默认不加 ALGORITHM=INPLACE 就已经允许ddl期间并发DML操作。但是会有一个小临时文件产生：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-rw-rw----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 8<span class="selector-class">.6K</span> <span class="selector-tag">May</span> 23 21<span class="selector-pseudo">:42</span> <span class="selector-id">#sql-7055_5</span><span class="selector-class">.frm</span></div><div class="line"><span class="selector-tag">-rw-rw----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 112<span class="selector-tag">K</span> <span class="selector-tag">May</span> 23 21<span class="selector-pseudo">:42</span> <span class="selector-id">#sql-ib21-16847116</span><span class="selector-class">.ibd</span></div></pre></td></tr></table></figure></p>
<p>当指定copy时，就会锁表了（一般你不想这样做）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`sbtest2`</span></div><div class="line">4DROIP <span class="keyword">COLUMN</span> <span class="string">`f_new_col1`</span>, algorithm=copy;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-修改字段类型"><a href="#3-3-修改字段类型" class="headerlink" title="3.3 修改字段类型"></a>3.3 修改字段类型</h3><p>修改列类型与添加新列不一样，修改类型需要rebuild整个表：<br>(select ok, update waiting)<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">**SESSION1**</div><div class="line">mysql&gt; ALTER TABLE sbtest2</div><div class="line">4   CHANGE f_new_col2 f_new_col2 varchar(<span class="number">50</span>) NULL DEFAULT '', algorithm=inplace ;</div><div class="line">ERROR <span class="number">1846</span> (<span class="number">0</span>A000): ALGORITHM=INPLACE is not supported. Reason: Cannot <span class="built_in">change</span> column type INPLACE. Try ALGORITHM=COPY.</div><div class="line">不支持INPLACE</div><div class="line"></div><div class="line">mysql&gt; ALTER TABLE sbtest2</div><div class="line">4   CHANGE f_new_col2 f_new_col2 varchar(<span class="number">50</span>) NULL DEFAULT '';</div><div class="line"></div><div class="line">**SESSION2**</div><div class="line">mysql&gt; update sbtest2 <span class="built_in">set</span> c=<span class="string">"update when add colomun ddl start"</span> <span class="keyword">where</span> c='<span class="number">33333</span>';</div><div class="line"></div><div class="line">mysql&gt; select * from sbtest2 <span class="keyword">where</span> c='select when add colomun ddl start';</div><div class="line">Empty <span class="built_in">set</span> (<span class="number">3.79</span> sec)</div><div class="line"></div><div class="line">mysql&gt; show processlist;</div><div class="line">+-----+-----------------+-----------+------------+---------+------+---------------------------------+----------------------------------------------------------------------------------+</div><div class="line">| <span class="type">Id</span>  | <span class="type">User</span>            | <span class="type">Host</span>      | <span class="type">db</span>         | <span class="type">Command</span> | <span class="type">Time</span> | <span class="type">State</span>                           | <span class="type">Info</span>                                                                             |</div><div class="line"><span class="type">+-----+-----------------+-----------+------------+---------+------+---------------------------------+----------------------------------------------------------------------------------+</span></div><div class="line">|   5 | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">5</span> | <span class="type">copy</span> to tmp table               | <span class="type">ALTER</span> TABLE sbtest2</div><div class="line">   CHANGE f_new_col2 f_new_col2 varchar(<span class="number">50</span>) NULL DEFAULT '' |</div><div class="line"><span class="type">|   7</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">NULL</span>       | <span class="type">Query</span>   |    <span class="type">0</span> | <span class="type">init</span>                            | <span class="type">show</span> processlist                                                                 |</div><div class="line"><span class="type">| 161</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">4</span> | <span class="type">Waiting</span> <span class="keyword">for</span> table metadata lock | <span class="type">update</span> sbtest2 <span class="built_in">set</span> c=<span class="string">"update when add colomun ddl start"</span> <span class="keyword">where</span> c='<span class="number">33333</span>'         |</div><div class="line"><span class="type">| 187</span> | <span class="type">root</span>            | <span class="type">localhost</span> | <span class="type">confluence</span> | <span class="type">Query</span>   |    <span class="type">3</span> | <span class="type">Sending</span> data                    | <span class="type">select</span> * from sbtest2 <span class="keyword">where</span> c='select when add colomun ddl start'                |</div><div class="line"><span class="type">+-----+-----------------+-----------+------------+---------+------+---------------------------------+----------------------------------------------------------------------------------+</span></div><div class="line">5 rows <span class="built_in">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p>
<h3 id="3-4-Waiting-for-table-metadata-lock"><a href="#3-4-Waiting-for-table-metadata-lock" class="headerlink" title="3.4 Waiting for table metadata lock"></a>3.4 Waiting for table metadata lock</h3><p>Online DDL看起来很美好，实验测试也正如预期，但几次在生产环境修改索引时（5000w的表），还是无法避免出现大量 <em>Waiting for table metadata lock</em> 锁等待，线程数持续增加并告警，导致长达十多分钟不可写。后来发现原来是 5.6.16 版本开始mysql对日期、时间类型的存储格式进行了改动，会导致日期类型的表在升级前后，第一次alter必须rebuild：（<a href="https://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html" target="_blank" rel="external">地址</a>）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">As of MySQL 5.6.16, <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> upgrades <span class="keyword">old</span> temporal <span class="keyword">columns</span> <span class="keyword">to</span> <span class="number">5.6</span> <span class="keyword">format</span> <span class="keyword">for</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span>, <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span>, <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span>, <span class="keyword">ADD</span> <span class="keyword">INDEX</span>, <span class="keyword">and</span> <span class="keyword">FORCE</span> operations.</div><div class="line">Hence, the <span class="keyword">following</span> <span class="keyword">statement</span> upgrades a <span class="keyword">table</span> containing <span class="keyword">columns</span> <span class="keyword">in</span> the <span class="keyword">old</span> <span class="keyword">format</span>:</div><div class="line"></div><div class="line">  <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">FORCE</span>;</div><div class="line"></div><div class="line">This conversion cannot be done using the INPLACE algorithm because the table must be rebuilt,</div><div class="line">so specifying ALGORITHM=INPLACE in these cases results in an error. Specify ALGORITHM=COPY if necessary.</div></pre></td></tr></table></figure></p>
<p>关于 metadata lock 介绍参考云栖 <a href="https://yq.aliyun.com/articles/27667?spm=5176.100240.searchblog.8.StFEGY" target="_blank" rel="external">这系列文章</a>。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li><a href="http://www.cnblogs.com/cchust/p/4639397.html" target="_blank" rel="external">MySQL online ddl原理</a></li>
<li><a href="http://www.cnblogs.com/gomysql/p/3776192.html" target="_blank" rel="external">MySQL 5.6 Online DDL</a></li>
<li><a href="http://mysqllover.com/?p=547" target="_blank" rel="external">[MySQL 5.6] MySQL 5.6 online ddl 使用、测试及关键函数栈</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html" target="_blank" rel="external">MySQL Manual Overview of Online DDL</a></li>
<li><a href="http://hedengcheng.com/?p=405" target="_blank" rel="external">MySQL InnoDB Add Index实现调研(一：Inplace Add Index)</a></li>
<li><a href="http://tencentdba.com/blog/mysql%E5%9C%A8%E7%BA%BF%E5%8A%A0%E5%AD%97%E6%AE%B5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="external">tencentDBA 实现的在线加字段</a></li>
</ul>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/05/24/mysql-online-ddl-concept/">http://seanlook.com/2016/05/24/mysql-online-ddl-concept/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做MySQL的都知道，数据库操作里面，DDL操作（比如CREATE,DROP,ALTER等）代价是非常高的，特别是在单表上千万的情况下，加个索引或改个列类型，就有可能堵塞整个表的读写。&lt;/p&gt;
&lt;p&gt;然后 mysql 5.6 开始，大家期待的Online DDL出现了，可以实现修改表结构的同时，依然允许DML操作(select,insert,update,delete)。在这个特性出现以前，用的比较多的工具是&lt;code&gt;pt-online-schema-change&lt;/code&gt;，比较请参考&lt;a href=&quot;http://seanlook.com/2016/05/27/mysql-pt-online-schema-change&quot;&gt;pt-online-schema-change使用说明、限制与比较&lt;/a&gt;或 &lt;a href=&quot;http://www.fromdual.ch/online-ddl_vs_pt-online-schema-change&quot;&gt;ONLINE DDL VS PT-ONLINE-SCHEMA-CHANGE&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;1-Online-DDL&quot;&gt;&lt;a href=&quot;#1-Online-DDL&quot; class=&quot;headerlink&quot; title=&quot;1. Online DDL&quot;&gt;&lt;/a&gt;1. Online DDL&lt;/h2&gt;&lt;p&gt;在 MySQL 5.1 （带InnoDB Plugin）和5.5中，有个新特性叫 Fast Index Creation（下称 FIC），就是在添加或者删除二级&lt;strong&gt;索引&lt;/strong&gt;的时候，可以不用复制原表。对于之前的版本对于索引的添加删除这类DDL操作，MySQL数据库的操作过程为如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先新建Temp table，表结构是 ALTAR TABLE 新定义的结构&lt;/li&gt;
&lt;li&gt;然后把原表中数据导入到这个Temp table&lt;/li&gt;
&lt;li&gt;删除原表&lt;/li&gt;
&lt;li&gt;最后把临时表rename为原来的表名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了保持数据的一致性，中间复制数据（Copy Table）全程锁表只读，如果有写请求进来将无法提供服务，连接数爆张。&lt;/p&gt;
&lt;p&gt;引入FIC之后，创建二级索引时会对原表加上一个S锁，创建过程不需要重建表（no-rebuild）；删除InnoDB二级索引只需要更新内部视图，并标记这个索引的空间可用，去掉数据库元数据上该索引的定义即可。这个过程也只允许读操作，不能写入，但大大加快了修改索引的速度（不含主键索引，InnoDB IOT的特性决定了修改主键依然需要 Copy Table ）。&lt;/p&gt;
&lt;p&gt;FIC只对索引的创建删除有效，MySQL 5.6 Online DDL把这种特性扩展到了添加列、删除列、修改列类型、列重命名、设置默认值等等，实际效果要看所使用的选项和操作类别来定。&lt;/p&gt;
&lt;h3 id=&quot;1-1-Online-DDL选项&quot;&gt;&lt;a href=&quot;#1-1-Online-DDL选项&quot; class=&quot;headerlink&quot; title=&quot;1.1 Online DDL选项&quot;&gt;&lt;/a&gt;1.1 Online DDL选项&lt;/h3&gt;&lt;p&gt;MySQL 在线DDL分为 &lt;code&gt;INPLACE&lt;/code&gt; 和 &lt;code&gt;COPY&lt;/code&gt; 两种方式，通过在ALTER语句的ALGORITHM参数指定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ALGORITHM=INPLACE&lt;/code&gt;，可以避免重建表带来的IO和CPU消耗，保证ddl期间依然有良好的性能和并发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALGORITHM=COPY&lt;/code&gt;，需要拷贝原始表，所以不允许并发DML写操作，可读。这种copy方式的效率还是不如 inplace ，因为前者需要记录undo和redo log，而且因为临时占用buffer pool引起短时间内性能受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面只是 Online DDL 内部的实现方式，此外还有 LOCK 选项控制是否锁表，根据不同的DDL操作类型有不同的表现：默认mysql尽可能不去锁表，但是像修改主键这样的昂贵操作不得不选择锁表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOCK=NONE&lt;/code&gt;，即DDL期间允许并发读写涉及的表，比如为了保证 ALTER TABLE 时不影响用户注册或支付，可以明确指定，好处是如果不幸该 alter语句不支持对该表的继续写入，则会提示失败，而不会直接发到库上执行。&lt;code&gt;ALGORITHM=COPY&lt;/code&gt;默认LOCK级别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOCK=SHARED&lt;/code&gt;，即DDL期间表上的写操作会被阻塞，但不影响读取。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOCK=DEFAULT&lt;/code&gt;，让mysql自己去判断lock的模式，原则是mysql尽可能不去锁表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOCK=EXCLUSIVE&lt;/code&gt;，即DDL期间该表不可用，堵塞任何读写请求。如果你想alter操作在最短的时间内完成，或者表短时间内不可用能接受，可以手动指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是有一点需要说明，无论任何模式下，online ddl开始之前都需要一个短时间排它锁(exclusive)来准备环境，所以alter命令发出后，会首先等待该表上的其它操作完成，在alter命令之后的请求会出现等待&lt;code&gt;waiting meta data lock&lt;/code&gt;。同样在ddl结束之前，也要等待alter期间所有的事务完成，也会堵塞一小段时间。所以尽量在ALTER TABLE之前确保没有大事务在执行，否则一样出现连环锁表。&lt;/p&gt;
&lt;h3 id=&quot;1-2-考虑不同的DDL操作类别&quot;&gt;&lt;a href=&quot;#1-2-考虑不同的DDL操作类别&quot; class=&quot;headerlink&quot; title=&quot;1.2 考虑不同的DDL操作类别&quot;&gt;&lt;/a&gt;1.2 考虑不同的DDL操作类别&lt;/h3&gt;&lt;p&gt;从上面的介绍可以看出，不是5.6支持在线ddl就可以随心所欲的alter table，锁不锁表要看情况：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="Percona-toolkit" scheme="http://seanlook.com/tags/Percona-toolkit/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB行格式对text/blob大变长字段的影响</title>
    <link href="http://seanlook.com/2016/05/18/mysql-blob-row_format/"/>
    <id>http://seanlook.com/2016/05/18/mysql-blob-row_format/</id>
    <published>2016-05-18T08:32:49.000Z</published>
    <updated>2016-05-18T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在排查现网Text与Blob类型，发现有不少，在《高性能MySQL(第3版)》看到对这两种变长数据类型的处理会涉及到在磁盘上创建临时表，性能开销比较大。于是把影响blob型数据存储方式了解了一下：row_format。<!-- 关于临时表的内容，请参考 --></p>
<h2 id="1-InnoDB的Antelop与Barracuda文件格式"><a href="#1-InnoDB的Antelop与Barracuda文件格式" class="headerlink" title="1. InnoDB的Antelop与Barracuda文件格式"></a>1. InnoDB的Antelop与Barracuda文件格式</h2><p>Innodb存储引擎保存记录，是以行的形式存放的（与之对应的是像Google BigTable这种列数据库）。在InnoDB 1.0.x版本之前，InnoDB 存储引擎提供了 <code>Compact</code> 和 <code>Redundant</code> 两种格式来存放行记录数据，这也是目前使用最多的一种格式。Redundant 格式是为兼容之前版本而保留的。</p>
<p>MySQL 5.1 中的 innodb_plugin 引入了新的<em>文件格式</em>：<code>Barracuda</code>（将以前的<em>行格式</em> compact 和 redundant 合称为<code>Antelope</code>），该文件格式拥有新的两种行格式：<code>compressed</code>和<code>dynamic</code>。</p>
<p>在 MySQL 5.6 版本中，默认还是 Compact 行格式，也是目前使用最多的一种 ROW FORMAT。用户可以通过命令 <code>SHOW TABLE STATUS LIKE&#39;table_name&#39;</code> 来查看当前表使用的行格式，其中 <em>row_format</em> 列表示当前所使用的行记录结构类型。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; show variables like "innodb_file_format";</span></div><div class="line">+--------------------+-----------+</div><div class="line"><span class="section">| Variable_name      | Value     |</span></div><div class="line">+--------------------+-----------+</div><div class="line"><span class="section">| innodb_file_format | Barracuda |</span></div><div class="line">+--------------------+-----------+</div><div class="line">1 row in set</div><div class="line"></div><div class="line">mysql&gt; show table status like "tablename%"\G</div><div class="line"><span class="bullet">*************************** </span>1. row ***************************</div><div class="line"><span class="code">           Name: t_rf_compact</span></div><div class="line"><span class="code">         Engine: InnoDB</span></div><div class="line"><span class="code">        Version: 10</span></div><div class="line"><span class="code">     Row_format: Compact</span></div><div class="line"><span class="code">           Rows: 4</span></div><div class="line"><span class="code"> Avg_row_length: 36864</span></div><div class="line"><span class="code">    Data_length: 147456</span></div><div class="line">Max<span class="emphasis">_data_</span>length: 0</div><div class="line"><span class="code">   Index_length: 0</span></div><div class="line"><span class="code">      Data_free: 0</span></div><div class="line"><span class="code"> Auto_increment: 7</span></div><div class="line"><span class="code">    Create_time: 2016-05-14 20:52:58</span></div><div class="line"><span class="code">    Update_time: NULL</span></div><div class="line"><span class="code">     Check_time: NULL</span></div><div class="line"><span class="code">      Collation: utf8_general_ci</span></div><div class="line"><span class="code">       Checksum: NULL</span></div><div class="line"><span class="code"> Create_options: </span></div><div class="line"><span class="code">        Comment: </span></div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>在 msyql 5.7.9 及以后版本，默认行格式由<code>innodb_default_row_format</code>变量决定，它的默认值是<code>DYNAMIC</code>，也可以在 create table 的时候指定<code>ROW_FORMAT=DYNAMIC</code>。</p>
<a id="more"></a>
<p>注意，如果要修改现有表的行模式为<code>compressed</code>或<code>dynamic</code>，必须先将文件格式设置成Barracuda：<code>set global innodb_file_format=Barracuda;</code>，再用<code>ALTER TABLE tablename ROW_FORMAT=COMPRESSED;</code>去修改才能生效，否则修改无效却无提示：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; ALTER TABLE tablename ROW<span class="emphasis">_FORMAT=COMPRESSED;</span></div><div class="line">Query OK, 0 rows affected</div><div class="line">Records: 0  Duplicates: 0  Warnings: 2</div><div class="line"></div><div class="line">修改失败</div><div class="line"><span class="section">mysql&gt; show warnings;</span></div><div class="line">+---------+------+-----------------------------------------------------------------------+</div><div class="line"><span class="section">| Level   | Code | Message                                                               |</span></div><div class="line">+---------+------+-----------------------------------------------------------------------+</div><div class="line">| Warning | 1478 | InnoDB: ROW<span class="emphasis">_FORMAT=COMPRESSED requires innodb_</span>file<span class="emphasis">_format &gt; Antelope. |</span></div><div class="line">| Warning | 1478 | InnoDB: assuming ROW_FORMAT=COMPACT.                                  |</div><div class="line"><span class="code">+---------+</span>------<span class="code">+-----------------------------------------------------------------------+</span></div><div class="line">2 rows in set</div></pre></td></tr></table></figure>
<h2 id="2-对TEXT-BLOB这类大字段类型的影响"><a href="#2-对TEXT-BLOB这类大字段类型的影响" class="headerlink" title="2. 对TEXT/BLOB这类大字段类型的影响"></a>2. 对TEXT/BLOB这类大字段类型的影响</h2><h3 id="2-1-compact"><a href="#2-1-compact" class="headerlink" title="2.1 compact"></a>2.1 compact</h3><p>在 Antelope 两种行格式下，如果blob列值长度 &lt;= 768 bytes，就不会发生行溢出(page overflow)，内容都在数据页(B-tree Node)；如果列值长度 &gt; 768字节，那么前768字节依然在数据页，而剩余的则放在溢出页(off-page)，如下图：</p>
<p><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-compact-768.png" alt=""></p>
<p>上面所讲的讲的blob或变长大字段类型包括blob,text,varchar，其中varchar列值长度大于某数N时也会存溢出页，在latin1字符集下N值可以这样计算：innodb的块大小默认为16kb，由于innodb存储引擎表为索引组织表，树底层的叶子节点为一双向链表，因此每个页中至少应该有两行记录，这就决定了innodb在存储一行数据的时候不能够超过8k，减去其它列值所占字节数，约等于N。</p>
<p>我们知道对于InnoDB来说，内存是极为珍贵的，如果把768字节长度的blob都放在数据页，虽然可以节省部分IO，但相对来说能缓存行数就变少，也就是能缓存的索引值变少了，降低了索引效率。</p>
<h3 id="2-2-dynamic"><a href="#2-2-dynamic" class="headerlink" title="2.2 dynamic"></a>2.2 dynamic</h3><p>Barracuda 的两种行格式对blob采用完全行溢出，即聚集索引记录（数据页）只保留20字节的指针，指向真实存放它的溢出段地址：<br><img src="http://7q5fot.com1.z0.glb.clouddn.com/mysql-barracuda-20-off-page.png" alt=""></p>
<p>dynamic行格式，列存储是否放到off-page页，主要取决于行大小，它会把行中最长的那一列放到off-page，直到数据页能存放下两行。TEXT/BLOB列 &lt;=40 bytes 时总是存放于数据页。这种方式可以避免compact那样把太多的大列值放到 B-tree Node，因为dynamic格式认为，只要大列值有部分数据放在off-page，那把整个值放入都放入off-page更有效。</p>
<p><strong>compressed</strong> 物理结构上与dynamic类似，但是对表的数据行使用zlib算法进行了压缩存储。在long blob列类型比较多的情况下用，可以降低off-page的使用，减少存储空间（一般40%左右），但要求更高的CPU，buffer pool里面可能会同时存储数据的压缩版和非压缩版，所以也多占用部分内存。这里 <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-compression-internals.html" target="_blank" rel="external">MySQL 5.6 Manual innodb-compression-internals</a> 讲的十分清楚。 </p>
<p>另外，由于<code>ROW_FORMAT=DYNAMIC</code> 和 <code>ROW_FORMAT=COMPRESSED</code> 是从 <code>ROW_FORMAT=COMPACT</code> 变化来的，所以他们处理 <code>CHAR</code>类型存储的方式和 COMPACT 一样。</p>
<h2 id="3-对blob型字段存取优化"><a href="#3-对blob型字段存取优化" class="headerlink" title="3. 对blob型字段存取优化"></a>3. 对blob型字段存取优化</h2><p>如果一个查询涉及BLOB值，又需要使用临时表——不管它多小——它都会立即在磁盘上创建临时表。这样效率很低，尤其是对小而快的查询，临时表可能是查询中最大的开销。</p>
<p>比如：创建一个带Text字段的compact表：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE TABLE <span class="code">`t_rf_compact`</span> (</div><div class="line"><span class="code">  `f_id` int(11) NOT NULL AUTO_INCREMENT,</span></div><div class="line"><span class="code">  `f_char` char(30) DEFAULT NULL,</span></div><div class="line"><span class="code">  `f_varchar` varchar(30) NOT NULL DEFAULT '',</span></div><div class="line"><span class="code">  `f_text` text NOT NULL,</span></div><div class="line"><span class="code">  PRIMARY KEY (`f_id`)</span></div><div class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW<span class="emphasis">_FORMAT=COMPACT;</span></div><div class="line"></div><div class="line">mysql&gt; insert into t<span class="emphasis">_rf_</span>compact(f<span class="emphasis">_char,f_</span>varchar,f<span class="emphasis">_text) values('aa','中中',repeat('b',700));</span></div><div class="line">mysql&gt; insert into t_rf<span class="emphasis">_compact(f_</span>char,f<span class="emphasis">_varchar,f_</span>text) values(<span class="emphasis">'aa'</span>,<span class="emphasis">'文'</span>,repeat(<span class="emphasis">'c'</span>,60000));</div><div class="line">第二条数据会行溢出，前768字节放在Clustered Index数据页，剩余的放扩展存储空间</div><div class="line"></div><div class="line"><span class="section">mysql&gt; explain select t1.f_id from t_rf_compact t1,t_rf_compact t2 where t1.f_id=t2.f_id order by t1.f_id limit 1; </span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</div><div class="line"><span class="section">| id | select_type | table | type   | possible_keys | key     | key_len | ref               | rows | Extra       |</span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</div><div class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | PRIMARY | 4       | NULL              |    6 | Using index |</div><div class="line"><span class="section">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | d_ec_crm2.t1.f_id |    1 | Using index |</span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+-------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">mysql&gt; show status like "%tmp%tables";</span></div><div class="line">+-------------------------+-------+</div><div class="line"><span class="section">| Variable_name           | Value |</span></div><div class="line">+-------------------------+-------+</div><div class="line">| Created<span class="emphasis">_tmp_</span>disk<span class="emphasis">_tables | 7     |</span></div><div class="line">| Created_tmp<span class="emphasis">_tables      | 36    |</span></div><div class="line">+-------------------------+-------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="section">mysql&gt; select t1.f_id from t_rf_compact t1,t_rf_compact t2 where t1.f_id=t2.f_id order by t1.f_id limit 1;</span></div><div class="line">+------+</div><div class="line"><span class="section">| f_id |</span></div><div class="line">+------+</div><div class="line"><span class="section">|    1 |</span></div><div class="line">+------+</div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line"><span class="section">mysql&gt; show status like "%tmp%tables";</span></div><div class="line">+-------------------------+-------+</div><div class="line"><span class="section">| Variable_name           | Value |</span></div><div class="line">+-------------------------+-------+</div><div class="line">| Created<span class="emphasis">_tmp_</span>disk<span class="emphasis">_tables | 7     |</span></div><div class="line">| Created_tmp<span class="emphasis">_tables      | 36    |</span></div><div class="line">+-------------------------+-------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>没有临时表产生，所以磁盘临时表无变化。让它产生临时表：（但不涉及text列）</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; explain select t1.f_id from t_rf_compact t1,t_rf_compact t2 where t1.f_id=t2.f_id order by t2.f_id;</span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+----------------------------------------------+</div><div class="line"><span class="section">| id | select_type | table | type   | possible_keys | key     | key_len | ref               | rows | Extra                                        |</span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+----------------------------------------------+</div><div class="line">|  1 | SIMPLE      | t1    | index  | PRIMARY       | PRIMARY | 4       | NULL              |    6 | Using index; Using temporary; Using filesort |</div><div class="line"><span class="section">|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | d_ec_crm2.t1.f_id |    1 | Using index                                  |</span></div><div class="line">+----+-------------+-------+--------+---------------+---------+---------+-------------------+------+----------------------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select t1.f<span class="emphasis">_id from t_</span>rf<span class="emphasis">_compact t1,t_</span>rf<span class="emphasis">_compact t2 where t1.f_</span>id=t2.f<span class="emphasis">_id order by t2.f_</span>id;</div><div class="line"></div><div class="line"><span class="section">mysql&gt; show status like "%tmp%tables";</span></div><div class="line">+-------------------------+-------+</div><div class="line"><span class="section">| Variable_name           | Value |</span></div><div class="line">+-------------------------+-------+</div><div class="line">| Created<span class="emphasis">_tmp_</span>disk<span class="emphasis">_tables | 7     |</span></div><div class="line">| Created_tmp<span class="emphasis">_tables      | 37    |</span></div><div class="line">+-------------------------+-------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>虽然有<code>Using temporary</code>，但内存临时表还是够用，磁盘临时表还是无变化。返回TEXT列（也会使用临时表排序）：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select t1.f<span class="emphasis">_text from t_</span>rf<span class="emphasis">_compact t1,t_</span>rf<span class="emphasis">_compact t2 where t1.f_</span>id=t2.f<span class="emphasis">_id order by t2.f_</span>id;</div><div class="line"><span class="section">mysql&gt; show status like "%tmp%tables";</span></div><div class="line">+-------------------------+-------+</div><div class="line"><span class="section">| Variable_name           | Value |</span></div><div class="line">+-------------------------+-------+</div><div class="line">| Created<span class="emphasis">_tmp_</span>disk<span class="emphasis">_tables | 8     |</span></div><div class="line">| Created_tmp<span class="emphasis">_tables      | 38    |</span></div><div class="line">+-------------------------+-------+</div><div class="line">2 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<p><code>Created_tmp_disk_tables</code>磁盘临时表有增加，与上面结论相符：只有有TEXT/BLOB列参与，如果用到临时表，不管它多小，都会创建在磁盘上，从而带来性能消耗。</p>
<p>注：磁盘临时表存储引擎一定是 MyISAM，与<code>select @@default_tmp_storage_engine;</code>（5.6.3开始）看到的<em>InnoDB</em>无关，它是控制<em>CREATE TEMPORARY TABLE</em>时的默认引擎。在 5.7.5 开始<code>internal_tmp_disk_storage_engine</code>选项可以定义磁盘临时表的引擎类型。关于临时表与内存表可以参考 <a href="http://imysql.com/2015/07/11/mysql-faq-how-using-temp-table.shtml" target="_blank" rel="external">[MySQL FAQ]系列 — 什么情况下会用到临时表 -老叶</a> 。</p>
<p>有两种办法来减轻这种不利的情况：通过 <code>SUBSTRING()</code> 函数把值转换为 VARCHAR，或者让磁盘临时表更快一些。</p>
<p>让磁盘临时表运行更快的方式是，把它们放在基于内存的文件系统tmpfs，tmpfs文件系统为了降低开销不会刷新内存数据到磁盘，读写速度也很快，而临时表也不需要持久存放。mysql的 tmpdir 参数控制临时文件存放位置，建议如果使用的话要监控空间使用率。另外如果BLOB列非常大或多，可以考虑调大InnoDB日志缓存大小<code>innodb_log_buffer_size</code>。</p>
<p>如果使用BLOB这类变长大字段类型，需要以下后果考虑：</p>
<blockquote>
<ul>
<li>大字段在InnoDB里可能浪费大量空间。例如，若存储字段值只是比行的要求多了一个字节，也会使用整个页面来存储剩下的字节，浪费了页面的大部分空间。同样的，如果有一个值只是稍微超过了32个页的大小，实际上就需要使用96个页面。</li>
<li>扩展存储禁用了自适应哈希，因为需要完整的比较列的整个长度，才能发现是不是正确的数据（哈希帮助InnoDB非常快速的找到“猜测的位置”，但是必须检查“猜测的位置”是不是正确）。因为自适应哈希是完全的内存结构，并且直接指向Buffer Pool中访问“最”频繁的页面，但对于扩展存储空间却无法使用Adaptive Hash。</li>
<li>太长的值可能使得在查询中作为WHERE条件不能使用索引，因而执行很慢。在应用WHERE条件之前，MySQL需要把所有的列读出来，所以可能导致MySQL要求InnoDB读取很多扩展存储，然后检查WHERE条件，丢弃所有不需要的数据。查询不需要的列绝对不是好主意，在这种特殊的场景下尤其需要避免这样做。如果发现查询正遇到这个限制带来的问题，可以尝试通过覆盖索引来解决部分问题。</li>
<li>如果一张表里有很多大字段，最好是把它们组合起来单独存到一个列里面，比如说用XML文档格式存储。这让所有的大字段共享一个扩展存储空间，这比每个字段用自己的页要好。</li>
<li>有时候可以把大字段用COMPRESS()压缩后再存为BLOB，或者在发送到MySQL前在应用程序中进行压缩，这可以获得显著的空间优势和性能收益。<br>—— 《高性能MySQL(第3版)》 P368</li>
</ul>
</blockquote>
<p>对上面的解读就是：</p>
<ul>
<li>如果预期长度范围varchar就满足，就避免使用TEXT</li>
<li>对于字段非常大的列可以在应用程序里压缩后再存到mysql，如果列值很长请考虑用单独的表存放</li>
<li>一张表有多个类blob字段，把它们组合起来如<code>&lt;TEXT&gt;&lt;f_big_col1&gt;long..&lt;/f_big_col1&gt; &lt;f_content&gt;long..&lt;/f_content&gt;&lt;/TEXT&gt;</code>，再压缩存储。但要考虑是否使用全文索引，是否需要前缀索引。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.opskumu.com/mysql-blob.html" target="_blank" rel="external">MySQL 大字段溢出导致数据回写失败</a></li>
<li><a href="http://hidba.org/?p=551" target="_blank" rel="external">innodb使用大字段text，blob的一些优化建议 -玄惭</a></li>
<li><a href="http://imysql.com/2014/09/28/mysql-optimization-case-blob-stored-in-innodb-optimization.shtml" target="_blank" rel="external">[MySQL优化案例]系列 — 优化InnoDB表BLOB列的存储效率 -老叶</a></li>
<li><a href="http://blog.chinaunix.net/uid-24485075-id-3523032.html" target="_blank" rel="external">InnoDB 数据表压缩原理与限制 </a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-row-format-dynamic.html" target="_blank" rel="external">MySQL Manual DYNAMIC and COMPRESSED Row Formats </a></li>
<li>《MySQL技术内幕·InnoDB存储引擎》 P</li>
</ul>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/05/18/mysql-blob-row_format/">http://seanlook.com/2016/05/18/mysql-blob-row_format/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在排查现网Text与Blob类型，发现有不少，在《高性能MySQL(第3版)》看到对这两种变长数据类型的处理会涉及到在磁盘上创建临时表，性能开销比较大。于是把影响blob型数据存储方式了解了一下：row_format。&lt;!-- 关于临时表的内容，请参考 --&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-InnoDB的Antelop与Barracuda文件格式&quot;&gt;&lt;a href=&quot;#1-InnoDB的Antelop与Barracuda文件格式&quot; class=&quot;headerlink&quot; title=&quot;1. InnoDB的Antelop与Barracuda文件格式&quot;&gt;&lt;/a&gt;1. InnoDB的Antelop与Barracuda文件格式&lt;/h2&gt;&lt;p&gt;Innodb存储引擎保存记录，是以行的形式存放的（与之对应的是像Google BigTable这种列数据库）。在InnoDB 1.0.x版本之前，InnoDB 存储引擎提供了 &lt;code&gt;Compact&lt;/code&gt; 和 &lt;code&gt;Redundant&lt;/code&gt; 两种格式来存放行记录数据，这也是目前使用最多的一种格式。Redundant 格式是为兼容之前版本而保留的。&lt;/p&gt;
&lt;p&gt;MySQL 5.1 中的 innodb_plugin 引入了新的&lt;em&gt;文件格式&lt;/em&gt;：&lt;code&gt;Barracuda&lt;/code&gt;（将以前的&lt;em&gt;行格式&lt;/em&gt; compact 和 redundant 合称为&lt;code&gt;Antelope&lt;/code&gt;），该文件格式拥有新的两种行格式：&lt;code&gt;compressed&lt;/code&gt;和&lt;code&gt;dynamic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 MySQL 5.6 版本中，默认还是 Compact 行格式，也是目前使用最多的一种 ROW FORMAT。用户可以通过命令 &lt;code&gt;SHOW TABLE STATUS LIKE&amp;#39;table_name&amp;#39;&lt;/code&gt; 来查看当前表使用的行格式，其中 &lt;em&gt;row_format&lt;/em&gt; 列表示当前所使用的行记录结构类型。&lt;/p&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;mysql&amp;gt; show variables like &quot;innodb_file_format&quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+--------------------+-----------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;| Variable_name      | Value     |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+--------------------+-----------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;| innodb_file_format | Barracuda |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+--------------------+-----------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1 row in set&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; show table status like &quot;tablename%&quot;\G&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;*************************** &lt;/span&gt;1. row ***************************&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;           Name: t_rf_compact&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;         Engine: InnoDB&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;        Version: 10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;     Row_format: Compact&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;           Rows: 4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt; Avg_row_length: 36864&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;    Data_length: 147456&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Max&lt;span class=&quot;emphasis&quot;&gt;_data_&lt;/span&gt;length: 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;   Index_length: 0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;      Data_free: 0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt; Auto_increment: 7&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;    Create_time: 2016-05-14 20:52:58&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;    Update_time: NULL&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;     Check_time: NULL&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;      Collation: utf8_general_ci&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;       Checksum: NULL&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt; Create_options: &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;        Comment: &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1 row in set (0.00 sec)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 msyql 5.7.9 及以后版本，默认行格式由&lt;code&gt;innodb_default_row_format&lt;/code&gt;变量决定，它的默认值是&lt;code&gt;DYNAMIC&lt;/code&gt;，也可以在 create table 的时候指定&lt;code&gt;ROW_FORMAT=DYNAMIC&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="schema设计" scheme="http://seanlook.com/tags/schema%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库开发规范-EC</title>
    <link href="http://seanlook.com/2016/05/11/mysql-dev-principle-ec/"/>
    <id>http://seanlook.com/2016/05/11/mysql-dev-principle-ec/</id>
    <published>2016-05-11T08:32:49.000Z</published>
    <updated>2016-05-11T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 

http://highdb.com/mysql%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/
http://blog.csdn.net/xlgen157387/article/details/48086607
http://www.iteye.com/topic/1141229
-->
<p>最近一段时间一边在线上抓取SQL来优化，一边在整理这个开发规范，尽量减少新的问题SQL进入生产库。今天也是对公司的开发做了一次培训，PPT就不放上来了，里面有十来个生产SQL的案例。因为规范大部分还是具有通用性，所以也借鉴了像去哪儿和赶集的规范，但实际在撰写本文的过程中，每一条规范的背后无不是在工作中有参照的反面例子的。如果时间可以的话，会抽出一部分或分析其原理，或用案例证明。</p>
<h2 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h2><ol>
<li><h3 id="库名、表名、字段名必须使用小写字母，并采用下划线分割"><a href="#库名、表名、字段名必须使用小写字母，并采用下划线分割" class="headerlink" title="库名、表名、字段名必须使用小写字母，并采用下划线分割"></a>库名、表名、字段名必须使用小写字母，并采用下划线分割</h3><ul>
<li>MySQL有配置参数lower_case_table_names=1，即库表名以小写存储，大小写不敏感。如果是0，则库表名以实际情况存储，大小写敏感；如果是2，以实际情况存储，但以小写比较。</li>
<li>如果大小写混合使用，可能存在abc，Abc，ABC等多个表共存，容易导致混乱。</li>
<li>字段名显示区分大小写，但实际使⽤时不区分，即不可以建立两个名字一样但大小写不一样的字段。</li>
<li>为了统一规范， 库名、表名、字段名使用小写字母。</li>
</ul>
</li>
<li><h3 id="库名以-d-开头，表名以-t-开头，字段名以-f-开头"><a href="#库名以-d-开头，表名以-t-开头，字段名以-f-开头" class="headerlink" title="库名以 d 开头，表名以 t 开头，字段名以 f_ 开头"></a>库名以 d<em> 开头，表名以 t</em> 开头，字段名以 f_ 开头</h3><ul>
<li>比如表 <code>t_crm_relation</code>，中间的 crm 代表业务模块名</li>
<li>视图以<code>view_</code>开头，事件以<code>event_</code>开头，触发器以<code>trig_</code>开头，存储过程以<code>proc_</code>开头，函数以<code>func_</code>开头</li>
<li>普通索引以<code>idx_col1_col2</code>命名，唯一索引以<code>uk_col1_col2</code>命名（可去掉f_公共部分）。如 idx_companyid_corpid_contacttime(f_company_id,f_corp_id,f_contact_time)</li>
</ul>
</li>
<li><h3 id="库名、表名、字段名禁止超过32个字符，需见名知意"><a href="#库名、表名、字段名禁止超过32个字符，需见名知意" class="headerlink" title="库名、表名、字段名禁止超过32个字符，需见名知意"></a>库名、表名、字段名禁止超过32个字符，需见名知意</h3><p>库名、表名、字段名支持最多64个字符，但为了统一规范、易于辨识以及减少传输量，禁止超过32个字符</p>
</li>
<li><h3 id="临时库、表名须以tmp加日期为后缀"><a href="#临时库、表名须以tmp加日期为后缀" class="headerlink" title="临时库、表名须以tmp加日期为后缀"></a>临时库、表名须以tmp加日期为后缀</h3><p>如 t_crm_relation_tmp0425。备份表也类似，形如 <code>_bak20160425</code> 。</p>
</li>
<li><h3 id="按日期时间分表须符合-YYYY-MM-DD-格式"><a href="#按日期时间分表须符合-YYYY-MM-DD-格式" class="headerlink" title="按日期时间分表须符合_YYYY[MM][DD]格式"></a>按日期时间分表须符合_YYYY[MM][DD]格式</h3><p>这也是为将来有可能分表做准备的，比如<code>t_crm_ec_record_201403</code>，但像 t_crm_contact_at201506就打破了这种规范。<br>不具有时间特性的，直接以 <code>t_tbname_001</code> 这样的方式命名。</p>
</li>
</ol>
<h2 id="2-库表基础规范"><a href="#2-库表基础规范" class="headerlink" title="2. 库表基础规范"></a>2. 库表基础规范</h2><ol>
<li><h3 id="使用Innodb存储引擎"><a href="#使用Innodb存储引擎" class="headerlink" title="使用Innodb存储引擎"></a>使用Innodb存储引擎</h3><p>5.5版本开始mysql默认存储引擎就是InnoDB，5.7版本开始，系统表都放弃MyISAM了。</p>
</li>
<li><h3 id="表字符集统一使用UTF8"><a href="#表字符集统一使用UTF8" class="headerlink" title="表字符集统一使用UTF8"></a>表字符集统一使用UTF8</h3><ul>
<li>UTF8字符集存储汉字占用3个字节，存储英文字符占用一个字节</li>
<li>校对字符集使用默认的 utf8_general_ci</li>
<li>连接的客户端也使用utf8，建立连接时指定charset或<code>SET NAMES UTF8;</code>。（对于已经在项目中长期使用latin1的，救不了了）</li>
<li>如果遇到EMOJ等表情符号的存储需求，可申请使用UTF8MB4字符集</li>
</ul>
</li>
<li><h3 id="所有表都要添加注释"><a href="#所有表都要添加注释" class="headerlink" title="所有表都要添加注释"></a>所有表都要添加注释</h3><ul>
<li>尽量给字段也添加注释</li>
<li>类status型需指明主要值的含义，如”0-离线，1-在线”</li>
</ul>
</li>
<li><h3 id="控制单表字段数量"><a href="#控制单表字段数量" class="headerlink" title="控制单表字段数量"></a>控制单表字段数量</h3><ul>
<li>单表字段数上限30左右，再多的话考虑垂直分表，一是冷热数据分离，二是大字段分离，三是常在一起做条件和返回列的不分离。</li>
<li>表字段控制少而精，可以提高IO效率，内存缓存更多有效数据，从而提高响应速度和并发能力，后续 alter table 也更快。</li>
</ul>
</li>
<li><h3 id="所有表都必须要显式指定主键"><a href="#所有表都必须要显式指定主键" class="headerlink" title="所有表都必须要显式指定主键"></a>所有表都必须要显式指定主键</h3><ul>
<li>主键尽量采用自增方式，InnoDB表实际是一棵索引组织表，顺序存储可以提高存取效率，充分利用磁盘空间。还有对一些复杂查询可能需要自连接来优化时需要用到。</li>
<li>需要全局唯一主键时，使用外部发号器ticket server（建设中）</li>
<li>如果没有主键或唯一索引，update/delete是通过所有字段来定位操作的行，相当于每行就是一次全表扫描</li>
<li>少数情况可以使用联合唯一主键，需与DBA协商</li>
</ul>
</li>
<li><h3 id="不强制使用外键参考"><a href="#不强制使用外键参考" class="headerlink" title="不强制使用外键参考"></a>不强制使用外键参考</h3><p>即使2个表的字段有明确的外键参考关系，也不使用 FOREIGN KEY ，因为新纪录会去主键表做校验，影响性能。</p>
</li>
<li><h3 id="适度使用存储过程、视图，禁止使用触发器、事件"><a href="#适度使用存储过程、视图，禁止使用触发器、事件" class="headerlink" title="适度使用存储过程、视图，禁止使用触发器、事件"></a>适度使用存储过程、视图，禁止使用触发器、事件</h3></li>
</ol>
<a id="more"></a>
<ul>
<li>存储过程（procedure）虽然可以简化业务端代码，在传统企业写复杂逻辑时可能会用到，而在互联网企业变更是很频繁的，在分库分表的情况下要升级一个存储过程相当麻烦。又因为它是不记录log的，所以也不方便debug性能问题。如果使用过程，一定考虑如果执行失败的情况。<ul>
<li>使用视图一定程度上也是为了降低代码里SQL的复杂度，但有时候为了视图的通用性会损失性能（比如返回不必要的字段）。</li>
</ul>
</li>
<li>触发器（trigger）也是同样，但也不应该通过它去约束数据的强一致性，mysql只支持“基于行的触发”，也就是说，触发器始终是针对一条记录的，而不是针对整个sql语句的，如果变更的数据集非常大的话，效率会很低。掩盖一条sql背后的工作，一旦出现问题将是灾难性的，但又很难快速分析和定位。再者需要ddl时无法使用pt-osc工具。放在transaction执行。</li>
<li>事件（event）也是一种偷懒的表现，目前已经遇到数次由于定时任务执行失败影响业务的情况，而且mysql无法对它做失败预警。建立专门的 job scheduler 平台。</li>
</ul>
<ol>
<li><h3 id="单表数据量控制在5000w以内"><a href="#单表数据量控制在5000w以内" class="headerlink" title="单表数据量控制在5000w以内"></a>单表数据量控制在5000w以内</h3></li>
<li><h3 id="数据库中不允许存储明文密码"><a href="#数据库中不允许存储明文密码" class="headerlink" title="数据库中不允许存储明文密码"></a>数据库中不允许存储明文密码</h3></li>
</ol>
<h2 id="3-字段规范"><a href="#3-字段规范" class="headerlink" title="3. 字段规范"></a>3. 字段规范</h2><ol>
<li><h3 id="char、varchar、text等字符串类型定义"><a href="#char、varchar、text等字符串类型定义" class="headerlink" title="char、varchar、text等字符串类型定义"></a>char、varchar、text等字符串类型定义</h3><ul>
<li>对于长度基本固定的列，如果该列恰好更新又特别频繁，适合char</li>
<li>varchar虽然存储变长字符串，但不可太小也不可太大。UTF8最多能存21844个汉字，或65532个英文</li>
<li>varbinary(M)保存的是二进制字符串，它保存的是字节而不是字符，所以没有字符集的概念，M长度0-255（字节）。只用于排序或比较时大小写敏感的类型，不包括密码存储</li>
<li>TEXT类型与VARCHAR都类似，存储可变长度，最大限制也是2^16，但是它20bytes以后的内容是在数据页以外的空间存储（row_format=dynamic），对它的使用需要多一次寻址，没有默认值。<br>一般用于存放容量平均都很大、操作没有其它字段那样频繁的值。<br>网上部分文章说要避免使用text和blob，要知道如果纯用varchar可能会导致行溢出，效果差不多，但因为每行占用字节数过多，会导致buffer_pool能缓存的数据行、页下降。另外text和blob上面一般不会去建索引，而是利用sphinx之类的第三方全文搜索引擎，如果确实要创建（前缀）索引，那就会影响性能。凡事看具体场景。<br>另外尽可能把text/blob拆到另一个表中</li>
<li>BLOB可以看出varbinary的扩展版本，内容以二进制字符串存储，无字符集，区分大小写，有一种经常提但不用的场景：不要在数据库里存储图片。</li>
</ul>
</li>
<li><h3 id="int、tinyint、decimal等数字类型定义"><a href="#int、tinyint、decimal等数字类型定义" class="headerlink" title="int、tinyint、decimal等数字类型定义"></a>int、tinyint、decimal等数字类型定义</h3><ul>
<li>使用tinyint来代替 enum和boolean<br>ENUM类型在需要修改或增加枚举值时，需要在线DDL，成本较高；ENUM列值如果含有数字类型，可能会引起默认值混淆<br>tinyint使用1个字节，一般用于status,type,flag的列</li>
<li>建议使用 UNSIGNED 存储非负数值<br>相比不使用 unsigned，可以扩大一倍使用数值范围</li>
<li>int使用固定4个字节存储，int(11)与int(4)只是显示宽度的区别</li>
<li>使用Decimal 代替float/double存储精确浮点数<br>对于货币、金额这样的类型，使用decimal，如 decimal(9,2)。float默认只能能精确到6位有效数字</li>
</ul>
</li>
<li><h3 id="timestamp与datetime选择"><a href="#timestamp与datetime选择" class="headerlink" title="timestamp与datetime选择"></a>timestamp与datetime选择</h3><ul>
<li>datetime 和 timestamp类型所占的存储空间不同，前者8个字节，后者4个字节，这样造成的后果是两者能表示的时间范围不同。前者范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，后者范围为 1970-01-01 08:00:01 到 2038-01-19 11:14:07 。所以 TIMESTAMP 支持的范围比 DATATIME 要小。</li>
<li>timestamp可以在insert/update行时，自动更新时间字段（如 f_set_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP），但一个表只能有一个这样的定义。</li>
<li>timestamp显示与时区有关，内部总是以 UTC 毫秒 来存的。还受到严格模式的限制</li>
<li>优先使用timestamp，datetime也没问题</li>
<li>where条件里不要对时间列上使用时间函数</li>
</ul>
</li>
<li><h3 id="建议字段都定义为NOT-NULL"><a href="#建议字段都定义为NOT-NULL" class="headerlink" title="建议字段都定义为NOT NULL"></a>建议字段都定义为NOT NULL</h3><ul>
<li>如果是索引字段，一定要定义为not null 。因为null值会影响cordinate统计，影响优化器对索引的选择</li>
<li>如果不能保证insert时一定有值过来，定义时使用default ‘’ ，或 0</li>
</ul>
</li>
<li><h3 id="同一意义的字段定义必须相同"><a href="#同一意义的字段定义必须相同" class="headerlink" title="同一意义的字段定义必须相同"></a>同一意义的字段定义必须相同</h3><p> 比如不同表中都有 f_user_id 字段，那么它的类型、字段长度要设计成一样</p>
</li>
</ol>
<h2 id="4-索引规范"><a href="#4-索引规范" class="headerlink" title="4. 索引规范"></a>4. 索引规范</h2><ol>
<li><h3 id="任何新的select-update-delete上线，都要先explain，看索引使用情况"><a href="#任何新的select-update-delete上线，都要先explain，看索引使用情况" class="headerlink" title="任何新的select,update,delete上线，都要先explain，看索引使用情况"></a>任何新的select,update,delete上线，都要先explain，看索引使用情况</h3><p>尽量避免extra列出现：Using File Sort，Using Temporary，rows超过1000的要谨慎上线。<br>explain解读</p>
<ul>
<li><code>type</code>：ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</li>
<li><code>possible_keys</code>：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li><code>key</code>：表示MySQL实际决定使用的键（索引）<br>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX</li>
<li><code>ref</code>：表示选择 <code>key</code> 列上的索引，哪些列或常量被用于查找索引列上的值</li>
<li><code>rows</code>：根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li><code>Extra</code><ul>
<li><code>Using temporary</code>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</li>
<li><code>Using filesort</code>：MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><h3 id="索引个数限制"><a href="#索引个数限制" class="headerlink" title="索引个数限制"></a>索引个数限制</h3><ul>
<li>索引是双刃剑，会增加维护负担，增大IO压力，索引占用空间是成倍增加的</li>
<li>单张表的索引数量控制在5个以内，或不超过表字段个数的20%。若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。</li>
</ul>
</li>
<li><h3 id="避免冗余索引"><a href="#避免冗余索引" class="headerlink" title="避免冗余索引"></a>避免冗余索引</h3><ul>
<li>InnoDB表是一棵索引组织表，主键是和数据放在一起的聚集索引，普通索引最终指向的是主键地址，所以把主键做最后一列是多余的。如f_crm_id作为主键，联合索引(f_user_id,f_crm_id)上的f_crm_id就完全多余</li>
<li>(a,b,c)、(a,b)，后者为冗余索引。可以利用前缀索引来达到加速目的，减轻维护负担</li>
</ul>
</li>
<li><h3 id="没有特殊要求，使用自增id作为主键"><a href="#没有特殊要求，使用自增id作为主键" class="headerlink" title="没有特殊要求，使用自增id作为主键"></a>没有特殊要求，使用自增id作为主键</h3><ul>
<li>主键是一种聚集索引，顺序写入。组合唯一索引作为主键的话，是随机写入，适合写少读多的表</li>
<li>主键不允许更新</li>
</ul>
</li>
<li><h3 id="索引尽量建在选择性高的列上"><a href="#索引尽量建在选择性高的列上" class="headerlink" title="索引尽量建在选择性高的列上"></a>索引尽量建在选择性高的列上</h3><ul>
<li>不在低基数列上建立索引，例如性别、类型。但有一种情况，idx_feedbackid_type (f_feedback_id,f_type)，如果经常用 f_type=1 比较，而且能过滤掉90%行，那这个组合索引就值得创建。有时候同样的查询语句，由于条件取值不同导致使用不同的索引，也是这个道理。</li>
<li>索引选择性计算方法（基数 ÷ 数据行数）<br>Selectivity = Cardinality / Total Rows = select count(distinct col1)/count(*) from tbname，越接近1说明col1上使用索引的过滤效果越好</li>
<li>走索引扫描行数超过30%时，改全表扫描</li>
</ul>
</li>
<li><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><ul>
<li>mysql使用联合索引时，从左向右匹配，遇到断开或者范围查询时，无法用到后续的索引列<br>比如索引idx_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)、(c1,c2)、(c1,c2,c3)三个索引，where条件包含上面三种情况的字段比较则可以用到索引，但像 where c1=a and c3=c 只能用到c1列的索引，像 c2=b and c3=c等情况就完全用不到这个索引</li>
<li>遇到范围查询(&gt;、&lt;、between、like)也会停止索引匹配，比如 c1=a and c2 &gt; 2 and c3=c，只有c1,c2列上的比较能用到索引，(c1,c2,c3)排列的索引才可能会都用上</li>
<li>where条件里面字段的顺序与索引顺序无关，mysql优化器会自动调整顺序</li>
</ul>
</li>
<li><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>对超过30个字符长度的列创建索引时，考虑使用前缀索引，如 idx_cs_guid2 (f_cs_guid(26))表示截取前26个字符做索引，既可以提高查找效率，也可以节省空间</li>
<li>前缀索引也有它的缺点是，如果在该列上 ORDER BY 或 GROUP BY 时无法使用索引，也不能把它们用作覆盖索引(Covering Index)</li>
<li>如果在varbinary或blob这种以二进制存储的列上建立前缀索引，要考虑字符集，括号里表示的是字节数</li>
</ul>
</li>
<li><h3 id="合理使用覆盖索引减少IO"><a href="#合理使用覆盖索引减少IO" class="headerlink" title="合理使用覆盖索引减少IO"></a>合理使用覆盖索引减少IO</h3><p>INNODB存储引擎中，secondary index(非主键索引，又称为辅助索引、二级索引)没有直接存储行地址，而是存储主键值。<br>如果用户需要查询secondary index中所不包含的数据列，则需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引则可以在一个索引中获取所有需要的数据列，从而避免回表进行二次查找，节省IO因此效率较高。<br>例如SELECT email，uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid，email)，以获得性能提升。</p>
</li>
<li><h3 id="尽量不要在频繁更新的列上创建索引"><a href="#尽量不要在频繁更新的列上创建索引" class="headerlink" title="尽量不要在频繁更新的列上创建索引"></a>尽量不要在频繁更新的列上创建索引</h3><p>如不在定义了 ON UPDATE CURRENT_STAMP 的列上创建索引，维护成本太高（好在mysql有insert buffer，会合并索引的插入）</p>
</li>
</ol>
<h2 id="5-SQL设计"><a href="#5-SQL设计" class="headerlink" title="5. SQL设计"></a>5. SQL设计</h2><ol>
<li><h3 id="杜绝直接-SELECT-读取全部字段"><a href="#杜绝直接-SELECT-读取全部字段" class="headerlink" title="杜绝直接 SELECT * 读取全部字段"></a>杜绝直接 SELECT * 读取全部字段</h3><p> 即使需要所有字段，减少网络带宽消耗，能有效利用覆盖索引，表结构变更对程序基本无影响</p>
</li>
<li><h3 id="能确定返回结果只有一条时，使用-limit-1"><a href="#能确定返回结果只有一条时，使用-limit-1" class="headerlink" title="能确定返回结果只有一条时，使用 limit 1"></a>能确定返回结果只有一条时，使用 limit 1</h3><p><strong>在保证数据不会有误的前提下</strong>，能确定结果集数量时，多使用limit，尽快的返回结果。</p>
</li>
<li><h3 id="小心隐式类型转换"><a href="#小心隐式类型转换" class="headerlink" title="小心隐式类型转换"></a>小心隐式类型转换</h3><ul>
<li><p>转换规则</p>
<blockquote>
<p>a. 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换<br>b. 两个参数都是字符串，会按照字符串来比较，不做类型转换<br>c. 两个参数都是整数，按照整数来比较，不做类型转换<br>d. 十六进制的值和非数字做比较时，会被当做二进制串<br>e. 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp<br>f. 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较<br>g. 所有其他情况下，两个参数都会被转换为浮点数再进行比较。</p>
</blockquote>
</li>
<li><p>如果一个索引建立在string类型上，如果这个字段和一个int类型的值比较，符合第 g 条。如f_phone定义的类型是varchar，但where使用f_phone in (098890)，两个参数都会被当成成浮点型。发生这个隐式转换并不是最糟的，最糟的是string转换后的float，mysql无法使用索引，这才导致了性能问题。如果是 f_user_id = ‘1234567’ 的情况，符合第 b 条,直接把数字当字符串比较。</p>
</li>
</ul>
</li>
<li><h3 id="禁止在where条件列上使用函数"><a href="#禁止在where条件列上使用函数" class="headerlink" title="禁止在where条件列上使用函数"></a>禁止在where条件列上使用函数</h3><ul>
<li>会导致索引失效，如lower(email)，f_qq % 4。可放到右边的常量上计算</li>
<li>返回小结果集不是很大的情况下，可以对返回列使用函数，简化程序开发</li>
</ul>
</li>
<li><h3 id="使用like模糊匹配，-不要放首位"><a href="#使用like模糊匹配，-不要放首位" class="headerlink" title="使用like模糊匹配，%不要放首位"></a>使用like模糊匹配，%不要放首位</h3><p>会导致索引失效，有这种搜索需求是，考虑其它方案，如sphinx全文搜索</p>
</li>
<li><h3 id="涉及到复杂sql时，务必先参考已有索引设计，先explain"><a href="#涉及到复杂sql时，务必先参考已有索引设计，先explain" class="headerlink" title="涉及到复杂sql时，务必先参考已有索引设计，先explain"></a>涉及到复杂sql时，务必先参考已有索引设计，先explain</h3><ul>
<li>简单SQL拆分，不以代码处理复杂为由。</li>
<li>比如 OR 条件： f_phone=’10000’ or f_mobile=’10000’，两个字段各自有索引，但只能用到其中一个。可以拆分成2个sql，或者union all。</li>
<li>先explain的好处是可以为了利用索引，增加更多查询限制条件</li>
</ul>
</li>
<li><h3 id="使用join时，where条件尽量使用充分利用同一表上的索引"><a href="#使用join时，where条件尽量使用充分利用同一表上的索引" class="headerlink" title="使用join时，where条件尽量使用充分利用同一表上的索引"></a>使用join时，where条件尽量使用充分利用同一表上的索引</h3><ul>
<li>如 select t1.a,t2.b * from t1,t2 and t1.a=t2.a and t1.b=123 and t2.c= 4 ，如果t1.c与t2.c字段相同，那么t1上的索引(b,c)就只用到b了。此时如果把where条件中的t2.c=4改成t1.c=4，那么可以用到完整的索引</li>
<li>这种情况可能会在字段冗余设计（反范式）时出现</li>
<li>正确选取inner join和left join</li>
</ul>
</li>
<li><h3 id="少用子查询，改用join"><a href="#少用子查询，改用join" class="headerlink" title="少用子查询，改用join"></a>少用子查询，改用join</h3><p>小于5.6版本时，子查询效率很低，不像Oracle那样先计算子查询后外层查询。5.6版本开始得到优化</p>
</li>
<li><h3 id="考虑使用union-all，少使用union，注意考虑去重"><a href="#考虑使用union-all，少使用union，注意考虑去重" class="headerlink" title="考虑使用union all，少使用union，注意考虑去重"></a>考虑使用union all，少使用union，注意考虑去重</h3><ul>
<li>union all不去重，而少了排序操作，速度相对比union要快，如果没有去重的需求，优先使用union all</li>
<li>如果UNION结果中有使用limit，在2个子SQL可能有许多返回值的情况下，各自加上limit。如果还有order by，请找DBA。</li>
</ul>
</li>
<li><h3 id="IN的内容尽量不超过200个"><a href="#IN的内容尽量不超过200个" class="headerlink" title="IN的内容尽量不超过200个"></a>IN的内容尽量不超过200个</h3><p>超过500个值使用批量的方式，否则一次执行会影响数据库的并发能力，因为单SQL只能且一直占用单CPU，而且可能导致主从复制延迟</p>
</li>
<li><h3 id="拒绝大事务"><a href="#拒绝大事务" class="headerlink" title="拒绝大事务"></a>拒绝大事务</h3><p>比如在一个事务里进行多个select，多个update，如果是高频事务，会严重影响MySQL并发能力，因为事务持有的锁等资源只在事务rollback/commit时才能释放。但同时也要权衡数据写入的一致性。</p>
</li>
<li><h3 id="避免使用is-null-is-not-null这样的比较"><a href="#避免使用is-null-is-not-null这样的比较" class="headerlink" title="避免使用is null, is not null这样的比较"></a>避免使用is null, is not null这样的比较</h3></li>
<li><h3 id="order-by-limit"><a href="#order-by-limit" class="headerlink" title="order by .. limit"></a>order by .. limit</h3><p>这种查询更多的是通过索引去优化，但order by的字段有讲究，比如主键id与f_time都是顺序递增，那就可以考虑order by id而非 f_time 。</p>
</li>
<li><h3 id="c1-lt-a-order-by-c2"><a href="#c1-lt-a-order-by-c2" class="headerlink" title="c1 &lt; a order by c2"></a>c1 &lt; a order by c2</h3><p>与上面不同的是，order by之前有个范围查询，由前面的内容可知，用不到类似(c1,c2)的索引，但是可以利用(c2,c1)索引。另外还可以改写成join的方式实现。</p>
</li>
<li><h3 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h3><p>建议使用合理的分页方式以提高分页效率，大页情况下不使用跳跃式分页<br>假如有类似下面分页语句:<br>SELECT <em> FROM table1 ORDER BY ftime DESC LIMIT 10000,10;<br>这种分页方式会导致大量的io，因为MySQL使用的是提前读取策略。<br>推荐分页方式：<br>SELECT </em> FROM table1  WHERE ftime &lt; last_time ORDER BY ftime DESC LIMIT 10<br>即传入上一次分页的界值</p>
<p>SELECT * FROM table as t1 inner JOIN (SELECT id FROM table ORDER BY time LIMIT 10000，10) as t2 ON t1.id=t2.id</p>
</li>
<li><h3 id="count计数"><a href="#count计数" class="headerlink" title="count计数"></a>count计数</h3><ul>
<li>首先count(<em>)、count(1)、count(col1)是有区别的，count(</em>)表示整个结果集有多少条记录，count(1)表示结果集里以primary key统计数量，绝大多数情况下count(<em>)与count(1)效果一样的，但count(col1)表示的是结果集里 col1 列 NOT null 的记录数。优先采用count(</em>)</li>
<li>大数据量count是消耗资源的操作，甚至会拖慢整个库，查询性能问题无法解决的，应从产品设计上进行重构。例如当频繁需要count的查询，考虑使用汇总表</li>
<li>遇到distinct的情况，group by方式可能效率更高。</li>
</ul>
</li>
<li><h3 id="delete-update语句改成select再explain"><a href="#delete-update语句改成select再explain" class="headerlink" title="delete,update语句改成select再explain"></a>delete,update语句改成select再explain</h3><p>select最多导致数据库慢，写操作才是锁表的罪魁祸首</p>
</li>
<li><h3 id="减少与数据库交互的次数，尽量采用批量SQL语句"><a href="#减少与数据库交互的次数，尽量采用批量SQL语句" class="headerlink" title="减少与数据库交互的次数，尽量采用批量SQL语句"></a>减少与数据库交互的次数，尽量采用批量SQL语句</h3><ul>
<li><code>INSERT ... ON DUPLICATE KEY UPDATE ...</code>，插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行旧行UPDATE，如果不重复则直接插入，影响1行。</li>
<li><code>REPLACE INTO</code>类似，但它是冲突时删除旧行。<code>INSERT IGNORE</code>相反，保留旧行，丢弃要插入的新行。</li>
<li>INSERT INTO VALUES(),(),()，合并插入。</li>
</ul>
</li>
<li><h3 id="杜绝危险SQL"><a href="#杜绝危险SQL" class="headerlink" title="杜绝危险SQL"></a>杜绝危险SQL</h3><ul>
<li>去掉where 1=1 这样无意义或恒真的条件，如果遇到update/delete或遭到sql注入就恐怖了</li>
<li>SQL中不允许出现DDL语句。一般也不给予create/alter这类权限，但阿里云RDS只区分读写用户</li>
</ul>
</li>
</ol>
<h2 id="6-行为规范"><a href="#6-行为规范" class="headerlink" title="6. 行为规范"></a>6. 行为规范</h2><ul>
<li>不允许在DBA不知情的情况下导现网数据</li>
<li>大批量更新，如修复数据，避开高峰期，并通知DBA。直接执行sql的由运维或DBA同事操作</li>
<li>及时处理已下线业务的SQL</li>
<li>复杂sql上线审核<br>因为目前还没有SQL审查机制，复杂sql如多表join,count,group by，主动上报DBA评估。</li>
<li>重要项目的数据库方案选型和设计必须提前通知DBA参与</li>
</ul>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul>
<li><a href="http://wangwei007.blog.51cto.com/68019/1709769" target="_blank" rel="external">互联网MySQL开发规范</a> 这个基本也是《去哪儿MySQL开发规范.pdf》版本</li>
<li>MySQL数据库开发的三十六条军规<em>石展</em>完整.pdf</li>
<li><a href="http://imysql.com/2015/07/23/something-important-about-mysql-design-reference.shtml" target="_blank" rel="external">老叶观点：MySQL开发规范之我见</a></li>
<li><a href="http://blog.csdn.net/xlgen157387/article/details/48086607" target="_blank" rel="external">MySQL开发规范与使用技巧总结</a></li>
<li><a href="http://highdb.com/mysql%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" target="_blank" rel="external">http://highdb.com/mysql%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</a></li>
</ul>
<hr>
<p>本文链接地址：<a href="http://seanlook.com/2016/05/11/mysql-dev-principle-ec/">http://seanlook.com/2016/05/11/mysql-dev-principle-ec/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;!-- 

http://highdb.com/mysql%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/
http://blog.csdn.net/xlgen157387/article/details/48086607
http://www.iteye.com/topic/1141229
--&gt;
&lt;p&gt;最近一段时间一边在线上抓取SQL来优化，一边在整理这个开发规范，尽量减少新的问题SQL进入生产库。今天也是对公司的开发做了一次培训，PPT就不放上来了，里面有十来个生产SQL的案例。因为规范大部分还是具有通用性，所以也借鉴了像去哪儿和赶集的规范，但实际在撰写本文的过程中，每一条规范的背后无不是在工作中有参照的反面例子的。如果时间可以的话，会抽出一部分或分析其原理，或用案例证明。&lt;/p&gt;
&lt;h2 id=&quot;1-命名规范&quot;&gt;&lt;a href=&quot;#1-命名规范&quot; class=&quot;headerlink&quot; title=&quot;1. 命名规范&quot;&gt;&lt;/a&gt;1. 命名规范&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;库名、表名、字段名必须使用小写字母，并采用下划线分割&quot;&gt;&lt;a href=&quot;#库名、表名、字段名必须使用小写字母，并采用下划线分割&quot; class=&quot;headerlink&quot; title=&quot;库名、表名、字段名必须使用小写字母，并采用下划线分割&quot;&gt;&lt;/a&gt;库名、表名、字段名必须使用小写字母，并采用下划线分割&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MySQL有配置参数lower_case_table_names=1，即库表名以小写存储，大小写不敏感。如果是0，则库表名以实际情况存储，大小写敏感；如果是2，以实际情况存储，但以小写比较。&lt;/li&gt;
&lt;li&gt;如果大小写混合使用，可能存在abc，Abc，ABC等多个表共存，容易导致混乱。&lt;/li&gt;
&lt;li&gt;字段名显示区分大小写，但实际使⽤时不区分，即不可以建立两个名字一样但大小写不一样的字段。&lt;/li&gt;
&lt;li&gt;为了统一规范， 库名、表名、字段名使用小写字母。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;库名以-d-开头，表名以-t-开头，字段名以-f-开头&quot;&gt;&lt;a href=&quot;#库名以-d-开头，表名以-t-开头，字段名以-f-开头&quot; class=&quot;headerlink&quot; title=&quot;库名以 d 开头，表名以 t 开头，字段名以 f_ 开头&quot;&gt;&lt;/a&gt;库名以 d&lt;em&gt; 开头，表名以 t&lt;/em&gt; 开头，字段名以 f_ 开头&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;比如表 &lt;code&gt;t_crm_relation&lt;/code&gt;，中间的 crm 代表业务模块名&lt;/li&gt;
&lt;li&gt;视图以&lt;code&gt;view_&lt;/code&gt;开头，事件以&lt;code&gt;event_&lt;/code&gt;开头，触发器以&lt;code&gt;trig_&lt;/code&gt;开头，存储过程以&lt;code&gt;proc_&lt;/code&gt;开头，函数以&lt;code&gt;func_&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;普通索引以&lt;code&gt;idx_col1_col2&lt;/code&gt;命名，唯一索引以&lt;code&gt;uk_col1_col2&lt;/code&gt;命名（可去掉f_公共部分）。如 idx_companyid_corpid_contacttime(f_company_id,f_corp_id,f_contact_time)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;库名、表名、字段名禁止超过32个字符，需见名知意&quot;&gt;&lt;a href=&quot;#库名、表名、字段名禁止超过32个字符，需见名知意&quot; class=&quot;headerlink&quot; title=&quot;库名、表名、字段名禁止超过32个字符，需见名知意&quot;&gt;&lt;/a&gt;库名、表名、字段名禁止超过32个字符，需见名知意&lt;/h3&gt;&lt;p&gt;库名、表名、字段名支持最多64个字符，但为了统一规范、易于辨识以及减少传输量，禁止超过32个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;临时库、表名须以tmp加日期为后缀&quot;&gt;&lt;a href=&quot;#临时库、表名须以tmp加日期为后缀&quot; class=&quot;headerlink&quot; title=&quot;临时库、表名须以tmp加日期为后缀&quot;&gt;&lt;/a&gt;临时库、表名须以tmp加日期为后缀&lt;/h3&gt;&lt;p&gt;如 t_crm_relation_tmp0425。备份表也类似，形如 &lt;code&gt;_bak20160425&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;按日期时间分表须符合-YYYY-MM-DD-格式&quot;&gt;&lt;a href=&quot;#按日期时间分表须符合-YYYY-MM-DD-格式&quot; class=&quot;headerlink&quot; title=&quot;按日期时间分表须符合_YYYY[MM][DD]格式&quot;&gt;&lt;/a&gt;按日期时间分表须符合_YYYY[MM][DD]格式&lt;/h3&gt;&lt;p&gt;这也是为将来有可能分表做准备的，比如&lt;code&gt;t_crm_ec_record_201403&lt;/code&gt;，但像 t_crm_contact_at201506就打破了这种规范。&lt;br&gt;不具有时间特性的，直接以 &lt;code&gt;t_tbname_001&lt;/code&gt; 这样的方式命名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-库表基础规范&quot;&gt;&lt;a href=&quot;#2-库表基础规范&quot; class=&quot;headerlink&quot; title=&quot;2. 库表基础规范&quot;&gt;&lt;/a&gt;2. 库表基础规范&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;使用Innodb存储引擎&quot;&gt;&lt;a href=&quot;#使用Innodb存储引擎&quot; class=&quot;headerlink&quot; title=&quot;使用Innodb存储引擎&quot;&gt;&lt;/a&gt;使用Innodb存储引擎&lt;/h3&gt;&lt;p&gt;5.5版本开始mysql默认存储引擎就是InnoDB，5.7版本开始，系统表都放弃MyISAM了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;表字符集统一使用UTF8&quot;&gt;&lt;a href=&quot;#表字符集统一使用UTF8&quot; class=&quot;headerlink&quot; title=&quot;表字符集统一使用UTF8&quot;&gt;&lt;/a&gt;表字符集统一使用UTF8&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;UTF8字符集存储汉字占用3个字节，存储英文字符占用一个字节&lt;/li&gt;
&lt;li&gt;校对字符集使用默认的 utf8_general_ci&lt;/li&gt;
&lt;li&gt;连接的客户端也使用utf8，建立连接时指定charset或&lt;code&gt;SET NAMES UTF8;&lt;/code&gt;。（对于已经在项目中长期使用latin1的，救不了了）&lt;/li&gt;
&lt;li&gt;如果遇到EMOJ等表情符号的存储需求，可申请使用UTF8MB4字符集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;所有表都要添加注释&quot;&gt;&lt;a href=&quot;#所有表都要添加注释&quot; class=&quot;headerlink&quot; title=&quot;所有表都要添加注释&quot;&gt;&lt;/a&gt;所有表都要添加注释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽量给字段也添加注释&lt;/li&gt;
&lt;li&gt;类status型需指明主要值的含义，如”0-离线，1-在线”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;控制单表字段数量&quot;&gt;&lt;a href=&quot;#控制单表字段数量&quot; class=&quot;headerlink&quot; title=&quot;控制单表字段数量&quot;&gt;&lt;/a&gt;控制单表字段数量&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单表字段数上限30左右，再多的话考虑垂直分表，一是冷热数据分离，二是大字段分离，三是常在一起做条件和返回列的不分离。&lt;/li&gt;
&lt;li&gt;表字段控制少而精，可以提高IO效率，内存缓存更多有效数据，从而提高响应速度和并发能力，后续 alter table 也更快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;所有表都必须要显式指定主键&quot;&gt;&lt;a href=&quot;#所有表都必须要显式指定主键&quot; class=&quot;headerlink&quot; title=&quot;所有表都必须要显式指定主键&quot;&gt;&lt;/a&gt;所有表都必须要显式指定主键&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主键尽量采用自增方式，InnoDB表实际是一棵索引组织表，顺序存储可以提高存取效率，充分利用磁盘空间。还有对一些复杂查询可能需要自连接来优化时需要用到。&lt;/li&gt;
&lt;li&gt;需要全局唯一主键时，使用外部发号器ticket server（建设中）&lt;/li&gt;
&lt;li&gt;如果没有主键或唯一索引，update/delete是通过所有字段来定位操作的行，相当于每行就是一次全表扫描&lt;/li&gt;
&lt;li&gt;少数情况可以使用联合唯一主键，需与DBA协商&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;不强制使用外键参考&quot;&gt;&lt;a href=&quot;#不强制使用外键参考&quot; class=&quot;headerlink&quot; title=&quot;不强制使用外键参考&quot;&gt;&lt;/a&gt;不强制使用外键参考&lt;/h3&gt;&lt;p&gt;即使2个表的字段有明确的外键参考关系，也不使用 FOREIGN KEY ，因为新纪录会去主键表做校验，影响性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;适度使用存储过程、视图，禁止使用触发器、事件&quot;&gt;&lt;a href=&quot;#适度使用存储过程、视图，禁止使用触发器、事件&quot; class=&quot;headerlink&quot; title=&quot;适度使用存储过程、视图，禁止使用触发器、事件&quot;&gt;&lt;/a&gt;适度使用存储过程、视图，禁止使用触发器、事件&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="规范" scheme="http://seanlook.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>小心MySQL的隐式类型转换陷阱</title>
    <link href="http://seanlook.com/2016/05/05/mysql-type-conversion/"/>
    <id>http://seanlook.com/2016/05/05/mysql-type-conversion/</id>
    <published>2016-05-05T08:32:49.000Z</published>
    <updated>2016-05-05T08:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-隐式类型转换实例"><a href="#1-隐式类型转换实例" class="headerlink" title="1. 隐式类型转换实例"></a>1. 隐式类型转换实例</h2><p>今天生产库上突然出现MySQL线程数告警，IOPS很高，实例会话里面出现许多类似下面的sql：(修改了相关字段和值)</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT f_col3_id,f_qq1_id FROM d_dbname.t_tb1 WHERE f_col1_id=<span class="number">1226391</span> and f_col2_id=<span class="number">1244378</span> and </div><div class="line">f_qq1_id in (<span class="number">12345</span>,<span class="number">23456</span>,<span class="number">34567</span>,<span class="number">45678</span>,<span class="number">56789</span>,<span class="number">67890</span>,<span class="number">78901</span>,<span class="number">89012</span>,<span class="number">90123</span>,<span class="number">901231</span>,<span class="number">901232</span>,<span class="number">901233</span>)</div></pre></td></tr></table></figure>
<p>用 explain 看了下扫描行数和索引选择情况： </p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain SELECT f<span class="emphasis">_col3_</span>id,f<span class="emphasis">_qq1_</span>id FROM d<span class="emphasis">_dbname.t_</span>tb1 WHERE f<span class="emphasis">_col1_</span>id=1226391 </div><div class="line"><span class="section">and f_col2_id=1244378 and f_qq1_id in (12345,23456,34567,45678,56789,67890,78901,89012,90123,901231,901232,901233);</span></div><div class="line">+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+</div><div class="line"><span class="section">| id   | select_type   | table   | type   | possible_keys                  | key           | key_len    | ref    | rows   | Extra                              |</span></div><div class="line">+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+</div><div class="line"><span class="section">| 1    | SIMPLE        | t_tb1   | ref    | uid_type_frid,idx_corpid_qq1id | uid_type_frid | 8          | const  | 1386   | Using index condition; Using where |</span></div><div class="line">+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+</div><div class="line">共返回 1 行记录,花费 11.52 ms.</div></pre></td></tr></table></figure>
<p>t_tb1 表上有个索引<code>uid_type_frid(f_col2_id,f_type)</code>、<code>idx_corp_id_qq1id(f_col1_id,f_qq1_id)</code>，而且如果选择后者时，f_qq1_id的过滤效果应该很佳，但却选择了前者。当使用 hint <code>use index(idx_corp_id_qq1id)</code>时：<br><a id="more"></a><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain extended SELECT f_col3_id,f_qq1_id FROM d_dbname.t_tb1  use index(idx_corpid_qq1id) WHERE f_col1_id=<span class="number">1226391</span> <span class="literal">and</span> f_col2_id=<span class="number">1244378</span> <span class="literal">and</span> f_qq1_id in (<span class="number">12345</span>,<span class="number">23456</span>,<span class="number">34567</span>,<span class="number">45678</span>,<span class="number">56789</span>,<span class="number">67890</span>,<span class="number">78901</span>,<span class="number">89012</span>,<span class="number">90123</span>,<span class="number">901231</span>,<span class="number">901232</span>,<span class="number">901233</span>)<span class="comment">;</span></div><div class="line">+------+---------------+--------+--------+---------------------+------------------+------------+----------+-------------+------------------------------------+</div><div class="line">| id   | select_type   | table  | type   | possible_keys       | key              | key_len    | ref      | rows        | Extra                              |</div><div class="line">+------+---------------+--------+--------+---------------------+------------------+------------+----------+-------------+------------------------------------+</div><div class="line">| <span class="number">1</span>    | SIMPLE        | t_tb1  | ref    | idx_corpid_qq1id    | idx_corpid_qq1id | <span class="number">8</span>          | const    | <span class="number">2375752</span>     | Using index condition<span class="comment">; Using where |</span></div><div class="line">+---- -+---------------+--------+--------+---------------------+------------------+------------+----------+-------------+------------------------------------+</div><div class="line">共返回 <span class="number">1</span> 行记录,花费 <span class="number">17.48</span> ms.</div><div class="line"></div><div class="line">mysql&gt;show warnings<span class="comment">;</span></div><div class="line">+-----------------+----------------+-----------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Level           | Code           | Message                                                                                                               |</div><div class="line">+-----------------+----------------+-----------------------------------------------------------------------------------------------------------------------+</div><div class="line">| Warning         |           <span class="number">1739</span> | Cannot use range access on index 'idx_corpid_qq1id' due to type <span class="literal">or</span> collation conversion on field 'f_qq1_id'           |</div><div class="line">| Note            |           <span class="number">1003</span> | /* select#<span class="number">1</span> */ select `d_dbname`.`t_tb1`.`f_col3_id` AS `f_col3_id`,`d_dbname`.`t_tb1`.`f_qq1_id` AS `f_qq1_id` from `d_dbname`.`t_tb1` USE INDEX (`idx_corpid_qq1id`) where |</div><div class="line">|                 |                |  ((`d_dbname`.`t_tb1`.`f_col2_id` = <span class="number">1244378</span>) <span class="literal">and</span> (`d_dbname`.`t_tb1`.`f_col1_id` = <span class="number">1226391</span>) <span class="literal">and</span> (`d_dbname`.`t_tb1`.`f_qq1_id` in |</div><div class="line">|                 |                | (<span class="number">12345</span>,<span class="number">23456</span>,<span class="number">34567</span>,<span class="number">45678</span>,<span class="number">56789</span>,<span class="number">67890</span>,<span class="number">78901</span>,<span class="number">89012</span>,<span class="number">90123</span>,<span class="number">901231</span>,<span class="number">901232</span>,<span class="number">901233</span>)))                                        |</div><div class="line">+-----------------+----------------+-----------------------------------------------------------------------------------------------------------------------+</div><div class="line">共返回 <span class="number">2</span> 行记录,花费 <span class="number">10.81</span> ms.</div></pre></td></tr></table></figure></p>
<p>rows列达到200w行，但问题也发现了：select_type应该是 range 才对，key_len看出来只用到了<code>idx_corpid_qq1id</code>索引的第一列。上面explain使用了 <code>extended</code>，所以<code>show warnings;</code>可以很明确的看到 f_qq1_id 出现了隐式类型转换：f_qq1_id是varchar，而后面的比较值是整型。</p>
<p>解决该问题就是避免出现隐式类型转换(implicit type conversion)带来的不可控：把f_qq1_id in的内容写成字符串：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt;explain SELECT f<span class="emphasis">_col3_</span>id,f<span class="emphasis">_qq1_</span>id FROM d<span class="emphasis">_dbname.t_</span>tb1 WHERE f<span class="emphasis">_col1_</span>id=1226391 and f<span class="emphasis">_col2_</span>id=1244378 and </div><div class="line"><span class="section">f_qq1_id in ('12345','23456','34567','45678','56789','67890','78901','89012','90123','901231');</span></div><div class="line">+-------+---------------+--------+---------+--------------------------------+------------------+-------------+---------+---------+------------------------------------+</div><div class="line"><span class="section">| id    | select_type   | table  | type    | possible_keys                  | key              | key_len     | ref     | rows    | Extra                              |</span></div><div class="line">+-------+---------------+--------+---------+--------------------------------+------------------+-------------+---------+---------+------------------------------------+</div><div class="line"><span class="section">| 1     | SIMPLE        | t_tb1  | range   | uid_type_frid,idx_corpid_qq1id | idx_corpid_qq1id | 70          |         | 40      | Using index condition; Using where |</span></div><div class="line">+-------+---------------+--------+---------+--------------------------------+------------------+-------------+---------+---------+------------------------------------+</div><div class="line">共返回 1 行记录,花费 12.41 ms.</div></pre></td></tr></table></figure>
<p>扫描行数从1386减少为40。</p>
<p>类似的还出现过一例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">0</span>)  <span class="keyword">FROM</span> d_dbname.t_tb2 <span class="keyword">where</span> f_col1_id= <span class="string">'1931231'</span>  <span class="keyword">AND</span> f_phone <span class="keyword">in</span>(<span class="number">098890</span>);</div><div class="line"></div><div class="line">| Warning | 1292 | Truncated incorrect DOUBLE value: '1512-98464356'</div></pre></td></tr></table></figure>
<p>优化后直接从扫描rows 100w行降为1。</p>
<p>借这个机会，系统的来看一下mysql中的隐式类型转换。</p>
<h2 id="2-mysql隐式转换规则"><a href="#2-mysql隐式转换规则" class="headerlink" title="2. mysql隐式转换规则"></a>2. mysql隐式转换规则</h2><h3 id="2-1-规则"><a href="#2-1-规则" class="headerlink" title="2.1 规则"></a>2.1 规则</h3><p>下面来分析一下<a href="http://dev.mysql.com/doc/refman/5.7/en/type-conversion.html" target="_blank" rel="external">隐式转换的规则</a>：</p>
<blockquote>
<p>a. 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换<br>b. 两个参数都是字符串，会按照字符串来比较，不做类型转换<br>c. 两个参数都是整数，按照整数来比较，不做类型转换<br>d. 十六进制的值和非数字做比较时，会被当做二进制串<br>e. 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp<br>f. 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较<br>g. 所有其他情况下，两个参数都会被转换为浮点数再进行比较</p>
</blockquote>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; select 11 + '11', 11 + 'aa', 'a1' + 'bb', 11 + '0.01a';  </span></div><div class="line">+-----------+-----------+-------------+--------------+</div><div class="line"><span class="section">| 11 + '11' | 11 + 'aa' | 'a1' + 'bb' | 11 + '0.01a' |</span></div><div class="line">+-----------+-----------+-------------+--------------+</div><div class="line"><span class="section">|        22 |        11 |           0 |        11.01 |</span></div><div class="line">+-----------+-----------+-------------+--------------+</div><div class="line">1 row in set, 4 warnings (0.00 sec)</div><div class="line"></div><div class="line"><span class="section">mysql&gt; show warnings;</span></div><div class="line">+---------+------+-------------------------------------------+</div><div class="line"><span class="section">| Level   | Code | Message                                   |</span></div><div class="line">+---------+------+-------------------------------------------+</div><div class="line">| Warning | 1292 | Truncated incorrect DOUBLE value: <span class="emphasis">'aa'</span>    |</div><div class="line">| Warning | 1292 | Truncated incorrect DOUBLE value: <span class="emphasis">'a1'</span>    |</div><div class="line">| Warning | 1292 | Truncated incorrect DOUBLE value: <span class="emphasis">'bb'</span>    |</div><div class="line"><span class="section">| Warning | 1292 | Truncated incorrect DOUBLE value: '0.01a' |</span></div><div class="line">+---------+------+-------------------------------------------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">mysql&gt; select '11a' = 11, '11.0' = 11, '11.0' = '11', NULL = 1;</span></div><div class="line">+------------+-------------+---------------+----------+</div><div class="line"><span class="section">| '11a' = 11 | '11.0' = 11 | '11.0' = '11' | NULL = 1 |</span></div><div class="line">+------------+-------------+---------------+----------+</div><div class="line"><span class="section">|          1 |           1 |             0 |     NULL |</span></div><div class="line">+------------+-------------+---------------+----------+</div><div class="line">1 row in set, 1 warning (0.01 sec)</div></pre></td></tr></table></figure>
<p>上面可以看出<code>11 + &#39;aa&#39;</code>，由于操作符两边的类型不一样且符合第g条，<code>aa</code>要被转换成浮点型小数，然而转换失败（字母被截断），可以认为转成了 0，整数<code>11</code>被转成浮点型还是它自己，所以<code>11 + &#39;aa&#39; = 11</code>。</p>
<p><code>0.01a</code>转成double型也是被截断成<code>0.01</code>，所以<code>11 + &#39;0.01a&#39; = 11.01</code>。</p>
<p>等式比较也说明了这一点，<code>&#39;11a&#39;</code>和<code>&#39;11.0&#39;</code>转换后都等于 <code>11</code>，这也正是文章开头实例为什么没走索引的原因： varchar型的f_qq1_id，转换成浮点型比较时，等于 12345 的情况有无数种如12345a、12345.b等待，MySQL优化器无法确定索引是否更有效，所以选择了其它方案。</p>
<p>但并不是只要出现隐式类型转换，就会引起上面类似的性能问题，最终是要看转换后能否有效选择索引。像<code>f_id = &#39;654321&#39;</code>、<code>f_mtime between &#39;2016-05-01 00:00:00&#39; and &#39;2016-05-04 23:59:59&#39;</code>就不会影响索引选择，因为前者f_id是整型，即使与后面的字符串型数字转换成double比较，依然能根据double确定f_id的值，索引依然有效。后者是因为符合第e条，只是右边的常量做了转换。</p>
<p>开发人员可能都只要存在这么一个隐式类型转换的坑，但却又经常不注意，所以干脆无需记住那么多规则，该什么类型就与什么类型比较。</p>
<h3 id="2-2-隐式类型转换的安全问题"><a href="#2-2-隐式类型转换的安全问题" class="headerlink" title="2.2 隐式类型转换的安全问题"></a>2.2 隐式类型转换的安全问题</h3><p>implicit type conversion 不仅可能引起性能问题，还有可能产生安全问题。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; desc t_account;</span></div><div class="line">+-----------+-------------+------+-----+---------+----------------+</div><div class="line"><span class="section">| Field     | Type        | Null | Key | Default | Extra          |</span></div><div class="line">+-----------+-------------+------+-----+---------+----------------+</div><div class="line">| fid       | int(11)     | NO   | PRI | NULL    | auto<span class="emphasis">_increment |</span></div><div class="line">| fname     | varchar(20) | YES  |     | NULL    |                |</div><div class="line">| fpassword | varchar(50) | YES  |     | NULL    |                |</div><div class="line">+-----------+-------------+------+-----+---------+----------------+</div><div class="line"></div><div class="line"><span class="section">mysql&gt; select * from t_account;</span></div><div class="line">+-----+-----------+-------------+</div><div class="line"><span class="section">| fid | fname     | fpassword   |</span></div><div class="line">+-----+-----------+-------------+</div><div class="line">|   1 | xiaoming  | p<span class="emphasis">_xiaoming  |</span></div><div class="line">|   2 | xiaoming1 | p_xiaoming1 |</div><div class="line"><span class="code">+-----+</span>-----------<span class="code">+-------------+</span></div><div class="line"></div><div class="line">假如应用前端没有WAF防护，那么下面的sql很容易注入：</div><div class="line">mysql&gt; select * from t<span class="emphasis">_account where fname='A' ;</span></div><div class="line"></div><div class="line">fname传入  A' OR 1=<span class="emphasis">'1  </span></div><div class="line"></div><div class="line">mysql&gt; select * from t<span class="emphasis">_account where fname='A' OR 1='1';</span></div></pre></td></tr></table></figure></p>
<p>攻击者更聪明一点： fname传入 <code>A&#39;+&#39;B</code>  ，fpassword传入 <code>ccc&#39;+0</code> ：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">mysql&gt; select * from t_account where fname='A'+'B' and fpassword='ccc'+0;</span></div><div class="line">+-----+-----------+-------------+</div><div class="line"><span class="section">| fid | fname     | fpassword   |</span></div><div class="line">+-----+-----------+-------------+</div><div class="line">|   1 | xiaoming  | p<span class="emphasis">_xiaoming  |</span></div><div class="line">|   2 | xiaoming1 | p_xiaoming1 |</div><div class="line"><span class="code">+-----+</span>-----------<span class="code">+-------------+</span></div><div class="line">2 rows in set, 7 warnings (0.00 sec)</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yq.aliyun.com/articles/39477" target="_blank" rel="external">MySQL隐式转化整理</a></li>
<li><a href="http://blog.itpub.net/22418990/viewspace-1302080/" target="_blank" rel="external">WHRER条件里的数据类型必须和字段数据类型一致</a></li>
<li><a href="https://vagosec.org/2013/04/mysql-implicit-type-conversion/" target="_blank" rel="external">Implicit type conversion in MySQL</a></li>
</ul>
<hr>
<p>原文链接地址：<a href="http://seanlook.com/2016/05/05/mysql-type-conversion/">http://seanlook.com/2016/05/05/mysql-type-conversion/</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-隐式类型转换实例&quot;&gt;&lt;a href=&quot;#1-隐式类型转换实例&quot; class=&quot;headerlink&quot; title=&quot;1. 隐式类型转换实例&quot;&gt;&lt;/a&gt;1. 隐式类型转换实例&lt;/h2&gt;&lt;p&gt;今天生产库上突然出现MySQL线程数告警，IOPS很高，实例会话里面出现许多类似下面的sql：(修改了相关字段和值)&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;SELECT f_col3_id,f_qq1_id FROM d_dbname.t_tb1 WHERE f_col1_id=&lt;span class=&quot;number&quot;&gt;1226391&lt;/span&gt; and f_col2_id=&lt;span class=&quot;number&quot;&gt;1244378&lt;/span&gt; and &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;f_qq1_id in (&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23456&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;34567&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;45678&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;56789&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;67890&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;78901&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;89012&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;90123&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;901231&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;901232&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;901233&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用 explain 看了下扫描行数和索引选择情况： &lt;/p&gt;
&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt;explain SELECT f&lt;span class=&quot;emphasis&quot;&gt;_col3_&lt;/span&gt;id,f&lt;span class=&quot;emphasis&quot;&gt;_qq1_&lt;/span&gt;id FROM d&lt;span class=&quot;emphasis&quot;&gt;_dbname.t_&lt;/span&gt;tb1 WHERE f&lt;span class=&quot;emphasis&quot;&gt;_col1_&lt;/span&gt;id=1226391 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;and f_col2_id=1244378 and f_qq1_id in (12345,23456,34567,45678,56789,67890,78901,89012,90123,901231,901232,901233);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;| id   | select_type   | table   | type   | possible_keys                  | key           | key_len    | ref    | rows   | Extra                              |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;| 1    | SIMPLE        | t_tb1   | ref    | uid_type_frid,idx_corpid_qq1id | uid_type_frid | 8          | const  | 1386   | Using index condition; Using where |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+------+---------------+---------+--------+--------------------------------+---------------+------------+--------+--------+------------------------------------+&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;共返回 1 行记录,花费 11.52 ms.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;t_tb1 表上有个索引&lt;code&gt;uid_type_frid(f_col2_id,f_type)&lt;/code&gt;、&lt;code&gt;idx_corp_id_qq1id(f_col1_id,f_qq1_id)&lt;/code&gt;，而且如果选择后者时，f_qq1_id的过滤效果应该很佳，但却选择了前者。当使用 hint &lt;code&gt;use index(idx_corp_id_qq1id)&lt;/code&gt;时：&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://seanlook.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://seanlook.com/tags/mysql/"/>
    
      <category term="schema设计" scheme="http://seanlook.com/tags/schema%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
